var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/context/BridgeContext.ts
import { createWalletClient, custom, http } from "viem";
import { createAztecNodeClient as createAztecNodeClient2 } from "@aztec/aztec.js/node";
import { AztecAddress as AztecAddress2 } from "@aztec/aztec.js/addresses";
import { privateKeyToAccount } from "viem/accounts";

// src/utils/artifacts/AztecGateway7683/AztecGateway7683.ts
import { loadContractArtifact, loadContractArtifactForPublic } from "@aztec/aztec.js/abi";
import { Contract, ContractBase, DeployMethod } from "@aztec/aztec.js/contracts";
import { Fr } from "@aztec/aztec.js/fields";
import { PublicKeys } from "@aztec/aztec.js/keys";

// src/utils/artifacts/AztecGateway7683/aztec_gateway_7683-AztecGateway7683.json
var aztec_gateway_7683_AztecGateway7683_default = {
  file_map: {
    "106": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      source: 'use dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress,\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a "magical value" that makes the proof below pass. Hence it\'s safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            "Proving public value inclusion failed",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that\'s represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                "Public data tree index doesn\'t match witness",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n'
    },
    "111": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      source: 'use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address\'s preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        "Invalid public keys hint for address",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = "Invalid public keys hint for address")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock("utilityGetPublicKeysAndPartialAddress").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n'
    },
    "115": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      source: 'use crate::macros::{\n    calls_generation::{\n        external_functions::{\n            generate_external_function_calls, generate_external_function_self_calls_structs,\n        },\n        internal_functions::generate_call_internal_struct,\n    },\n    dispatch::generate_public_dispatch,\n    internals_functions_generation::{create_fn_abi_exports, process_functions},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{\n        get_trait_impl_method, is_fn_contract_library_method, is_fn_external, is_fn_internal,\n        is_fn_test, module_has_storage,\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    // Functions that don\'t have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate new functions prefixed with `__aztec_nr_internals__` and we replace the original functions\' bodies\n    // with `static_assert(false, ...)` to prevent them from being called directly from within the contract.\n    let functions = process_functions(m);\n\n    // We generate structs and their implementations necessary for convenient functions calls.\n    let interface = generate_contract_interface(m);\n    let self_call_structs = generate_external_function_self_calls_structs(m);\n    let call_internal_struct = generate_call_internal_struct(m);\n\n    // We generate ABI exports for all the external functions in the contract.\n    let fn_abi_exports = create_fn_abi_exports(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { sync_private_state }\n    }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n\n    let process_message_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { process_message }\n    }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $self_call_structs\n        $call_internal_struct\n        $functions\n        $fn_abi_exports\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state_fn_and_abi_export\n        $process_message_fn_and_abi_export\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let calls = generate_external_function_calls(m);\n\n    let module_name = m.name();\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $calls\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we\'re about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, owner, storage_slot, randomness);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note,\n                                contract_address,\n                                owner,\n                                randomness,\n                                storage_slot,\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, owner, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                owner: aztec::protocol_types::address::AztecAddress,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                randomness: Field,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _owner: aztec::protocol_types::address::AztecAddress,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _randomness: Field,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f"This contract does not use private notes")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    quote {\n        pub struct sync_private_state_parameters {}\n\n        #[abi(functions)]\n        pub struct sync_private_state_abi {\n            parameters: sync_private_state_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn sync_private_state() {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n            \n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    quote {\n        pub struct process_message_parameters {\n            pub message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            pub message_context: aztec::messages::processing::message_context::MessageContext,\n        }\n\n        #[abi(functions)]\n        pub struct process_message_abi {\n            parameters: process_message_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n\n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);     \n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                address,\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\ncomptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_internal(f)\n            & !is_fn_test(f) {\n            // We  don\'t suggest that #[contract_library_method] is allowed because we don\'t want to introduce another\n            // concept\n            panic(\n                f"Function {name} must be marked as either #[external(...)], #[internal(...)], or #[test]",\n            );\n        }\n    }\n}\n'
    },
    "117": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/calls_generation/external_functions_stubs.nr",
      source: "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector};\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, serialized_args_array_len_quote, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n    let serialized_args_array_len: u32 =\n        unquote!(quote { ($serialized_args_array_len_quote) as u32 });\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        serialized_args_array_len, fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\npub(crate) comptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PrivateCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PrivateStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PrivateStaticCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PublicCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::PublicStaticCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\npub(crate) comptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::calls::UtilityCall<$fn_name_len, $serialized_args_array_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::calls::UtilityCall::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\n// Self-call stub generation functions for CallSelf, CallSelfStatic, EnqueueSelf and EnqueueSelfStatic structs\n\n// Note: Unlike for the call registry, the self-call registry stubs directly perform the call instead of returning a\n// call interface struct.\n// TODO(F-131): This ^ is confusing and should be reflected in the naming.\n\n/// Creates a stub for calling a private function (or static private function if `is_static` is true) from private\n/// context (for CallSelf<&mut PrivateContext> and CallSelfStatic<&mut PrivateContext>).\npub comptime fn create_private_self_call_stub(f: FunctionDefinition, is_static: bool) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, _, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let args_hash = aztec::hash::hash_args($serialized_args_array_name);\n            aztec::oracle::execution_cache::store($serialized_args_array_name, args_hash);\n            let returns_hash = self.context.call_private_function_with_args_hash(\n                self.address,\n                selector,\n                args_hash,\n                $is_static\n            );\n            returns_hash.get_preimage()\n        }\n    }\n}\n\n// TODO(F-131): Drop the use of the Call in the following 4 functions - it doesn't make sense to not not\n// perform the call directly using the context. I tried doing this already but it became a lot of pain due to the use of\n// slices and them being illegal to return from unconstrained functions. Makes sense to tackle this when cleaning up the\n// call interface code.\n// Note: Once we get rid of the structs we will be able to merge some of the static and non-static stub functions.\n\n/// Creates a stub for calling a public function from public context (for CallSelf<PublicContext>)\npub comptime fn create_public_self_call_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            unsafe {\n                aztec::context::calls::PublicCall::new(\n                    self.address,\n                    selector,\n                    $fn_name_str,\n                    $serialized_args_array_name,\n                ).call(self.context)\n            }\n        }\n    }\n}\n\n/// Creates a static stub for calling a public view function from public context (for CallSelfStatic<PublicContext>)\npub comptime fn create_public_self_call_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, _, fn_name_str, _, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> $fn_return_type {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            unsafe {\n                aztec::context::calls::PublicStaticCall::new(\n                    self.address,\n                    selector,\n                    $fn_name_str,\n                    $serialized_args_array_name,\n                ).view(self.context)\n            }\n        }\n    }\n}\n\n/// Creates a static stub for enqueuing a public view function from private context (for EnqueueSelfStatic<&mut PrivateContext>)\npub comptime fn create_public_self_enqueue_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let interface: aztec::context::calls::PublicStaticCall<$fn_name_len, $serialized_args_array_len, ()> = aztec::context::calls::PublicStaticCall::new(\n                self.address,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            );\n            interface.enqueue_view(self.context);\n        }\n    }\n}\n\n/// Creates a stub for enqueuing a public function from private context (for EnqueueSelf<&mut PrivateContext>)\npub comptime fn create_public_self_enqueue_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, serialized_args_array_len, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            let interface: aztec::context::calls::PublicCall<$fn_name_len, $serialized_args_array_len, ()> = aztec::context::calls::PublicCall::new(\n                self.address,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            );\n            interface.enqueue(self.context);\n        }\n    }\n}\n"
    },
    "12": {
      path: "std/convert.nr",
      source: "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      source: 'use crate::macros::internals_functions_generation::external_functions_registry::get_public_functions;\nuse super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that\'s assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = get_public_functions(m);\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it\'s possible to have collisions. With the following check, we ensure it doesn\'t happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f"Public function selector collision detected between functions \'{fn_name}\' and \'{existing_fn}\'",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f"arg{parameter_index_value}".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f"arg{parameter_index}".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        // We call a function whose name is prefixed with `__aztec_nr_internals__`. This is necessary because the\n        // original function is intentionally made uncallable, preventing direct invocation within the contract.\n        // Instead, a new function with the same name, but prefixed by `__aztec_nr_internals__`, has been generated to\n        // be called here. For more details see the `process_functions` function.\n        let name = f"__aztec_nr_internals__{fn_name}".quoted_contents();\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f"Unknown selector {selector}") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public functions having this attribute.\n            #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n'
    },
    "123": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      source: 'use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won\'t find it through searching)\npub fn mark_as_initialized_public(context: PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won\'t find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won\'t find it through searching)\npub fn assert_is_initialized_public(context: PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), "Not initialized");\n}\n\n// Used by `create_init_check` (you won\'t find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier, context.this_address());\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won\'t find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, "Initialization hash does not match");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        "Initializer address is not the contract deployer",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won\'t find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, "Initialization hash does not match");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        "Initializer address is not the contract deployer",\n    );\n}\n\n/// This function is not only used in macros but it\'s also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don\'t hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n'
    },
    "127": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/internals_functions_generation/external/helpers.nr",
      source: 'use crate::macros::{\n    functions::auth_registry::AUTHORIZE_ONCE_REGISTRY,\n    utils::{is_fn_initializer, is_fn_only_self, is_fn_view},\n};\nuse std::meta::ctstring::AsCtString;\n\n/// Gathers all attributes relevant to the function\'s ABI and returns a quote that can be applied to the newly generated\n/// function. We apply the abi marker attributes instead of the original ones (e.g. abi_view instead of view) to avoid\n/// the relevant attribute\'s functionality from getting triggered.\npub(crate) comptime fn get_abi_relevant_attributes(f: FunctionDefinition) -> Quoted {\n    let mut attributes = quote {};\n\n    if is_fn_view(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_view] };\n    }\n\n    if is_fn_only_self(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_only_self] };\n    }\n\n    if is_fn_initializer(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_initializer] };\n    }\n\n    attributes\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                self.address,\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, "Invalid authwit nonce. When \'from\' and \'msg_sender\' are the same, authwit_nonce must be zero");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once("from_arg_name", "nonce_arg_name")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f"Functions marked with #[authorize_once] must have the #[external(\\"private\\")] or #[external(\\"public\\")] attribute placed last",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f"{from_arg_name}".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\"...\\", \\"authwit_nonce\\")]",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f"{nonce_arg_name}".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\"from\\", \\"...\\")]",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}",\n        );\n    }\n\n    let nonce_check_quote = f"{nonce_arg_name_quoted} == 0".quoted_contents();\n\n    let fn_call = if is_private {\n        let args_len = f.parameters().len();\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f"Invalid authwit nonce. When \'{from_arg_name}\' and \'msg_sender\' are the same, \'{nonce_arg_name}\' must be zero"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(self.msg_sender().unwrap())) {\n            $fn_call(self.context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n'
    },
    "129": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/internals_functions_generation/external/private.nr",
      source: 'use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, create_message_discovery_call, get_abi_relevant_attributes,\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, fn_has_nophasecheck, is_fn_initializer,\n        is_fn_only_self, is_fn_view, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn generate_private_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n\n    let original_params_quotes = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    let params = quote { inputs: aztec::context::inputs::private_context_inputs::PrivateContextInputs, $original_params_quotes };\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we\'ve received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let storage_init = if module_has_storage {\n        // Contract has Storage defined so we initialize it.\n        quote {\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            $args_serialization\n            let args_hash = aztec::hash::hash_args($serialized_args_name);\n            let mut context = aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<&mut aztec::context::private_context::PrivateContext> = CallSelf { address: self_address, context: &mut context };\n            let enqueue_self: EnqueueSelf<&mut aztec::context::private_context::PrivateContext> = EnqueueSelf { address: self_address, context: &mut context };\n            let call_self_static: CallSelfStatic<&mut aztec::context::private_context::PrivateContext> = CallSelfStatic { address: self_address, context: &mut context };\n            let enqueue_self_static: EnqueueSelfStatic<&mut aztec::context::private_context::PrivateContext> = EnqueueSelfStatic { address: self_address, context: &mut context };\n            let internal: CallInternal<&mut aztec::context::private_context::PrivateContext> = CallInternal { context: &mut context };\n            aztec::contract_self::ContractSelf::new_private(&mut context, storage, call_self, enqueue_self, call_self_static, enqueue_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f"Function {original_function_name} can only be called by the same contract";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f"Function {original_function_name} can only be called statically"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(*self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don\'t have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Phase checks are skipped in functions that request to manually handle phases\n    let initial_phase_store = if fn_has_nophasecheck(f) {\n        quote {}\n    } else {\n        quote { let within_revertible_phase: bool = self.context.in_revertible_phase(); }\n    };\n\n    let no_phase_change_check = if fn_has_nophasecheck(f) {\n        quote {}\n    } else {\n        quote {   \n            assert_eq(\n                within_revertible_phase,\n                self.context.in_revertible_phase(),\n                f"Phase change detected on function with phase check. If this is expected, use #[nophasecheck]",\n            ); \n        }\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don\'t\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            self.context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f"_{return_value_var_name}".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { self.context.finish() };\n\n    // Preserve all attributes that are relevant to the function\'s ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    let fn_name = f"__aztec_nr_internals__{original_function_name}".quoted_contents();\n\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $contract_self_creation\n        $initial_phase_store\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let body_quote = body.map(|expr| expr.quoted()).join(quote { });\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $no_phase_change_check\n        $context_finish\n    };\n\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_private]\n        $abi_relevant_attributes\n        fn $fn_name($params) -> return_data aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs {\n            $to_prepend\n            $body_quote\n            $to_append\n        }\n    }\n}\n'
    },
    "130": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/internals_functions_generation/external/public.nr",
      source: 'use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, get_abi_relevant_attributes,\n    },\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_initializer, is_fn_only_self, is_fn_view,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse std::meta::ctstring::AsCtString;\n\npub(crate) comptime fn generate_public_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::public_context::PublicContext::new(|| {\n            // We start from 1 because we skip the selector for the dispatch function.\n            let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n            dep::aztec::hash::hash_args(serialized_args)\n            });\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<aztec::context::public_context::PublicContext> = CallSelf { address: self_address, context };\n            let call_self_static: CallSelfStatic<aztec::context::public_context::PublicContext> = CallSelfStatic { address: self_address, context };\n            let internal: CallInternal<aztec::context::public_context::PublicContext> = CallInternal { context };\n            aztec::contract_self::ContractSelf::new_public(context, storage, call_self, call_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f"Function {original_function_name} can only be called by the same contract";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f"Function {original_function_name} can only be called statically"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don\'t have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $contract_self_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let fn_name = f"__aztec_nr_internals__{original_function_name}".quoted_contents();\n    let body = f.body();\n    let return_type = f.return_type();\n\n    // New function parameters are the same as the original function\'s ones.\n    let params = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    // Preserve all attributes that are relevant to the function\'s ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n        $abi_relevant_attributes\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n            $to_append\n        }\n    }\n}\n'
    },
    "137": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      source: 'use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f"A contract can contain at most {MAX_NOTE_TYPES} different note types",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f"{name}".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note\'s packed length doesn\'t exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn\'t work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, owner: AztecAddress, storage_slot: Field, randomness: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field, owner: AztecAddress) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field, owner: AztecAddress) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, owner: aztec::protocol_types::address::AztecAddress, storage_slot: Field, randomness: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [aztec::protocol_types::traits::ToField::to_field(owner), storage_slot, randomness]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                owner: aztec::protocol_types::address::AztecAddress,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid "trait not in scope" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                owner: aztec::protocol_types::address::AztecAddress,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid "trait not in scope" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f"{name}Properties".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        let i = i as u8;\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.",\n    );\n}\n'
    },
    "140": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      source: 'use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note\'s packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, owner, storage_slot, note_type_id, contract_address, randomness, note_nonce| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* owner */ AztecAddress, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* randomness */ Field, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log("Performing message discovery");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            "Processing log with tag {0}",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE\'s database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n'
    },
    "141": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      source: `use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};

use dep::protocol_types::{
    address::AztecAddress,
    constants::MAX_NOTE_HASHES_PER_TX,
    debug_log::debug_log_format,
    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},
    traits::ToField,
};

/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*
/// the complete note information, since it does not include content, storage slot, etc.
pub struct DiscoveredNoteInfo {
    pub note_nonce: Field,
    pub note_hash: Field,
    pub inner_nullifier: Field,
}

/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible
/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in
/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most
/// cases it will contain a single element.
///
/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,
/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.
pub unconstrained fn attempt_note_nonce_discovery<Env>(
    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,
    first_nullifier_in_tx: Field,
    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,
    contract_address: AztecAddress,
    owner: AztecAddress,
    storage_slot: Field,
    randomness: Field,
    note_type_id: Field,
    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,
) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {
    let discovered_notes = &mut BoundedVec::new();

    debug_log_format(
        "Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}",
        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],
    );

    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,
    // is one of the note hashes created by the transaction.
    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {
        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the
        // new note hashes array. We therefore know for each note in every transaction what its nonce is.
        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);

        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches
        // the note hash at the array index we're currently processing.
        // TODO(#11157): handle failed note_hash_and_nullifier computation
        let hashes = compute_note_hash_and_nullifier(
            packed_note,
            owner,
            storage_slot,
            note_type_id,
            contract_address,
            randomness,
            candidate_nonce,
        )
            .expect(f"Failed to compute a note hash for note type {note_type_id}");

        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);
        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);

        if unique_note_hash == expected_unique_note_hash {
            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we
            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows
            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then
            // PXE may fail to realize that a given note has been nullified already, and calls to the application
            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an
            // application already has more direct means of making a call to it fail the transaction.
            discovered_notes.push(
                DiscoveredNoteInfo {
                    note_nonce: candidate_nonce,
                    note_hash: hashes.note_hash,
                    inner_nullifier: hashes.inner_nullifier,
                },
            );

            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present
            // multiple times in the same transaction with different nonces. This typically doesn't happen due to
            // notes containing random values in order to hide their contents.
        }
    });

    debug_log_format(
        "Found valid nonces for a total of {0} notes",
        [discovered_notes.len() as Field],
    );

    *discovered_notes
}

mod test {
    use crate::{
        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},
        note::{
            note_interface::{NoteHash, NoteType},
            note_metadata::SettledNoteMetadata,
            retrieved_note::RetrievedNote,
            utils::compute_note_hash_for_nullification,
        },
        oracle::random::random,
        test::mocks::mock_note::MockNote,
        utils::array,
    };

    use dep::protocol_types::{
        address::AztecAddress,
        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},
        traits::{FromField, Packable},
    };

    use super::attempt_note_nonce_discovery;

    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real
    // implementation, and as a sanity check that the interface is sufficient.
    unconstrained fn compute_note_hash_and_nullifier(
        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,
        owner: AztecAddress,
        storage_slot: Field,
        note_type_id: Field,
        contract_address: AztecAddress,
        randomness: Field,
        note_nonce: Field,
    ) -> Option<NoteHashAndNullifier> {
        if note_type_id == MockNote::get_id() {
            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));
            let note_hash = note.compute_note_hash(owner, storage_slot, randomness);

            let note_hash_for_nullification = compute_note_hash_for_nullification(
                RetrievedNote {
                    note,
                    contract_address,
                    owner,
                    randomness,
                    storage_slot,
                    metadata: SettledNoteMetadata::new(note_nonce).into(),
                },
            );

            let inner_nullifier =
                note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);

            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })
        } else {
            Option::none()
        }
    }

    global VALUE: Field = 7;
    global FIRST_NULLIFIER_IN_TX: Field = 47;
    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);
    global OWNER: AztecAddress = AztecAddress::from_field(14);
    global STORAGE_SLOT: Field = 99;
    global RANDOMNESS: Field = 99;

    #[test]
    unconstrained fn no_note_hashes() {
        let unique_note_hashes_in_tx = BoundedVec::new();
        let packed_note = BoundedVec::new();

        let discovered_notes = attempt_note_nonce_discovery(
            unique_note_hashes_in_tx,
            FIRST_NULLIFIER_IN_TX,
            compute_note_hash_and_nullifier,
            CONTRACT_ADDRESS,
            OWNER,
            STORAGE_SLOT,
            RANDOMNESS,
            MockNote::get_id(),
            packed_note,
        );

        assert_eq(discovered_notes.len(), 0);
    }

    #[test(should_fail_with = "Failed to compute a note hash")]
    unconstrained fn failed_hash_computation() {
        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);
        let packed_note = BoundedVec::new();
        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier

        let discovered_notes = attempt_note_nonce_discovery(
            unique_note_hashes_in_tx,
            FIRST_NULLIFIER_IN_TX,
            compute_note_hash_and_nullifier,
            CONTRACT_ADDRESS,
            OWNER,
            STORAGE_SLOT,
            RANDOMNESS,
            note_type_id,
            packed_note,
        );

        assert_eq(discovered_notes.len(), 0);
    }

    struct NoteAndData {
        note: MockNote,
        note_nonce: Field,
        note_hash: Field,
        unique_note_hash: Field,
        inner_nullifier: Field,
    }

    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {
        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);

        let retrieved_note = MockNote::new(value)
            .contract_address(CONTRACT_ADDRESS)
            .owner(OWNER)
            .randomness(RANDOMNESS)
            .storage_slot(STORAGE_SLOT)
            .note_metadata(SettledNoteMetadata::new(note_nonce).into())
            .build_retrieved_note();
        let note = retrieved_note.note;

        let note_hash = note.compute_note_hash(OWNER, STORAGE_SLOT, RANDOMNESS);
        let unique_note_hash = compute_unique_note_hash(
            note_nonce,
            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),
        );
        let inner_nullifier = note.compute_nullifier_unconstrained(
            OWNER,
            compute_note_hash_for_nullification(retrieved_note),
        );

        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }
    }

    #[test]
    unconstrained fn single_note() {
        let note_index_in_tx = 2;
        let note_and_data = construct_note(VALUE, note_index_in_tx);

        let mut unique_note_hashes_in_tx = BoundedVec::from_array([
            random(), random(), random(), random(), random(), random(), random(),
        ]);
        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);

        let discovered_notes = attempt_note_nonce_discovery(
            unique_note_hashes_in_tx,
            FIRST_NULLIFIER_IN_TX,
            compute_note_hash_and_nullifier,
            CONTRACT_ADDRESS,
            OWNER,
            STORAGE_SLOT,
            RANDOMNESS,
            MockNote::get_id(),
            BoundedVec::from_array(note_and_data.note.pack()),
        );

        assert_eq(discovered_notes.len(), 1);
        let discovered_note = discovered_notes.get(0);

        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);
        assert_eq(discovered_note.note_hash, note_and_data.note_hash);
        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);
    }

    #[test]
    unconstrained fn multiple_notes_same_preimage() {
        let first_note_index_in_tx = 3;
        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);

        let second_note_index_in_tx = 5;
        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);

        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same
        // call.
        assert_eq(first_note_and_data.note, second_note_and_data.note);
        let packed_note = first_note_and_data.note.pack();

        let mut unique_note_hashes_in_tx = BoundedVec::from_array([
            random(), random(), random(), random(), random(), random(), random(),
        ]);
        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);
        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);

        let discovered_notes = attempt_note_nonce_discovery(
            unique_note_hashes_in_tx,
            FIRST_NULLIFIER_IN_TX,
            compute_note_hash_and_nullifier,
            CONTRACT_ADDRESS,
            OWNER,
            STORAGE_SLOT,
            RANDOMNESS,
            MockNote::get_id(),
            BoundedVec::from_array(packed_note),
        );

        assert_eq(discovered_notes.len(), 2);

        assert(discovered_notes.any(|discovered_note| {
            (discovered_note.note_nonce == first_note_and_data.note_nonce)
                & (discovered_note.note_hash == first_note_and_data.note_hash)
                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)
        }));

        assert(discovered_notes.any(|discovered_note| {
            (discovered_note.note_nonce == second_note_and_data.note_nonce)
                & (discovered_note.note_hash == second_note_and_data.note_hash)
                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)
        }));
    }
}
`
    },
    "142": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      source: `use crate::{
    capsules::CapsuleArray,
    messages::{
        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},
        encoding::MAX_MESSAGE_CONTENT_LEN,
        processing::{
            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,
            log_retrieval_response::LogRetrievalResponse,
        },
    },
    utils::array,
};

use protocol_types::{
    address::AztecAddress,
    debug_log::debug_log_format,
    hash::sha256_to_field,
    traits::{Deserialize, FromField, Serialize},
};

/// [ owner, storage slot, randomness, note_completion_log_tag ]
global PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 4;
global PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX: u32 = 0;
global PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;
global PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;
global PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX: u32 = 3;

/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message
/// (e.g. the storage slot, note completion log tag, etc.).
pub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =
    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;

/// The slot in the PXE capsules where we store a \`CapsuleArray\` of \`DeliveredPendingPartialNote\`.
pub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(
    "AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT".as_bytes(),
);

/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the
/// log that will complete it and lead to a note being discovered and delivered.
#[derive(Serialize, Deserialize)]
pub(crate) struct DeliveredPendingPartialNote {
    pub(crate) note_completion_log_tag: Field,
    pub(crate) owner: AztecAddress,
    pub(crate) storage_slot: Field,
    pub(crate) randomness: Field,
    pub(crate) note_type_id: Field,
    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,
    pub(crate) recipient: AztecAddress,
}

pub unconstrained fn process_partial_note_private_msg(
    contract_address: AztecAddress,
    recipient: AztecAddress,
    msg_metadata: u64,
    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,
) {
    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search
    // for the public log that will complete it.
    let pending = decode_partial_note_private_msg(msg_metadata, msg_content, recipient);

    CapsuleArray::at(
        contract_address,
        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,
    )
        .push(pending);
}

/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes
/// being delivered to PXE if completed.
pub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(
    contract_address: AztecAddress,
    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,
) {
    let pending_partial_notes = CapsuleArray::at(
        contract_address,
        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,
    );

    debug_log_format(
        "{} pending partial notes",
        [pending_partial_notes.len() as Field],
    );

    // Each of the pending partial notes might get completed by a log containing its public values. For performance
    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time
    // waiting for the node roundtrip.
    let maybe_completion_logs =
        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);

    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the
    // same index. This means we can use the same index as we iterate through the responses to get both the partial note
    // and the log that might complete it.
    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());

    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {
        // We clear the completion logs as we read them so that the array is empty by the time we next query it.
        // TODO(#14943): use volatile arrays to avoid having to manually clear this.
        maybe_completion_logs.remove(i);

        let pending_partial_note = pending_partial_notes.get(i);

        if maybe_log.is_none() {
            debug_log_format(
                "Found no completion logs for partial note with tag {}",
                [pending_partial_note.note_completion_log_tag],
            );

            // Note that we're not removing the pending partial note from the capsule array, so we will continue
            // searching for this tagged log when performing message discovery in the future until we either find it or
            // the entry is somehow removed from the array.
        } else {
            debug_log_format(
                "Completion log found for partial note with tag {}",
                [pending_partial_note.note_completion_log_tag],
            );
            let log = maybe_log.unwrap();

            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the
            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get
            // the complete packed content.
            let complete_packed_note = array::append(
                pending_partial_note.packed_private_note_content,
                log.log_payload,
            );

            let discovered_notes = attempt_note_nonce_discovery(
                log.unique_note_hashes_in_tx,
                log.first_nullifier_in_tx,
                compute_note_hash_and_nullifier,
                contract_address,
                pending_partial_note.owner,
                pending_partial_note.storage_slot,
                pending_partial_note.randomness,
                pending_partial_note.note_type_id,
                complete_packed_note,
            );

            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note
            // being found?
            if discovered_notes.len() == 0 {
                panic(
                    f"A partial note's completion log did not result in any notes being found - this should never happen",
                );
            }

            debug_log_format(
                "Discovered {0} notes for partial note with tag {1}",
                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],
            );

            discovered_notes.for_each(|discovered_note| {
                enqueue_note_for_validation(
                    contract_address,
                    pending_partial_note.owner,
                    pending_partial_note.storage_slot,
                    pending_partial_note.randomness,
                    discovered_note.note_nonce,
                    complete_packed_note,
                    discovered_note.note_hash,
                    discovered_note.inner_nullifier,
                    log.tx_hash,
                    pending_partial_note.recipient,
                );
            });

            // Because there is only a single log for a given tag, once we've processed the tagged log then we
            // simply delete the pending work entry, regardless of whether it was actually completed or not.
            pending_partial_notes.remove(i);
        }
    });
}

fn decode_partial_note_private_msg(
    msg_metadata: u64,
    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,
    recipient: AztecAddress,
) -> DeliveredPendingPartialNote {
    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field

    // The following ensures that the message content contains at least the minimum number of fields required for a
    // valid partial note private message. (Refer to the description of
    // PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN for more information about these fields.)
    assert(
        msg_content.len() >= PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,
        f"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields",
    );

    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the
    // destructuring of the partial note private message encoding below must be updated as well.
    std::static_assert(
        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 4,
        "unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN",
    );

    // We currently have four fields that are not the partial note's packed representation,
    // which are the owner, the storage slot, the randomness, and the note completion log tag.
    let owner = AztecAddress::from_field(msg_content.get(
        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX,
    ));
    let storage_slot = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX);
    let randomness = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX);
    let note_completion_log_tag =
        msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX);

    let packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN> = array::subbvec(
        msg_content,
        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,
    );

    DeliveredPendingPartialNote {
        note_completion_log_tag,
        owner,
        storage_slot,
        randomness,
        note_type_id,
        packed_private_note_content,
        recipient,
    }
}
`
    },
    "143": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      source: 'use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event\'s serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event\'s contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        "unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n'
    },
    "144": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      source: `use crate::{
    messages::{
        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},
        encoding::MAX_MESSAGE_CONTENT_LEN,
        processing::enqueue_note_for_validation,
    },
    utils::array,
};
use protocol_types::{
    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,
    traits::FromField,
};

/// The number of fields in a private note message content that are not the note's packed representation.
// See the call to \`std::static_assert\` below to see what's in these fields.
global PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 3;
global PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX: u32 = 0;
global PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;
global PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;

/// The maximum length of the packed representation of a note's contents. This is limited by private log size,
/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, randomness, etc.).
pub global MAX_NOTE_PACKED_LEN: u32 =
    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;

pub unconstrained fn process_private_note_msg<Env>(
    contract_address: AztecAddress,
    tx_hash: Field,
    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,
    first_nullifier_in_tx: Field,
    recipient: AztecAddress,
    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,
    msg_metadata: u64,
    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,
) {
    let (note_type_id, owner, storage_slot, randomness, packed_note) =
        decode_private_note_msg(msg_metadata, msg_content);

    attempt_note_discovery(
        contract_address,
        tx_hash,
        unique_note_hashes_in_tx,
        first_nullifier_in_tx,
        recipient,
        compute_note_hash_and_nullifier,
        owner,
        storage_slot,
        randomness,
        note_type_id,
        packed_note,
    );
}

/// Attempts discovery of a note given information about its contents and the transaction in which it is
/// suspected the note was created.
pub unconstrained fn attempt_note_discovery<Env>(
    contract_address: AztecAddress,
    tx_hash: Field,
    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,
    first_nullifier_in_tx: Field,
    recipient: AztecAddress,
    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,
    owner: AztecAddress,
    storage_slot: Field,
    randomness: Field,
    note_type_id: Field,
    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,
) {
    let discovered_notes = attempt_note_nonce_discovery(
        unique_note_hashes_in_tx,
        first_nullifier_in_tx,
        compute_note_hash_and_nullifier,
        contract_address,
        owner,
        storage_slot,
        randomness,
        note_type_id,
        packed_note,
    );

    debug_log_format(
        "Discovered {0} notes from a private message",
        [discovered_notes.len() as Field],
    );

    discovered_notes.for_each(|discovered_note| {
        enqueue_note_for_validation(
            contract_address,
            owner,
            storage_slot,
            randomness,
            discovered_note.note_nonce,
            packed_note,
            discovered_note.note_hash,
            discovered_note.inner_nullifier,
            tx_hash,
            recipient,
        );
    });
}

fn decode_private_note_msg(
    msg_metadata: u64,
    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,
) -> (Field, AztecAddress, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {
    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field

    assert(
        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,
        f"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields",
    );

    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the
    // destructuring of the private note message encoding below must be updated as well.
    std::static_assert(
        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 3,
        "unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN",
    );

    // We currently have two fields that are not the note's packed representation, which are the owner and the storage slot.
    let owner = AztecAddress::from_field(msg_content.get(PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX));
    let storage_slot = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX);
    let randomness = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX);
    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);

    (note_type_id, owner, storage_slot, randomness, packed_note)
}
`
    },
    "145": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      source: `use crate::messages::{
    discovery::{
        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,
        private_events::process_private_event_msg, private_notes::process_private_note_msg,
    },
    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},
    encryption::{aes128::AES128, message_encryption::MessageEncryption},
    msg_type::{
        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,
    },
    processing::message_context::MessageContext,
};

use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};

/// Processes a message that can contain notes, partial notes, or events.
///
/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash
/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with
/// the list of unique note hashes in said transaction and the \`compute_note_hash_and_nullifier\` function. Once
/// discovered, the notes are enqueued for validation.
///
/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to
/// search for the note's completion public log.
///
/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then
/// enqueueing the event data and commitment for validation.
pub unconstrained fn process_message_ciphertext<Env>(
    contract_address: AztecAddress,
    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,
    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,
    message_context: MessageContext,
) {
    let message_plaintext_option = AES128::decrypt(message_ciphertext, message_context.recipient);

    if message_plaintext_option.is_some() {
        process_message_plaintext(
            contract_address,
            compute_note_hash_and_nullifier,
            message_plaintext_option.unwrap(),
            message_context,
        );
    } else {
        debug_log_format(
            "Found invalid message from tx {0}, ignoring",
            [message_context.tx_hash],
        );
    }
}

pub unconstrained fn process_message_plaintext<Env>(
    contract_address: AztecAddress,
    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,
    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,
    message_context: MessageContext,
) {
    // The first thing to do after decrypting the message is to determine what type of message we're processing. We
    // have 3 message types: private notes, partial notes and events.

    // We decode the message to obtain the message type id, metadata and content.
    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);

    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {
        debug_log("Processing private note msg");

        process_private_note_msg(
            contract_address,
            message_context.tx_hash,
            message_context.unique_note_hashes_in_tx,
            message_context.first_nullifier_in_tx,
            message_context.recipient,
            compute_note_hash_and_nullifier,
            msg_metadata,
            msg_content,
        );
    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {
        debug_log("Processing partial note private msg");

        process_partial_note_private_msg(
            contract_address,
            message_context.recipient,
            msg_metadata,
            msg_content,
        );
    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {
        debug_log("Processing private event msg");

        process_private_event_msg(
            contract_address,
            message_context.recipient,
            msg_metadata,
            msg_content,
            message_context.tx_hash,
        );
    } else {
        debug_log_format("Unknown msg type id {0}", [msg_type_id as Field]);
    }
}
`
    },
    "146": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      source: "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\n// Note: PRIVATE_LOG_CIPHERTEXT_LEN is an amount of fields,\n// so MESSAGE_CIPHERTEXT_LEN is the size of the message in fields.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\n// Note: We multiply by 31 because ciphertext bytes are stored in fields using bytes_to_fields, which packs 31 bytes per\n// field (since a Field is ~254 bits and can safely store 31 whole bytes).\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// The plaintext bytes represent Field values that were originally serialized using fields_to_bytes, which converts each\n// Field to 32 bytes. To convert the plaintext bytes back to fields, we divide by 32.\n// 479 / 32 = 14\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\npub global MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "147": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      source: 'use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n    public_keys::AddressPoint,\n};\n\nuse crate::{\n    keys::{ecdh_shared_secret::derive_ecdh_shared_secret, ephemeral::generate_ephemeral_key_pair},\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle, random::random, shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don\'t_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to "key" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that\'s good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it\'s safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you\'re calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won\'t give us 32 bytes of entropy.\n     * So we compute two "random" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each "random" field.\n     * Note: we use to_be_bytes because it\'s slightly more efficient. But we have to\n     * be careful not to take bytes from the "big end", because the "big" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it\'s the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it\'s extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, "N too large");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the "little end" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret = derive_ecdh_shared_secret(\n            eph_sk,\n            recipient\n                .to_address_point()\n                .unwrap_or(\n                    // Safety: if the recipient is an invalid address, then it is not possible to encrypt a message for\n                    // them because we cannot establish a shared secret. This is never expected to occur during normal\n                    // operation. However, it is technically possible for us to receive an invalid address, and we must\n                    // therefore handle it.\n                    // We could simply fail, but that\'d introduce a potential security issue in which an attacker forces\n                    // a contract to encrypt a message for an invalid address, resulting in an impossible transaction -\n                    // this is sometimes called a \'king of the hill\' attack.\n                    // We choose instead to not fail and encrypt the plaintext regardless using the shared secret that\n                    // results from a random valid address. The sender is free to choose this address and hence shared\n                    // secret, but this has no security implications as they already know not only the full plaintext\n                    // but also the ephemeral private key anyway.\n                    unsafe { random_address_point() },\n                )\n                .inner,\n        );\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            "unexpected ciphertext length",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I\'ll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            "unexpected ciphertext header length",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won\'t be constrained to be random. It\'s in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            "Unexpected error: message_bytes.len() should be divisible by 31, by construction.",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we\'ve\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            "unexpected message length",\n        );\n        assert(offset == message_bytes.len(), "unexpected encrypted message length");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the "real" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> Option<BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point. This may fail\n        // however, as not all x-coordinates are on the curve. In that case, we simply return `Option::none`.\n        point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool).map(|eph_pk| {\n            // Derive shared secret\n            let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n            // Derive symmetric keys:\n            let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n                ciphertext_shared_secret,\n            );\n            let (body_sym_key, body_iv) = pairs[0];\n            let (header_sym_key, header_iv) = pairs[1];\n\n            // Extract the header ciphertext\n            let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n            let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n            // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it\'s designed to work\n            // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n            // is fixed. But we do it anyway to not have to have duplicate oracles.\n            let header_ciphertext_bvec =\n                BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n            // Decrypt header\n            let header_plaintext =\n                aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n            // Extract ciphertext length from header (2 bytes, big-endian)\n            let ciphertext_length =\n                ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n            // Extract and decrypt main ciphertext\n            let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n            let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n            let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n                BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n            // Decrypt main ciphertext and return it\n            let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n            // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n            fields_from_bytes(plaintext_bytes)\n        })\n    }\n}\n\n/// Produces a random valid address point, i.e. one that is on the curve. This is equivalent to calling\n/// [AztecAddress::to_address_point] on a random valid address.\nunconstrained fn random_address_point() -> AddressPoint {\n    let mut result = std::mem::zeroed();\n\n    loop {\n        // We simply produce random x coordinates until we find one that is on the curve. About half of the x\n        // coordinates fulfill this condition, so this should only take a few iterations at most.\n        let x_coord = random();\n        let point = point_from_x_coord_and_sign(x_coord, true);\n        if point.is_some() {\n            result = AddressPoint { inner: point.unwrap() };\n            break;\n        }\n    }\n\n    result\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{AES128, random_address_point};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_deterministic() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock("utilityGetRandomField").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock("utilityGetRandomField").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock("privateGetNextAppTagAsSender").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient.to_address_point().unwrap().inner,\n            );\n\n            let _ = OracleMock::mock("utilityGetSharedSecret").returns(shared_secret);\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient).unwrap();\n\n            // The decryption function spits out a BoundedVec because it\'s designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                "Decrypted bytes should match original plaintext",\n            );\n\n            // The following is a workaround of "struct is never constructed" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_decrypt_random() {\n        // Same as `encrypt_decrypt_deterministic`, except we don\'t mock any of the oracles and rely on\n        // `TestEnvironment` instead.\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            assert_eq(\n                AES128::decrypt(BoundedVec::from_array(ciphertext), recipient).unwrap(),\n                BoundedVec::from_array(plaintext),\n            );\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_to_invalid_address() {\n        // x = 3 is a non-residue for this curve, resulting in an invalid address\n        let invalid_address = AztecAddress { inner: 3 };\n\n        // We just test that we produced some output and did not crash - the result is gibberish as it is encrypted\n        // using a public key for which we do not know the private key.\n        let _ = AES128::encrypt([1, 2, 3, 4], invalid_address);\n    }\n\n    #[test]\n    unconstrained fn random_address_point_produces_valid_points() {\n        // About half of random addresses are invalid, so testing just a couple gives us high confidence that\n        // `random_address_point` is indeed producing valid addresses.\n        for _ in 0..10 {\n            let random_address = AztecAddress { inner: random_address_point().inner.x };\n            assert(random_address.to_address_point().is_some());\n        }\n    }\n\n    #[test]\n    unconstrained fn decrypt_invalid_ephemeral_public_key() {\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3, 4];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            // The first field of the ciphertext is the x-coordinate of the ephemeral public key. We set it to a known\n            // non-residue (3), causing `decrypt` to fail to produce a decryption shared secret.\n            let mut bad_ciphertext = BoundedVec::from_array(ciphertext);\n            bad_ciphertext.set(0, 3);\n\n            assert(AES128::decrypt(bad_ciphertext, recipient).is_none());\n        });\n    }\n}\n'
    },
    "16": {
      path: "std/embedded_curve_ops.nr",
      source: "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "164": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      source: 'pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field("AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    "AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    "AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    "AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    "AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note\'s existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `owner` is the address used in note hash and nullifier computation, often requiring knowledge of their\n/// nullifier secret key.\n///\n/// `recipient` is the account to which the note message was delivered (i.e. the address the message was encrypted to).\n/// This determines which PXE account can see the note - other accounts will not be able to access it (e.g. other\n/// accounts will not be able to see one another\'s token balance notes, even in the same PXE) unless authorized. In most\n/// cases `recipient` equals `owner`, but they can differ in scenarios like delegated discovery.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can\'t use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n'
    },
    "167": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/messaging.nr",
      source: 'use crate::{\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n    leaf_index: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_l1_to_l2_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n        leaf_index,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    // Safety: The witness is only used as a "magical value" that makes the merkle proof below pass. Hence it\'s safe.\n    let (_leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert_eq(root, l1_to_l2_root, "Message not in state");\n\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\n}\n'
    },
    "17": {
      path: "std/field/bn254.nr",
      source: `use crate::field::field_less_than;
use crate::runtime::is_unconstrained;

// The low and high decomposition of the field modulus
pub(crate) global PLO: Field = 53438638232309528389504892708671455233;
pub(crate) global PHI: Field = 64323764613183177041862057485226039389;

pub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;

// Decomposes a single field into two 16 byte fields.
fn compute_decomposition(x: Field) -> (Field, Field) {
    // Here's we're taking advantage of truncating 128 bit limbs from the input field
    // and then subtracting them from the input such the field division is equivalent to integer division.
    let low = (x as u128) as Field;
    let high = (x - low) / TWO_POW_128;

    (low, high)
}

pub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {
    compute_decomposition(x)
}

unconstrained fn lte_hint(x: Field, y: Field) -> bool {
    if x == y {
        true
    } else {
        field_less_than(x, y)
    }
}

// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)
fn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {
    let (alo, ahi) = a;
    let (blo, bhi) = b;
    // Safety: borrow is enforced to be boolean due to its type.
    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)
    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)
    unsafe {
        let borrow = lte_hint(alo, blo);

        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;
        let rhi = ahi - bhi - (borrow as Field);

        rlo.assert_max_bit_size::<128>();
        rhi.assert_max_bit_size::<128>();
    }
}

/// Decompose a single field into two 16 byte fields.
pub fn decompose(x: Field) -> (Field, Field) {
    if is_unconstrained() {
        compute_decomposition(x)
    } else {
        // Safety: decomposition is properly checked below
        unsafe {
            // Take hints of the decomposition
            let (xlo, xhi) = decompose_hint(x);

            // Range check the limbs
            xlo.assert_max_bit_size::<128>();
            xhi.assert_max_bit_size::<128>();

            // Check that the decomposition is correct
            assert_eq(x, xlo + TWO_POW_128 * xhi);

            // Assert that the decomposition of P is greater than the decomposition of x
            assert_gt_limbs((PLO, PHI), (xlo, xhi));
            (xlo, xhi)
        }
    }
}

pub fn assert_gt(a: Field, b: Field) {
    if is_unconstrained() {
        assert(
            // Safety: already unconstrained
            unsafe { field_less_than(b, a) },
        );
    } else {
        // Decompose a and b
        let a_limbs = decompose(a);
        let b_limbs = decompose(b);

        // Assert that a_limbs is greater than b_limbs
        assert_gt_limbs(a_limbs, b_limbs)
    }
}

pub fn assert_lt(a: Field, b: Field) {
    assert_gt(b, a);
}

pub fn gt(a: Field, b: Field) -> bool {
    if is_unconstrained() {
        // Safety: unsafe in unconstrained
        unsafe {
            field_less_than(b, a)
        }
    } else if a == b {
        false
    } else {
        // Safety: Take a hint of the comparison and verify it
        unsafe {
            if field_less_than(a, b) {
                assert_gt(b, a);
                false
            } else {
                assert_gt(a, b);
                true
            }
        }
    }
}

pub fn lt(a: Field, b: Field) -> bool {
    gt(b, a)
}

mod tests {
    // TODO: Allow imports from "super"
    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};

    #[test]
    fn check_decompose() {
        assert_eq(decompose(TWO_POW_128), (0, 1));
        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));
        assert_eq(decompose(0x1234567890), (0x1234567890, 0));
    }

    #[test]
    unconstrained fn check_lte_hint() {
        assert(lte_hint(0, 1));
        assert(lte_hint(0, 0x100));
        assert(lte_hint(0x100, TWO_POW_128 - 1));
        assert(!lte_hint(0 - 1, 0));

        assert(lte_hint(0, 0));
        assert(lte_hint(0x100, 0x100));
        assert(lte_hint(0 - 1, 0 - 1));
    }

    #[test]
    fn check_gt() {
        assert(gt(1, 0));
        assert(gt(0x100, 0));
        assert(gt((0 - 1), (0 - 2)));
        assert(gt(TWO_POW_128, 0));
        assert(!gt(0, 0));
        assert(!gt(0, 0x100));
        assert(gt(0 - 1, 0 - 2));
        assert(!gt(0 - 2, 0 - 1));
        assert_gt(0 - 1, 0);
    }

    #[test]
    fn check_plo_phi() {
        assert_eq(PLO + PHI * TWO_POW_128, 0);
        let p_bytes = crate::field::modulus_le_bytes();
        let mut p_low: Field = 0;
        let mut p_high: Field = 0;

        let mut offset = 1;
        for i in 0..16 {
            p_low += (p_bytes[i] as Field) * offset;
            p_high += (p_bytes[i + 16] as Field) * offset;
            offset *= 256;
        }
        assert_eq(p_low, PLO);
        assert_eq(p_high, PHI);
    }

    #[test]
    fn check_decompose_edge_cases() {
        assert_eq(decompose(0), (0, 0));
        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));
        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));
        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));
        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));
    }

    #[test]
    fn check_decompose_large_values() {
        let large_field = 0xffffffffffffffff;
        let (lo, hi) = decompose(large_field);
        assert_eq(large_field, lo + TWO_POW_128 * hi);

        let large_value = large_field - TWO_POW_128;
        let (lo2, hi2) = decompose(large_value);
        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);
    }

    #[test]
    fn check_lt_comprehensive() {
        assert(lt(0, 1));
        assert(!lt(1, 0));
        assert(!lt(0, 0));
        assert(!lt(42, 42));

        assert(lt(TWO_POW_128 - 1, TWO_POW_128));
        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));
    }
}
`
    },
    "176": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      source: "use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "179": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      source: "use crate::{\n    context::{note_hash_read::NoteHashRead, PrivateContext},\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_read<Note>(retrieved_note: RetrievedNote<Note>) -> NoteHashRead\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(\n        retrieved_note.owner,\n        retrieved_note.storage_slot,\n        retrieved_note.randomness,\n    );\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        NoteHashRead::new_settled(compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        ))\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        NoteHashRead::new_transient(note_hash, retrieved_note.contract_address)\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(retrieved_note: RetrievedNote<Note>) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_note_hash_read(\n        retrieved_note,\n        compute_note_hash_read(retrieved_note),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_read` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_note_hash_read<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_read: NoteHashRead,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash = compute_siloed_note_hash(\n            note_hash_read.contract_address().unwrap(), // Safe since contract address must be populated for pending note reads.\n            note_hash_read.note_hash(),\n        );\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_read.note_hash()\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification = compute_note_hash_for_nullification(retrieved_note);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(\n        context,\n        retrieved_note.owner,\n        note_hash_for_nullification,\n    );\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "18": {
      path: "std/field/mod.nr",
      source: 'pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            "BIT_SIZE must be less than modulus_num_bits",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, "radix must be greater than 1");\n            static_assert(radix <= 256, "radix must be less than or equal to 256");\n            static_assert(radix & (radix - 1) == 0, "radix must be a power of 2");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, "radix must be greater than 1");\n            static_assert(radix <= 256, "radix must be less than or equal to 256");\n            static_assert(radix & (radix - 1) == 0, "radix must be a power of 2");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = "radix must be greater than 1")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f"radix must be greater than 1");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = "radix must be greater than 1")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f"radix must be greater than 1");\n        }\n    }\n\n    #[test(should_fail_with = "radix must be a power of 2")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f"radix must be a power of 2");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, "unexpected result");\n        }\n    }\n\n    #[test(should_fail_with = "radix must be less than or equal to 256")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f"radix must be less than or equal to 256")\n        }\n    }\n\n    #[test(should_fail_with = "Field failed to decompose into specified 16 limbs")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = "Field failed to decompose into specified 16 limbs")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = "Field failed to decompose into specified 8 limbs")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can\'t represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = "Field failed to decompose into specified 4 limbs")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can\'t represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            "N must be less than or equal to modulus_le_bits().len()",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n'
    },
    "183": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      source: "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "184": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      source: 'use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = "copy empty slot")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = "not allowed to access")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = "not allowed to access")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = "not allowed to access")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = "not allowed to access")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n'
    },
    "185": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      source: "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\npub unconstrained fn is_side_effect_counter_revertible_oracle_wrapper(counter: u32) -> bool {\n    is_side_effect_counter_revertible_oracle(counter)\n}\n\n#[oracle(privateIsSideEffectCounterRevertible)]\nunconstrained fn is_side_effect_counter_revertible_oracle(counter: u32) -> bool {}\n"
    },
    "186": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      source: "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "187": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      source: "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store<let N: u32>(values: [Field; N], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper<let N: u32>(\n    values: [Field; N],\n    hash: Field,\n) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle<let N: u32>(_values: [Field; N], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "188": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      source: "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "189": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr",
      source: "use dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(utilityGetL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {}\n"
    },
    "19": {
      path: "std/hash/mod.nr",
      source: `// Exposed only for usage in \`std::meta\`
pub(crate) mod poseidon2;

use crate::default::Default;
use crate::embedded_curve_ops::{
    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,
};
use crate::meta::derive_via;

#[foreign(sha256_compression)]
// docs:start:sha256_compression
pub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}
// docs:end:sha256_compression

#[foreign(keccakf1600)]
// docs:start:keccakf1600
pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}
// docs:end:keccakf1600

pub mod keccak {
    #[deprecated("This function has been moved to std::hash::keccakf1600")]
    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {
        super::keccakf1600(input)
    }
}

#[foreign(blake2s)]
// docs:start:blake2s
pub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]
// docs:end:blake2s
{}

// docs:start:blake3
pub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]
// docs:end:blake3
{
    if crate::runtime::is_unconstrained() {
        // Temporary measure while Barretenberg is main proving system.
        // Please open an issue if you're working on another proving system and running into problems due to this.
        crate::static_assert(
            N <= 1024,
            "Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes",
        );
    }
    __blake3(input)
}

#[foreign(blake3)]
fn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}

// docs:start:pedersen_commitment
pub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {
    // docs:end:pedersen_commitment
    pedersen_commitment_with_separator(input, 0)
}

#[inline_always]
pub fn pedersen_commitment_with_separator<let N: u32>(
    input: [Field; N],
    separator: u32,
) -> EmbeddedCurvePoint {
    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];
    for i in 0..N {
        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.
        points[i] = from_field_unsafe(input[i]);
    }
    let generators = derive_generators("DEFAULT_DOMAIN_SEPARATOR".as_bytes(), separator);
    multi_scalar_mul(generators, points)
}

// docs:start:pedersen_hash
pub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field
// docs:end:pedersen_hash
{
    pedersen_hash_with_separator(input, 0)
}

#[no_predicates]
pub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {
    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];
    let mut generators: [EmbeddedCurvePoint; N + 1] =
        [EmbeddedCurvePoint::point_at_infinity(); N + 1];
    let domain_generators: [EmbeddedCurvePoint; N] =
        derive_generators("DEFAULT_DOMAIN_SEPARATOR".as_bytes(), separator);

    for i in 0..N {
        scalars[i] = from_field_unsafe(input[i]);
        generators[i] = domain_generators[i];
    }
    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };

    let length_generator: [EmbeddedCurvePoint; 1] =
        derive_generators("pedersen_hash_length".as_bytes(), 0);
    generators[N] = length_generator[0];
    multi_scalar_mul_array_return(generators, scalars, true)[0].x
}

#[field(bn254)]
#[inline_always]
pub fn derive_generators<let N: u32, let M: u32>(
    domain_separator_bytes: [u8; M],
    starting_index: u32,
) -> [EmbeddedCurvePoint; N] {
    crate::assert_constant(domain_separator_bytes);
    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index
    __derive_generators(domain_separator_bytes, starting_index)
}

#[builtin(derive_pedersen_generators)]
#[field(bn254)]
fn __derive_generators<let N: u32, let M: u32>(
    domain_separator_bytes: [u8; M],
    starting_index: u32,
) -> [EmbeddedCurvePoint; N] {}

#[field(bn254)]
// Decompose the input 'bn254 scalar' into two 128 bits limbs.
// It is called 'unsafe' because it does not assert the limbs are 128 bits
// Assuming the limbs are 128 bits:
// Assert the decomposition does not overflow the field size.
fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {
    // Safety: xlo and xhi decomposition is checked below
    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };
    // Check that the decomposition is correct
    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);
    // Check that the decomposition does not overflow the field size
    let (a, b) = if xhi == crate::field::bn254::PHI {
        (xlo, crate::field::bn254::PLO)
    } else {
        (xhi, crate::field::bn254::PHI)
    };
    crate::field::bn254::assert_lt(a, b);

    EmbeddedCurveScalar { lo: xlo, hi: xhi }
}

pub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {
    assert_eq(input.len(), state_len);
    poseidon2_permutation_internal(input)
}

#[foreign(poseidon2_permutation)]
fn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}

// Generic hashing support.
// Partially ported and impacted by rust.

// Hash trait shall be implemented per type.
#[derive_via(derive_hash)]
pub trait Hash {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher;
}

// docs:start:derive_hash
comptime fn derive_hash(s: TypeDefinition) -> Quoted {
    let name = quote { $crate::hash::Hash };
    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };
    let for_each_field = |name| quote { _self.$name.hash(_state); };
    crate::meta::make_trait_impl(
        s,
        name,
        signature,
        for_each_field,
        quote {},
        |fields| fields,
    )
}
// docs:end:derive_hash

// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.
// TODO: consider making the types generic here ([u8], [Field], etc.)
pub trait Hasher {
    fn finish(self) -> Field;

    fn write(&mut self, input: Field);
}

// BuildHasher is a factory trait, responsible for production of specific Hasher.
pub trait BuildHasher {
    type H: Hasher;

    fn build_hasher(self) -> H;
}

pub struct BuildHasherDefault<H>;

impl<H> BuildHasher for BuildHasherDefault<H>
where
    H: Hasher + Default,
{
    type H = H;

    fn build_hasher(_self: Self) -> H {
        H::default()
    }
}

impl<H> Default for BuildHasherDefault<H>
where
    H: Hasher + Default,
{
    fn default() -> Self {
        BuildHasherDefault {}
    }
}

impl Hash for Field {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self);
    }
}

impl Hash for u1 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for u8 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for u16 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for u32 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for u64 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for u128 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for i8 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as u8 as Field);
    }
}

impl Hash for i16 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as u16 as Field);
    }
}

impl Hash for i32 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as u32 as Field);
    }
}

impl Hash for i64 {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as u64 as Field);
    }
}

impl Hash for bool {
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        H::write(state, self as Field);
    }
}

impl Hash for () {
    fn hash<H>(_self: Self, _state: &mut H)
    where
        H: Hasher,
    {}
}

impl<T, let N: u32> Hash for [T; N]
where
    T: Hash,
{
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        for elem in self {
            elem.hash(state);
        }
    }
}

impl<T> Hash for [T]
where
    T: Hash,
{
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        self.len().hash(state);
        for elem in self {
            elem.hash(state);
        }
    }
}

impl<A, B> Hash for (A, B)
where
    A: Hash,
    B: Hash,
{
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        self.0.hash(state);
        self.1.hash(state);
    }
}

impl<A, B, C> Hash for (A, B, C)
where
    A: Hash,
    B: Hash,
    C: Hash,
{
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        self.0.hash(state);
        self.1.hash(state);
        self.2.hash(state);
    }
}

impl<A, B, C, D> Hash for (A, B, C, D)
where
    A: Hash,
    B: Hash,
    C: Hash,
    D: Hash,
{
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        self.0.hash(state);
        self.1.hash(state);
        self.2.hash(state);
        self.3.hash(state);
    }
}

impl<A, B, C, D, E> Hash for (A, B, C, D, E)
where
    A: Hash,
    B: Hash,
    C: Hash,
    D: Hash,
    E: Hash,
{
    fn hash<H>(self, state: &mut H)
    where
        H: Hasher,
    {
        self.0.hash(state);
        self.1.hash(state);
        self.2.hash(state);
        self.3.hash(state);
        self.4.hash(state);
    }
}

// Some test vectors for Pedersen hash and Pedersen Commitment.
// They have been generated using the same functions so the tests are for now useless
// but they will be useful when we switch to Noir implementation.
#[test]
fn assert_pedersen() {
    assert_eq(
        pedersen_hash_with_separator([1], 1),
        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,
    );
    assert_eq(
        pedersen_commitment_with_separator([1], 1),
        EmbeddedCurvePoint {
            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,
            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,
            is_infinite: false,
        },
    );

    assert_eq(
        pedersen_hash_with_separator([1, 2], 2),
        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2], 2),
        EmbeddedCurvePoint {
            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,
            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3], 3),
        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3], 3),
        EmbeddedCurvePoint {
            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,
            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3, 4], 4),
        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3, 4], 4),
        EmbeddedCurvePoint {
            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,
            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),
        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),
        EmbeddedCurvePoint {
            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,
            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),
        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),
        EmbeddedCurvePoint {
            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,
            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),
        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),
        EmbeddedCurvePoint {
            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,
            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),
        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),
        EmbeddedCurvePoint {
            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,
            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),
        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),
        EmbeddedCurvePoint {
            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,
            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,
            is_infinite: false,
        },
    );
    assert_eq(
        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),
        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,
    );
    assert_eq(
        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),
        EmbeddedCurvePoint {
            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,
            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,
            is_infinite: false,
        },
    );
}
`
    },
    "192": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      source: "use protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\nuse protocol_types::traits::{Deserialize, Serialize};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(utilityGetPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "193": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      source: "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "194": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      source: "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "196": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      source: "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "198": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      source: "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            owner,\n            storage_slot,\n            randomness,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _owner: AztecAddress,\n    _storage_slot: Field,\n    _randomness: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _owner: Option<AztecAddress>,\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    owner: Option<AztecAddress>,\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            owner,\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "201": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      source: "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "202": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      source: 'use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock("utilityStorageRead").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock("utilityStorageRead").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n'
    },
    "203": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      source: '/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 5;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = "Incompatible oracle version. TXE is using version")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n'
    },
    "207": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      source: "use crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PublicMutable<FieldNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable (variable that implements the StateVariable trait):\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// Note that maps cannot be used with owned state variables (variables that\n/// implement the OwnedStateVariable trait) - those need to be wrapped in an\n/// `Owned` state variable instead.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PublicMutable, nested Map etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<FieldNote>)\n    /// let user_balance = self.storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n"
    },
    "217": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      source: "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::state_variable::StateVariable,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> StateVariable<M + 1, Context> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(self.context, self.storage_slot)\n    }\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the anchor block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   anchor block header.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_anchor_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "219": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      source: "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> StateVariable<M, Context> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T> PublicMutable<T, PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "242": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      source: '/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = "out of bounds")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n'
    },
    "245": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      source: '/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can\'t return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, "DstLen too large for offset");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we\'re setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = "DstLen too large for offset")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n'
    },
    "246": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      source: "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "248": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      source: 'use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, "N must be a multiple of 31");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = "N must be a multiple of 31")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n'
    },
    "249": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      source: '// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you\'ll end up with a subtle 2-bit "gap" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn\'t leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, "Input length must be a multiple of 32");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], "Value does not fit in field");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, "Value does not fit in field");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = "Input length must be a multiple of 32")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = "Value does not fit in field")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field\'s maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field\'s capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n'
    },
    "252": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      source: 'use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw "String literal too large" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don\'t serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the "sign") so it\'s possible to use that last bit as an "is_infinite" flag if desired in the future.\n    assert(!p.is_infinite, "Cannot serialize point at infinity as bytes.");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a "sign" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve\'s order minus 1 divided by 2.\n    // Ideally we\'d do `y <= MOD_DIV_2`, but there\'s no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The "sign" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct "sign"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n'
    },
    "256": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      source: 'use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), "Hint values do not match hash");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                "Non-zero hint for zero hash",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don\'t derive Packable on `WithHash` because `derive_serialize` function does not support setting "N = M"\n// as I do here 3 lines below. This could be worked around by placing the "where" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = "Non-zero hint for zero hash")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.anchor_block_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock("utilityStorageRead")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = "Hint values do not match hash")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n'
    },
    "263": {
      path: "/home/ubuntu/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      source: "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "283": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      source: 'use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature("IS_VALID()");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature("foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n'
    },
    "3": {
      path: "std/array/mod.nr",
      source: 'use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`\'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    "Array has not been sorted correctly according to `ordering`.",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, "hi");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n'
    },
    "321": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      source: "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "322": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      source: "use crate::traits::{Deserialize, Empty, Packable, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn to_be_bytes(self) -> [u8; 20] {\n        let field_bytes: [u8; 32] = self.inner.to_be_bytes();\n        let mut bytes = [0; 20];\n        for i in 0..20 {\n            bytes[i] = field_bytes[i + 12];\n        }\n        bytes\n    }\n}\n\nmod test {\n    use crate::{\n        address::eth_address::EthAddress,\n        constants::ETH_ADDRESS_LENGTH,\n        traits::{Deserialize, Serialize},\n    };\n\n    #[test]\n    fn serialization_of_eth_address() {\n        let item = EthAddress::from_field(1);\n        // We use the ETH_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n        // implementation and the constant.\n        let serialized: [Field; ETH_ADDRESS_LENGTH] = item.serialize();\n        let deserialized = EthAddress::deserialize(serialized);\n        assert_eq(item, deserialized);\n    }\n}\n"
    },
    "340": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      source: "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Deserialize, Empty, Hash, Serialize},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: Field,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: Field) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "342": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      source: "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "352": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      source: "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "361": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      source: 'use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I\'d generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_tree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n/// These values are precomputed and we run tests to ensure that they are correct.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f"depth should be between 0 and 10")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_tree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_tree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_tree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_tree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_tree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_tree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_tree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_tree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_tree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_tree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_tree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_tree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n'
    },
    "365": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      source: 'use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct\'s trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. "let N: u32"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. "T")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn\'t have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name "Serialize", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    } else {\n        quote {\n            [0; Self::N]\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Empty {}\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_empty() {\n        let original = Empty {};\n        let serialized = original.serialize();\n        assert_eq(serialized, [], "Serialized does not match empty array");\n        let deserialized = Empty::deserialize(serialized);\n        assert_eq(deserialized, original, "Deserialized does not match original");\n    }\n\n    #[test]\n    fn packable_on_empty() {\n        let original = Empty {};\n        let packed = original.pack();\n        assert_eq(packed, [], "Packed does not match empty array");\n        let unpacked = Empty::unpack(packed);\n        assert_eq(unpacked, original, "Unpacked does not match original");\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, "Packed does not match serialized");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: "metaprogramming!" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n'
    },
    "366": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      source: "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "367": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      source: `pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;
use crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};

pub global POINT_LENGTH: u32 = 3;

// Note: Not deriving this because it's not supported to call derive_serialize on a "remote" struct (and it will never
// be supported).
impl Serialize for Point {
    let N: u32 = POINT_LENGTH;

    fn serialize(self: Self) -> [Field; Self::N] {
        [self.x, self.y, self.is_infinite as Field]
    }
}

impl Hash for Point {
    fn hash(self) -> Field {
        poseidon2_hash(self.serialize())
    }
}

impl Empty for Point {
    /// Note: Does not return a valid point on curve - instead represents an empty/"unpopulated" point struct (e.g.
    /// empty/unpopulated value in an array of points).
    fn empty() -> Self {
        Point { x: 0, y: 0, is_infinite: false }
    }
}

impl Deserialize for Point {
    let N: u32 = POINT_LENGTH;

    fn deserialize(serialized: [Field; Self::N]) -> Self {
        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }
    }
}

// TODO(#11356): use compact representation here.
impl Packable for Point {
    let N: u32 = POINT_LENGTH;

    fn pack(self) -> [Field; Self::N] {
        self.serialize()
    }

    fn unpack(packed: [Field; Self::N]) -> Self {
        Self::deserialize(packed)
    }
}
`
    },
    "368": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      source: "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "375": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      source: "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "380": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      source: "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "396": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      source: "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for bool {\n    #[inline_always]\n    fn empty() -> Self {\n        false\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "398": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      source: "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "399": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      source: "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "404": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      source: `global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.

pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {
    assert(bytes.len() < 32, "field_from_bytes: N must be less than 32");
    let mut as_field = 0;
    let mut offset = 1;
    for i in 0..N {
        let mut index = i;
        if big_endian {
            index = N - i - 1;
        }
        as_field += (bytes[index] as Field) * offset;
        offset *= 256;
    }

    as_field
}

// Convert a 32 byte array to a field element by truncating the final byte
pub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {
    // Convert it to a field element
    let mut v = 1;
    let mut high = 0 as Field;
    let mut low = 0 as Field;

    for i in 0..15 {
        // covers bytes 16..30 (31 is truncated and ignored)
        low = low + (bytes32[15 + 15 - i] as Field) * v;
        v = v * 256;
        // covers bytes 0..14
        high = high + (bytes32[14 - i] as Field) * v;
    }
    // covers byte 15
    low = low + (bytes32[15] as Field) * v;

    low + high * v
}

// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports
pub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {
    lhs.lt(rhs)
}

pub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {
    rhs.lt(lhs)
}

pub fn min(f1: Field, f2: Field) -> Field {
    if f1.lt(f2) {
        f1
    } else {
        f2
    }
}

global C1: u32 = 28;
global C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;
global C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;

pub fn pow(x: Field, y: Field) -> Field {
    let mut r = 1 as Field;
    let b: [u1; 254] = y.to_le_bits();

    for i in 0..254 {
        r *= r;
        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);
    }

    r
}

/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.
pub fn sqrt(x: Field) -> Option<Field> {
    // Safety: if the hint returns the square root of x, then we simply square it
    // check the result equals x. If x is not square, we return a value that
    // enables us to prove that fact (see the \`else\` clause below).
    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };

    if is_sq {
        let sqrt = maybe_sqrt;
        validate_sqrt_hint(x, sqrt);
        Option::some(sqrt)
    } else {
        let not_sqrt_hint = maybe_sqrt;
        validate_not_sqrt_hint(x, not_sqrt_hint);
        Option::none()
    }
}

// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.
unconstrained fn is_square(x: Field) -> bool {
    let v = pow(x, -1 / 2);
    v * (v - 1) == 0
}

// Tonelli-Shanks algorithm for computing the square root of a Field element.
// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field
// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),
// and C5 = ZETA^C2, where ZETA is a non-square element of Field.
// These are pre-computed above as globals.
unconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {
    let mut z = pow(x, C3);
    let mut t = z * z * x;
    z *= x;
    let mut b = t;
    let mut c = C5;

    for i in 0..(C1 - 1) {
        for _j in 1..(C1 - i - 1) {
            b *= b;
        }

        z *= if b == 1 { 1 } else { c };

        c *= c;

        t *= if b == 1 { 1 } else { c };

        b = t;
    }

    z
}

// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.
unconstrained fn __sqrt(x: Field) -> (bool, Field) {
    let is_sq = is_square(x);
    if is_sq {
        let sqrt = tonelli_shanks_sqrt(x);
        (true, sqrt)
    } else {
        // Demonstrate that x is not a square (a.k.a. a "quadratic non-residue").
        // Facts:
        // The Legendre symbol ("LS") of x, is x^((p-1)/2) (mod p).
        // - If x is a square, LS(x) = 1
        // - If x is not a square, LS(x) = -1
        // - If x = 0, LS(x) = 0.
        //
        // Hence:
        // sq * sq = sq // 1 * 1 = 1
        // non-sq * non-sq = sq // -1 * -1 = 1
        // sq * non-sq = non-sq // -1 * 1 = -1
        //
        // See: https://en.wikipedia.org/wiki/Legendre_symbol
        let demo_x_not_square = x * KNOWN_NON_RESIDUE;
        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);
        (false, not_sqrt)
    }
}

fn validate_sqrt_hint(x: Field, hint: Field) {
    assert(hint * hint == x, f"The claimed_sqrt {hint} is not the sqrt of x {x}");
}

fn validate_not_sqrt_hint(x: Field, hint: Field) {
    // We need this assertion, because x = 0 would pass the other assertions in this
    // function, and we don't want people to be able to prove that 0 is not square!
    assert(x != 0, "0 has a square root; you cannot claim it is not square");
    // Demonstrate that x is not a square (a.k.a. a "quadratic non-residue").
    //
    // Facts:
    // The Legendre symbol ("LS") of x, is x^((p-1)/2) (mod p).
    // - If x is a square, LS(x) = 1
    // - If x is not a square, LS(x) = -1
    // - If x = 0, LS(x) = 0.
    //
    // Hence:
    // 1. sq * sq = sq // 1 * 1 = 1
    // 2. non-sq * non-sq = sq // -1 * -1 = 1
    // 3. sq * non-sq = non-sq // -1 * 1 = -1
    //
    // See: https://en.wikipedia.org/wiki/Legendre_symbol
    //
    // We want to demonstrate that this below multiplication falls under bullet-point (2):
    let demo_x_not_square = x * KNOWN_NON_RESIDUE;
    // I.e. we want to demonstrate that \`demo_x_not_square\` has Legendre symbol 1
    // (i.e. that it is a square), so we prove that it is square below.
    // Why do we want to prove that it has LS 1?
    // Well, since it was computed with a known-non-residue, its squareness implies we're
    // in case 2 (something multiplied by a known-non-residue yielding a result which
    // has a LS of 1), which implies that x must be a non-square. The unconstrained
    // function gave us the sqrt of demo_x_not_square, so all we need to do is
    // assert its squareness:
    assert(
        hint * hint == demo_x_not_square,
        f"The hint {hint} does not demonstrate that {x} is not a square",
    );
}

#[test]
unconstrained fn bytes_field_test() {
    // Tests correctness of field_from_bytes_32_trunc against existing methods
    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7
    let inputs = [
        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,
        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,
    ];
    let field = field_from_bytes(inputs, true);
    let return_bytes: [u8; 31] = field.to_be_bytes();
    assert_eq(inputs, return_bytes);
    // 32 bytes - we remove the final byte, and check it matches the field
    let inputs2 = [
        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,
        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,
    ];
    let field2 = field_from_bytes_32_trunc(inputs2);
    let return_bytes2: [u8; 31] = field.to_be_bytes();

    assert_eq(return_bytes2, return_bytes);
    assert_eq(field2, field);
}

#[test]
unconstrained fn max_field_test() {
    // Tests the hardcoded value in constants.nr vs underlying modulus
    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files
    let max_value = crate::constants::MAX_FIELD_VALUE;
    assert_eq(max_value, 0 - 1);
    // modulus == 0 is tested elsewhere, so below is more of a sanity check
    let max_bytes: [u8; 32] = max_value.to_be_bytes();
    let mod_bytes = std::field::modulus_be_bytes();
    for i in 0..31 {
        assert_eq(max_bytes[i], mod_bytes[i]);
    }
    assert_eq(max_bytes[31], mod_bytes[31] - 1);
}

#[test]
unconstrained fn sqrt_valid_test() {
    let x = 16; // examples: 16, 9, 25, 81
    let result = sqrt(x);
    assert(result.is_some());
    assert_eq(result.unwrap() * result.unwrap(), x);
}

#[test]
unconstrained fn sqrt_invalid_test() {
    let x = KNOWN_NON_RESIDUE; // has no square root in the field
    let result = sqrt(x);
    assert(result.is_none());
}
`
    },
    "408": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      source: 'pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), "Reader did not read all data");\n    }\n}\n'
    },
    "419": {
      path: "/home/ubuntu/nargo/github.com/noir-lang/sha256/v0.3.0/src/sha256.nr",
      source: 'use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK_SIZE, INT_SIZE, INT_SIZE_PTR,\n    MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\nmod oracle_tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    assert(message_size <= N);\n\n    let (h, msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n    finalize_sha256_blocks(message_size, h, msg_block)\n}\n\n/// Returns the first partially filled message block along with the internal state prior to its compression.\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> (STATE, MSG_BLOCK) {\n    if std::runtime::is_unconstrained() {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = initial_state;\n        // Pointer into msg_block on a 64 byte scale\n        for i in 0..num_full_blocks {\n            let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n            h = sha256_compression(msg_block, h);\n        }\n\n        // We now build the final un-filled block.\n        let msg_byte_ptr = message_size % BLOCK_SIZE;\n        let msg_block: MSG_BLOCK = if msg_byte_ptr != 0 {\n            let num_full_blocks = message_size / BLOCK_SIZE;\n            let msg_start = BLOCK_SIZE * num_full_blocks;\n            build_msg_block(msg, message_size, msg_start)\n        } else {\n            // If the message size is a multiple of the block size (i.e. `msg_byte_ptr == 0`) then this block will be empty,\n            // so we short-circuit in this case.\n            [0; 16]\n        };\n\n        (h, msg_block)\n    } else {\n        let num_blocks = N / BLOCK_SIZE;\n\n        // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n        // for the given message size with a lookup.\n        //\n        // These can be reasoned about as followed:\n        // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n        // - `states[i]` should then be the state after processing the first `i` blocks.\n        // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n        // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n        //\n        // In other words:\n        //\n        // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n        // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n        //\n        // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n        let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n        let mut states: [STATE; N / BLOCK_SIZE + 1] = [initial_state; N / BLOCK_SIZE + 1];\n\n        // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n        // no matter the value of `message_size`.\n        //\n        // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n        let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n            message_size / BLOCK_SIZE\n        } else {\n            0\n        };\n\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let new_msg_block = build_msg_block(msg, message_size, msg_start);\n\n            blocks[i] = new_msg_block;\n            states[i + 1] = sha256_compression(new_msg_block, states[i]);\n        }\n        // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n        if N % BLOCK_SIZE != 0 {\n            let new_msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks);\n\n            blocks[num_blocks] = new_msg_block;\n        }\n\n        (states[first_partially_filled_block_index], blocks[first_partially_filled_block_index])\n    }\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block_helper<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Build a message block from the input message starting at `msg_start`.\n//\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn build_msg_block<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> MSG_BLOCK {\n    let msg_block =\n        // Safety: We constrain the block below by reconstructing each `u32` word from the input bytes.\n        unsafe { build_msg_block_helper(msg, message_size, msg_start) };\n\n    if !is_unconstrained() {\n        let mut msg_end = msg_start + BLOCK_SIZE;\n\n        let max_read_index = std::cmp::min(message_size, msg_end);\n\n        // Reconstructed packed item\n        let mut msg_item: Field = 0;\n\n        // Inclusive at the end so that we can compare the last item.\n        for k in msg_start..=msg_end {\n            if (k != msg_start) & (k % INT_SIZE == 0) {\n                // If we consumed some input we can compare against the block.\n                let msg_block_index = (k - msg_start) / INT_SIZE - 1;\n                assert_eq(msg_block[msg_block_index] as Field, msg_item);\n\n                msg_item = 0;\n            }\n\n            // If we have input to consume, add it at the rightmost position.\n            let msg_byte = if k < max_read_index { msg[k] } else { 0 };\n            msg_item = msg_item * (TWO_POW_8 as Field) + msg_byte as Field;\n        }\n    }\n    msg_block\n}\n\n// Encode `8 * message_size` into two `u32` limbs.\nunconstrained fn encode_len(message_size: u32) -> (u32, u32) {\n    let len = 8 * message_size as u64;\n    let lo = len & 0xFFFFFFFF;\n    let hi = (len >> 32) & 0xFFFFFFFF;\n    (lo as u32, hi as u32)\n}\n\n// Write the length into the last 8 bytes of the block.\nfn attach_len_to_msg_block(mut msg_block: MSG_BLOCK, message_size: u32) -> MSG_BLOCK {\n    // Safety: We assert the correctness of the decomposition below.\n    // 2 `u32` limbs cannot overflow the field modulus so performing the check as `Field`s is safe.\n    let (lo, hi) = unsafe { encode_len(message_size) };\n    assert_eq(8 * (message_size as Field), lo as Field + hi as Field * TWO_POW_32);\n\n    msg_block[INT_SIZE_PTR] = hi;\n    msg_block[INT_SIZE_PTR + 1] = lo;\n    msg_block\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n/// Lookup table for the position of the padding bit within one of the `u32` words in the final message block.\nglobal PADDING_BIT_TABLE: [u32; 4] =\n    [(1 << 7) * TWO_POW_24, (1 << 7) * TWO_POW_16, (1 << 7) * TWO_POW_8, (1 << 7)];\n\n/// Add 1 bit padding to end of message and compress the block if there\'s not enough room for the 8-byte length.\n/// Returns the updated hash state and message block that will be used to write the message size.\n///\n/// # Assumptions:\n///\n/// - `msg_block[i] == 0` for all `i > msg_byte_ptr / INT_SIZE`\n/// - `msg_block[msg_byte_ptr / INT_SIZE] & ((1 << 7) * (msg_byte_ptr % INT_SIZE)) == 0`\nfn add_padding_byte_and_compress_if_needed(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n\n    // Lookup the position of the padding bit and insert it into the message block.\n    msg_block[index] += PADDING_BIT_TABLE[msg_byte_ptr % INT_SIZE];\n\n    // If we don\'t have room to write the size, compress the block and reset it.\n    if msg_byte_ptr >= MSG_SIZE_PTR {\n        let h = sha256_compression(msg_block, h);\n\n        // In this case, the final block consists of all zeros with the last 8 bytes containing the length.\n        // We set msg_block to all zeros and attach_len_to_msg_block will add the length to the last 8 bytes.\n        let msg_block = [0; INT_BLOCK_SIZE];\n        (h, msg_block)\n    } else {\n        (h, msg_block)\n    }\n}\n\npub(crate) fn finalize_sha256_blocks(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    let (h, mut msg_block) = add_padding_byte_and_compress_if_needed(msg_block, msg_byte_ptr, h);\n\n    msg_block = attach_len_to_msg_block(msg_block, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, "Message size must be a multiple of the block size");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, "Message size must be a multiple of the block size");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (h, msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\n// Helper function to finalize the message block with padding and length\nunconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // We now build the final un-filled block.\n    let msg_block: MSG_BLOCK = if msg_byte_ptr != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        build_msg_block(msg, message_size, msg_start)\n    } else {\n        // If the message size is a multiple of the block size (i.e. `msg_byte_ptr == 0`) then this block will be empty,\n        // so we short-circuit in this case.\n        [0; 16]\n    };\n\n    // Once built, we need to add the necessary padding bytes and encoded length\n    let (h, mut msg_block) = add_padding_byte_and_compress_if_needed(msg_block, msg_byte_ptr, h);\n    msg_block = attach_len_to_msg_block(msg_block, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\nmod test_process_full_blocks {\n\n    /// Wrapper to force an unconstrained runtime on process_full_blocks.\n    unconstrained fn unconstrained_process_full_blocks<let N: u32>(\n        msg: [u8; N],\n        message_size: u32,\n        h: super::STATE,\n    ) -> (super::STATE, super::MSG_BLOCK) {\n        super::process_full_blocks(msg, message_size, h)\n    }\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u32) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_state =\n            unsafe { unconstrained_process_full_blocks(msg, message_size, super::INITIAL_STATE) };\n        let state = super::process_full_blocks(msg, message_size, super::INITIAL_STATE);\n        assert_eq(state, unconstrained_state);\n    }\n}\n\nmod test_sha256_var {\n\n    /// Wrapper to force an unconstrained runtime on sha256.\n    unconstrained fn unconstrained_sha256<let N: u32>(\n        msg: [u8; N],\n        message_size: u32,\n    ) -> super::HASH {\n        super::sha256_var(msg, message_size)\n    }\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u32) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { unconstrained_sha256(msg, message_size) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n\n}\n'
    },
    "42": {
      path: "std/option.nr",
      source: "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      path: "std/panic.nr",
      source: "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "47": {
      path: "std/slice.nr",
      source: 'use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn len_empty() {\n        let empty: [Field] = &[];\n        assert_eq(empty.len(), 0);\n    }\n\n    #[test]\n    fn len_single() {\n        assert_eq(&[42].len(), 1);\n    }\n\n    #[test]\n    fn len_multiple() {\n        assert_eq(&[1, 2, 3, 4, 5].len(), 5);\n    }\n\n    #[test]\n    fn push_back_empty() {\n        let empty: [Field] = &[];\n        let result = empty.push_back(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_back_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_back(4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn push_front_empty() {\n        let empty = &[];\n        let result = empty.push_front(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_front_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_front(0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test(should_fail_with = "Index out of bounds")]\n    fn pop_back_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_back();\n    }\n\n    #[test]\n    fn pop_back_one() {\n        let slice = &[42];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_back_multiple() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = "Index out of bounds")]\n    fn pop_front_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_front();\n    }\n\n    #[test]\n    fn pop_front_one() {\n        let slice = &[42];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_front_multiple() {\n        let slice = &[1, 2, 3];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn insert_beginning() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(0, 0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test]\n    fn insert_middle() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(1, 99);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 99, 2, 3]);\n    }\n\n    #[test]\n    fn insert_end() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(3, 4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test(should_fail_with = "Index out of bounds")]\n    fn insert_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let _ = slice.insert(3, 4);\n    }\n\n    #[test(should_fail_with = "Index out of bounds")]\n    fn remove_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.remove(0);\n    }\n\n    #[test]\n    fn remove_beginning() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(0);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn remove_middle() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(1);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 3]);\n        assert_eq(elem, 2);\n    }\n\n    #[test]\n    fn remove_end() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(2);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = "Index out of bounds")]\n    fn remove_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let (_, _) = slice.remove(2);\n    }\n\n    #[test]\n    fn fold_empty() {\n        let empty = &[];\n        let result = empty.fold(10, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn fold_single() {\n        let slice = &[5];\n        let result = slice.fold(10, |acc, x| acc + x);\n        assert_eq(result, 15);\n    }\n\n    #[test]\n    fn fold_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.fold(0, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test(should_fail_with = "Index out of bounds")]\n    fn reduce_empty() {\n        let empty: [Field] = &[];\n        let _ = empty.reduce(|a, b| a + b);\n    }\n\n    #[test]\n    fn reduce_single() {\n        let slice = &[42];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 42);\n    }\n\n    #[test]\n    fn reduce_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn filter_empty() {\n        let empty = &[];\n        let result = empty.filter(|x| x > 0);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 0);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn filter_all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 10);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_some() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0);\n        assert_eq(result, &[2, 4]);\n    }\n\n    #[test]\n    fn all_empty() {\n        let empty = &[];\n        let result = empty.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 2);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_empty() {\n        let empty = &[];\n        let result = empty.any(|x| x > 0);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 3);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn any_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 10);\n        assert_eq(result, false);\n    }\n\n    // utility method tests\n    #[test]\n    fn append_empty_to_empty() {\n        let empty1: [Field] = &[];\n        let empty2: [Field] = &[];\n        let result = empty1.append(empty2);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn append_empty_to_non_empty() {\n        let slice = &[1, 2, 3];\n        let empty = &[];\n        let result = slice.append(empty);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_non_empty_to_empty() {\n        let empty = &[];\n        let slice = &[1, 2, 3];\n        let result = empty.append(slice);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_two_non_empty() {\n        let slice1 = &[1, 2];\n        let slice2 = &[3, 4, 5];\n        let result = slice1.append(slice2);\n        assert_eq(result, &[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn as_array_single() {\n        let slice = &[42];\n        let array: [Field; 1] = slice.as_array();\n        assert_eq(array[0], 42);\n    }\n\n    #[test]\n    fn as_array_multiple() {\n        let slice = &[1, 2, 3];\n        let array: [Field; 3] = slice.as_array();\n        assert_eq(array[0], 1);\n        assert_eq(array[1], 2);\n        assert_eq(array[2], 3);\n    }\n\n    // complex scenarios\n    #[test]\n    fn chain_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0).map(|x| x * 2).fold(0, |acc, x| acc + x);\n        assert_eq(result, 12); // (2*2) + (4*2) = 4 + 8 = 12\n    }\n\n    #[test]\n    fn nested_operations() {\n        let slice = &[1, 2, 3, 4];\n        let filtered = slice.filter(|x| x > 1);\n        let mapped = filtered.map(|x| x * x);\n        let sum = mapped.fold(0, |acc, x| acc + x);\n        assert_eq(sum, 29); // 2^2 + 3^2 + 4^2 = 4 + 9 + 16 = 29\n    }\n\n    #[test]\n    fn single_element_operations() {\n        let single = &[42];\n\n        // Test all operations on single element\n        assert_eq(single.len(), 1);\n\n        let pushed_back = single.push_back(99);\n        assert_eq(pushed_back, &[42, 99]);\n\n        let pushed_front = single.push_front(0);\n        assert_eq(pushed_front, &[0, 42]);\n\n        let (popped_back_slice, popped_back_elem) = single.pop_back();\n        assert_eq(popped_back_slice.len(), 0);\n        assert_eq(popped_back_elem, 42);\n\n        let (popped_front_elem, popped_front_slice) = single.pop_front();\n        assert_eq(popped_front_slice.len(), 0);\n        assert_eq(popped_front_elem, 42);\n\n        let inserted = single.insert(0, 0);\n        assert_eq(inserted, &[0, 42]);\n\n        let (removed_slice, removed_elem) = single.remove(0);\n        assert_eq(removed_slice.len(), 0);\n        assert_eq(removed_elem, 42);\n    }\n\n    #[test]\n    fn boundary_conditions() {\n        let slice = &[1, 2, 3];\n\n        // insert at boundaries\n        let at_start = slice.insert(0, 0);\n        assert_eq(at_start, &[0, 1, 2, 3]);\n\n        let at_end = slice.insert(3, 4);\n        assert_eq(at_end, &[1, 2, 3, 4]);\n\n        // remove at boundaries\n        let (removed_start, elem_start) = slice.remove(0);\n        assert_eq(removed_start, &[2, 3]);\n        assert_eq(elem_start, 1);\n\n        let (removed_end, elem_end) = slice.remove(2);\n        assert_eq(removed_end, &[1, 2]);\n        assert_eq(elem_end, 3);\n    }\n\n    #[test]\n    fn complex_predicates() {\n        let slice = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n        let even_greater_than_5 = slice.filter(|x| (x % 2 == 0) & (x > 5));\n        assert_eq(even_greater_than_5, &[6, 8, 10]);\n\n        let all_positive_and_less_than_20 = slice.all(|x| (x > 0) & (x < 20));\n        assert_eq(all_positive_and_less_than_20, true);\n\n        let any_divisible_by_7 = slice.any(|x| x % 7 == 0);\n        assert_eq(any_divisible_by_7, true);\n    }\n\n    #[test]\n    fn identity_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n\n        let mapped_identity = slice.map(|x| x);\n        assert_eq(mapped_identity, slice);\n\n        let filtered_all = slice.filter(|_| true);\n        assert_eq(filtered_all, slice);\n\n        let filtered_none = slice.filter(|_| false);\n        assert_eq(filtered_none.len(), 0);\n    }\n\n    #[test(should_fail)]\n    fn as_array_size_mismatch() {\n        let slice = &[1, 2, 3];\n        let _: [Field; 5] = slice.as_array(); // size doesn\'t match\n    }\n}\n'
    },
    "470": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      source: "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n// docs:start:uint_note_def\n#[derive(Deserialize, Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    /// The number stored in the note.\n    pub value: u128,\n}\n// docs:end:uint_note_def\n\nimpl NoteHash for UintNote {\n    // docs:start:compute_note_hash\n    fn compute_note_hash(\n        self,\n        owner: AztecAddress,\n        storage_slot: Field,\n        randomness: Field,\n    ) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let partial_note = PartialUintNote {\n            commitment: compute_partial_commitment(owner, storage_slot, randomness),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n    // docs:end:compute_note_hash\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        owner: AztecAddress,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(\n        self,\n        owner: AztecAddress,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = compute_partial_commitment(owner, storage_slot, randomness);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = UintPartialNotePrivateLogContent { public_log_tag: commitment };\n\n        let encrypted_log = note::compute_partial_note_private_content_log(\n            private_log_content,\n            owner,\n            storage_slot,\n            randomness,\n            recipient,\n        );\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// Computes a commitment to the private content of a partial UintNote, i.e. the fields that will remain private. All\n/// other note fields will be made public.\n// docs:start:compute_partial_commitment\nfn compute_partial_commitment(\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [owner.to_field(), storage_slot, randomness],\n        GENERATOR_INDEX__NOTE_HASH,\n    )\n}\n// docs:end:compute_partial_commitment\n\n#[derive(Packable)]\nstruct UintPartialNotePrivateLogContent {\n    public_log_tag: Field,\n}\n\nimpl NoteType for UintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n// docs:start:partial_uint_note_def\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n// docs:end:partial_uint_note_def\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_anchor_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    // docs:start:compute_complete_note_hash\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n    // docs:end:compute_complete_note_hash\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        compute_partial_commitment, PartialUintNote, UintNote, UintPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n        let note = UintNote { value };\n        let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n\n        let partial_note = PartialUintNote {\n            commitment: compute_partial_commitment(owner, storage_slot, randomness),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n        let note = UintNote { value };\n\n        let commitment = compute_partial_commitment(owner, storage_slot, randomness);\n\n        let private_log_content = UintPartialNotePrivateLogContent { public_log_tag: commitment };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // The completion log without the tag should match the note's packed representation.\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n        assert_eq(public_log_without_tag, note.pack());\n    }\n}\n"
    },
    "5": {
      path: "std/cmp.nr",
      source: "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "52": {
      path: "/home/ubuntu/Dropbox/WEB/aztec/nft-portal-example/substance-aztec-evm-bridge/packages/aztec/aztec_gateway_7683/src/main.nr",
      source: 'pub mod config;\npub mod types;\npub mod utils;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract AztecGateway7683 {\n    // self.context.chain_id() returns 1, which corresponds to the mainnet, making it unsuitable for our use case.\n    // Instead, we designate 999999 as the destination domain.\n    global LOCAL_DOMAIN: u32 = 999999;\n\n    global UNKNOWN: Field = 0;\n    global OPENED: Field = 1;\n    global FILLED: Field = 2;\n    global FILLED_PRIVATELY: Field = 3;\n    global SETTLED: Field = 4;\n    global REFUNDED: Field = 5;\n\n    global SETTLE_ORDER_TYPE: [u8; 32] = [\n        25, 30, 167, 118, 189, 110, 12, 213, 106, 109, 68, 186, 74, 234, 47, 236, 70, 139, 74, 11,\n        76, 29, 136, 13, 64, 37, 146, 158, 235, 97, 93, 13,\n    ]; // sha256("SETTLE_ORDER_TYPE")\n    global REFUND_ORDER_TYPE: [u8; 32] = [\n        102, 173, 54, 216, 202, 16, 109, 169, 101, 99, 85, 97, 82, 171, 164, 185, 22, 236, 105, 110,\n        205, 208, 138, 62, 94, 211, 104, 244, 228, 115, 165, 56,\n    ]; // sha256("REFUND_ORDER_TYPE")\n    global SECRET: [u8; 6] = [83, 69, 67, 82, 69, 84]; // SECRET\n\n    use crate::{\n        config::Config,\n        types::{\n            events::{Filled, Open, Settled},\n            helpers::InternalRCOParams,\n            onchain_cross_chain_order::OnchainCrossChainOrder,\n            order_data::{\n                ORDER_DATA_LENGTH, ORDER_DATA_TYPE, OrderData, PRIVATE_ORDER,\n                PRIVATE_ORDER_WITH_HOOK, PUBLIC_ORDER, PUBLIC_ORDER_WITH_HOOK,\n            },\n            resolved_cross_chain_order::{\n                FILL_INSTRUCTIONS_MAX_INSTRUCTIONS, FillInstruction, MAX_SPENT_MAX_OUTPUTS,\n                MIN_RECEIVED_MAX_OUTPUTS, Output, RESOLVED_CROSS_CHAIN_LENGTH,\n                ResolvedCrossChainOrder,\n            },\n        },\n        utils::{u32_to_u8_4, u8_32_to_aztec_address, u8_32_to_eth_address, u8_32_to_u128},\n    };\n    use dep::aztec::{\n        macros::{functions::{external, initializer, internal, view}, storage::storage},\n        protocol_types::{\n            address::{AztecAddress, EthAddress},\n            hash::{poseidon2_hash, poseidon2_hash_with_separator, sha256_to_field},\n            traits::{Packable, Serialize},\n            constants::GENERATOR_INDEX__SECRET_HASH,\n        },\n        state_vars::{Map, PublicImmutable, PublicMutable},\n    };\n    use dep::aztec::macros::functions::only_self;\n    use token::Token;\n\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n        claimable_orders: Map<Field, PublicMutable<Field, Context>, Context>,\n        order_status: Map<Field, PublicMutable<Field, Context>, Context>,\n        used_nonces: Map<AztecAddress, Map<Field, PublicMutable<bool, Context>, Context>, Context>,\n        orders_settlement_block_numbers: Map<Field, PublicMutable<Field, Context>, Context>,\n        orders_refund_block_numbers: Map<Field, PublicMutable<Field, Context>, Context>,\n    }\n\n    #[external("public")]\n    #[initializer]\n    fn constructor(l2Gateway: EthAddress, l2GatewayDomain: u32, forwarder: EthAddress) {\n        self.storage.config.initialize(Config { l2Gateway, l2GatewayDomain, forwarder });\n    }\n\n    #[external("private")]\n    fn claim_private(\n        secret: Field,\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        let order_data = OrderData::decode(origin_data_bytes);\n        assert(order_data.id() == order_id, "Invalid id");\n\n        self.enqueue(AztecGateway7683::at(self.address)._assert_order_status_private(\n            order_id,\n            FILLED_PRIVATELY,\n        ));\n\n        // verify that a commitment exists for the given order.\n        self.enqueue(AztecGateway7683::at(self.address)._check_if_order_is_claimable_private(\n            order_id,\n            _get_claimable_order_commitment(order_id, filler_data_bytes),\n        ));\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        assert(\n            poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH) == Field::from_be_bytes(order_data.recipient),\n            "Invalid secret",\n        );\n\n        // transfer from gateway public balance to user private balance\n        let token = u8_32_to_aztec_address(order_data.output_token);\n        \n        // The transfer note completer needs to be this contract, \n        // therefore it is not possible to use transfer_public_to_private\n        let commitment = self.call(Token::at(token).initialize_transfer_commitment(\n            self.msg_sender().unwrap(),\n            self.address,\n        ));\n\n        self.enqueue(Token::at(token).transfer_public_to_commitment(\n            self.address,\n            commitment,\n            u8_32_to_u128(order_data.amount_out),\n            0,\n        ));\n\n        self.enqueue(AztecGateway7683::at(self.address)._update_order_status_private(\n            order_id,\n            FILLED,\n        ));\n\n        self.enqueue(AztecGateway7683::at(self.address)._trigger_settlement(\n            order_id,\n            _get_settle_content_hash(order_id_bytes, filler_data_bytes),\n        ));\n    }\n\n    #[external("public")]\n    fn claim_refund(\n        order_id_bytes: [u8; 32],\n        order_data_bytes: [u8; ORDER_DATA_LENGTH],\n        message_leaf_index: Field,\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        let order_data = OrderData::decode(order_data_bytes);\n        assert(order_data.id() == order_id, "Invalid id");\n        assert(self.storage.order_status.at(order_id).read() == OPENED, "Order not opened");\n        self.storage.order_status.at(order_id).write(REFUNDED);\n\n        assert(\n            (order_data.order_type == PUBLIC_ORDER)\n                | (order_data.order_type == PUBLIC_ORDER_WITH_HOOK),\n            "Not a public order",\n        );\n        let config = self.storage.config.read();\n        assert(\n            u8_32_to_eth_address(order_data.destination_settler) == config.l2Gateway,\n            "Invalid destination settler",\n        );\n        assert(\n            order_data.destination_domain == config.l2GatewayDomain,\n            "Invalid destination domain",\n        );\n\n        self.context.consume_l1_to_l2_message(\n            _get_refund_content_hash(order_id_bytes),\n            Field::from_be_bytes(SECRET),\n            self.storage.config.read().forwarder,\n            message_leaf_index,\n        );\n\n        self.call(Token::at(u8_32_to_aztec_address(order_data.input_token))\n            .transfer_public_to_public(\n                self.address,\n                u8_32_to_aztec_address(order_data.sender),\n                u8_32_to_u128(order_data.amount_in),\n                0,\n            ));\n        // TODO: emit Refunded\n    }\n\n    #[external("private")]\n    fn claim_refund_private(\n        secret: Field,\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        message_leaf_index: Field,\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        let order_data = OrderData::decode(origin_data_bytes);\n        assert(order_data.id() == order_id, "Invalid id");\n\n        self.enqueue(AztecGateway7683::at(self.address)._check_refund_private(order_id));\n\n        let order_data = OrderData::decode(origin_data_bytes);\n        let order_type = order_data.order_type;\n        assert(\n            poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH) == Field::from_be_bytes(order_data.recipient),\n            "Invalid secret",\n        );\n        assert(\n            (order_type == PRIVATE_ORDER) | (order_type == PRIVATE_ORDER_WITH_HOOK),\n            "Not a private order",\n        );\n        let config = self.storage.config.read();\n        assert(\n            u8_32_to_eth_address(order_data.destination_settler) == config.l2Gateway,\n            "Invalid destination settler",\n        );\n        assert(\n            order_data.destination_domain == config.l2GatewayDomain,\n            "Invalid destination domain",\n        );\n\n        self.context.consume_l1_to_l2_message(\n            _get_refund_content_hash(order_id_bytes),\n            Field::from_be_bytes(SECRET),\n            self.storage.config.read().forwarder,\n            message_leaf_index,\n        );\n\n        let token = u8_32_to_aztec_address(order_data.input_token);\n\n        // The transfer note completer needs to be this contract, \n        // therefore it is not possible to use transfer_public_to_private\n        let commitment = self.call(Token::at(token).initialize_transfer_commitment(\n            self.msg_sender().unwrap(),\n            self.address,\n        ));\n\n        self.enqueue(Token::at(token).transfer_public_to_commitment(\n            self.address,\n            commitment,\n            u8_32_to_u128(order_data.amount_in),\n            0,\n        ));\n    }\n\n    #[external("public")]\n    fn fill(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        let order_data = OrderData::decode(origin_data_bytes);\n        assert(order_id == order_data.id(), "Invalid id");\n\n        let order_type = order_data.order_type;\n        assert(\n            (order_type == PUBLIC_ORDER) | (order_type == PUBLIC_ORDER_WITH_HOOK),\n            "Not a public order",\n        );\n        assert(self.storage.order_status.at(order_id).read() == UNKNOWN, "Invalid status");\n        assert(self.context.timestamp() as u32 <= order_data.fill_deadline, "Order fill expired");\n        assert(order_data.destination_domain == LOCAL_DOMAIN, "Invalid destination domain");\n        self.storage.order_status.at(order_id).write(FILLED);\n\n        // transfer from filler public balance to gateway public balance\n        self.call(Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_public_to_public(\n                self.msg_sender().unwrap(),\n                u8_32_to_aztec_address(order_data.recipient),\n                u8_32_to_u128(order_data.amount_out),\n                Field::from_be_bytes(order_data.sender_nonce),\n            ));\n\n        self.call(AztecGateway7683::at(self.address)._trigger_settlement(\n            order_id,\n            _get_settle_content_hash(order_id_bytes, filler_data_bytes), // at the moment filler data contains the ethereum address where the filler wants to receive the funds during the settlement\n        ));\n\n        self.context.emit_public_log(Filled {\n            order_id: order_id_bytes,\n            origin_data: origin_data_bytes,\n            filler_data: filler_data_bytes,\n        }\n            .pack());\n    }\n\n    #[external("private")]\n    fn fill_private(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n    ) {\n        let order_data = OrderData::decode(origin_data_bytes);\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        assert(order_id == order_data.id(), "Invalid id");\n\n        // transfer from filler private balance to gateway public balance\n        self.call(Token::at(u8_32_to_aztec_address(order_data.output_token))\n            .transfer_private_to_public(\n                self.msg_sender().unwrap(),\n                self.address,\n                u8_32_to_u128(order_data.amount_out),\n                Field::from_be_bytes(order_data.sender_nonce),\n            ));\n\n        assert(order_data.destination_domain == LOCAL_DOMAIN, "Invalid destination domain");\n        assert(\n            (order_data.order_type == PRIVATE_ORDER)\n                | (order_data.order_type == PRIVATE_ORDER_WITH_HOOK),\n            "Not a private order",\n        );\n        self.enqueue(AztecGateway7683::at(self.address)._fill_private(\n            order_id,\n            order_id_bytes,\n            origin_data_bytes,\n            filler_data_bytes,\n            order_data.fill_deadline,\n        ));\n    }\n\n    #[external("public")]\n    #[view]\n    fn get_order_status(order_id: Field) -> Field {\n        self.storage.order_status.at(order_id).read()\n    }\n\n    #[external("public")]\n    #[view]\n    fn get_order_refund_block_number(order_id: Field) -> Field {\n        self.storage.orders_refund_block_numbers.at(order_id).read()\n    }\n\n    #[external("public")]\n    #[view]\n    fn get_order_settlement_block_number(order_id: Field) -> Field {\n        self.storage.orders_settlement_block_numbers.at(order_id).read()\n    }\n\n    #[external("public")]\n    fn open(order: OnchainCrossChainOrder) {\n        assert(order.order_data_type == ORDER_DATA_TYPE, "Invalid data type");\n\n        let data = _resolve(\n            order,\n            self.msg_sender().unwrap(),\n            self.context.timestamp() as u32,\n        );\n        let resolved_order = data.resolved_cross_chain_order;\n        let order_id = data.order_id;\n        let nonce = Field::from_be_bytes(data.order_data.sender_nonce);\n        let order_type = data.order_data.order_type;\n        assert(\n            (order_type == PUBLIC_ORDER) | (order_type == PUBLIC_ORDER_WITH_HOOK),\n            "Not a public order",\n        );\n        assert(data.order_data.origin_domain == LOCAL_DOMAIN, "Invalid origin domain");\n        assert(\n            !self.storage.used_nonces.at(self.msg_sender().unwrap()).at(nonce).read(),\n            "Invalid nonce",\n        );\n\n        self.storage.order_status.at(order_id).write(OPENED);\n        self.storage.used_nonces.at(self.msg_sender().unwrap()).at(nonce).write(true);\n\n        for i in 0..resolved_order.min_received.len() {\n            let min_received = resolved_order.min_received[i];\n\n            self.call(Token::at(u8_32_to_aztec_address(min_received.token))\n                .transfer_public_to_public(\n                    self.msg_sender().unwrap(),\n                    self.address,\n                    u8_32_to_u128(min_received.amount),\n                    nonce,\n                ));\n        }\n\n        let event = Open::new(resolved_order.order_id, resolved_order.serialize());\n        self.context.emit_public_log(event.open1.pack());\n        self.context.emit_public_log(event.open2.pack());\n    }\n\n    #[external("private")]\n    fn open_private(order: OnchainCrossChainOrder) {\n        assert(order.order_data_type == ORDER_DATA_TYPE, "Invalid data type");\n\n        // Force the sender to be zero in order to avoid creating a connection between the sender and the recipient\n        let data = _resolve(order, AztecAddress::zero(), 0 as u32);\n        let resolved_order = data.resolved_cross_chain_order;\n        let order_id = data.order_id;\n        let nonce = Field::from_be_bytes(data.order_data.sender_nonce);\n\n        assert(\n            (data.order_data.order_type == PRIVATE_ORDER)\n                | (data.order_data.order_type == PRIVATE_ORDER_WITH_HOOK),\n            "Not a private order",\n        );\n        assert(data.order_data.origin_domain == LOCAL_DOMAIN, "Invalid origin domain");\n\n        self.enqueue(AztecGateway7683::at(self.address)._assert_nonce_and_set_order_status_private(\n            order_id,\n            nonce,\n        ));\n\n        for i in 0..resolved_order.min_received.len() {\n            let min_received = resolved_order.min_received[i];\n\n            // transfer from user private balance to gateway public balance\n            self.call(Token::at(u8_32_to_aztec_address(min_received.token))\n                .transfer_private_to_public(\n                    self.msg_sender().unwrap(),\n                    self.address,\n                    u8_32_to_u128(min_received.amount),\n                    nonce,\n                ));\n        }\n\n        self.enqueue(AztecGateway7683::at(self.address)._emit_open_private(\n            resolved_order.order_id,\n            resolved_order.serialize(),\n        ));\n    }\n\n    #[external("public")]\n    fn refund(order_id_bytes: [u8; 32], origin_data_bytes: [u8; ORDER_DATA_LENGTH]) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        let order_data = OrderData::decode(origin_data_bytes);\n        assert(order_data.id() == order_id, "Invalid id");\n        assert(self.storage.order_status.at(order_id).read() == UNKNOWN, "Invalid status");\n        assert(self.context.timestamp() as u32 > order_data.fill_deadline, "Order not expired");\n        self.storage.orders_refund_block_numbers.at(order_id).write(\n            self.context.block_number() as Field,\n        );\n        self.context.message_portal(\n            self.storage.config.read().forwarder,\n            _get_refund_content_hash(order_id_bytes),\n        );\n    }\n\n    #[external("public")]\n    fn settle(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n        message_leaf_index: Field,\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        let order_data = OrderData::decode(origin_data_bytes);\n        assert(order_data.id() == order_id, "Invalid id");\n        assert(self.storage.order_status.at(order_id).read() == OPENED, "Invalid status");\n        assert(\n            (order_data.order_type == PUBLIC_ORDER)\n                | (order_data.order_type == PUBLIC_ORDER_WITH_HOOK),\n            "Not a public order",\n        );\n        let config = self.storage.config.read();\n        assert(\n            u8_32_to_eth_address(order_data.destination_settler) == config.l2Gateway,\n            "Invalid destination settler",\n        );\n        assert(\n            order_data.destination_domain == config.l2GatewayDomain,\n            "Invalid destination domain",\n        );\n\n        self.context.consume_l1_to_l2_message(\n            _get_settle_content_hash(order_id_bytes, filler_data_bytes),\n            Field::from_be_bytes(SECRET),\n            self.storage.config.read().forwarder,\n            message_leaf_index,\n        );\n\n        // transfer from gateway public balance to user public balande\n        self.call(Token::at(u8_32_to_aztec_address(order_data.input_token))\n            .transfer_public_to_public(\n                self.address,\n                u8_32_to_aztec_address(filler_data_bytes),\n                u8_32_to_u128(order_data.amount_in),\n                0,\n            ));\n\n        self.storage.order_status.at(order_id).write(SETTLED);\n        self.context.emit_public_log(Settled {\n            order_id: order_id_bytes,\n            receiver: filler_data_bytes,\n        }\n            .pack());\n    }\n\n    #[external("private")]\n    fn settle_private(\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n        message_leaf_index: Field,\n    ) {\n        let order_id = Field::from_be_bytes(order_id_bytes);\n        let order_data = OrderData::decode(origin_data_bytes);\n        assert(order_data.id() == order_id, "Invalid id");\n\n        self.enqueue(AztecGateway7683::at(self.address)._assert_order_status_private(\n            order_id,\n            OPENED,\n        ));\n\n        assert(\n            (order_data.order_type == PRIVATE_ORDER)\n                | (order_data.order_type == PRIVATE_ORDER_WITH_HOOK),\n            "Not a private order",\n        );\n        let config = self.storage.config.read();\n        assert(\n            u8_32_to_eth_address(order_data.destination_settler) == config.l2Gateway,\n            "Invalid destination settler",\n        );\n        assert(\n            order_data.destination_domain == config.l2GatewayDomain,\n            "Invalid destination domain",\n        );\n\n        self.context.consume_l1_to_l2_message(\n            _get_settle_content_hash(order_id_bytes, filler_data_bytes),\n            Field::from_be_bytes(SECRET),\n            self.storage.config.read().forwarder,\n            message_leaf_index,\n        );\n\n        let filler = u8_32_to_aztec_address(filler_data_bytes);\n        let token = u8_32_to_aztec_address(order_data.input_token);\n\n        // The transfer note completer needs to be this contract, \n        // therefore it is not possible to use transfer_public_to_private\n        let commitment = self.call(Token::at(token).initialize_transfer_commitment(\n            filler,\n            self.address,\n        ));\n\n        self.enqueue(Token::at(token).transfer_public_to_commitment(\n            self.address,\n            commitment,\n            u8_32_to_u128(order_data.amount_in),\n            0,\n        ));\n\n        self.enqueue(AztecGateway7683::at(self.address)._update_order_status_private(\n            order_id,\n            SETTLED,\n        ));\n\n        self.enqueue(AztecGateway7683::at(self.address)._emit_settled_private(\n            order_id_bytes,\n            filler_data_bytes,\n        ));\n    }\n\n    #[external("public")]\n    #[only_self]\n    fn _assert_nonce_and_set_order_status_private(order_id: Field, nonce: Field) {\n        assert(\n            !self.storage.used_nonces.at(self.msg_sender().unwrap()).at(nonce).read(),\n            "Invalid nonce",\n        );\n        self.storage.used_nonces.at(self.msg_sender().unwrap()).at(nonce).write(true);\n        self.storage.order_status.at(order_id).write(OPENED);\n    }\n\n    #[external("public")]\n    #[only_self]\n    fn _assert_order_status_private(order_id: Field, status: Field) {\n        assert(self.storage.order_status.at(order_id).read() == status, "Invalid status");\n    }\n\n    #[external("public")]\n    #[only_self]\n    fn _check_if_order_is_claimable_private(order_id: Field, claimable_order_commitment: Field) {\n        assert(\n            self.storage.claimable_orders.at(order_id).read() == claimable_order_commitment,\n            "Invalid order",\n        );\n    }\n\n    #[external("public")]\n    #[only_self]\n    fn _check_refund_private(order_id: Field) {\n        assert(self.storage.order_status.at(order_id).read() == OPENED, "Order not opened");\n        self.storage.order_status.at(order_id).write(REFUNDED);\n        // TODO: emit Refunded\n    }\n\n    #[external("public")]\n    #[only_self]\n    fn _emit_open_private(\n        order_id_bytes: [u8; 32],\n        resolved_order_bytes: [Field; RESOLVED_CROSS_CHAIN_LENGTH],\n    ) {\n        let event = Open::new(order_id_bytes, resolved_order_bytes);\n        self.context.emit_public_log(event.open1.pack());\n        self.context.emit_public_log(event.open2.pack());\n    }\n\n    #[external("public")]\n    #[only_self]\n    fn _emit_settled_private(order_id_bytes: [u8; 32], receiver: [u8; 32]) {\n        self.context.emit_public_log(Settled { order_id: order_id_bytes, receiver }.pack());\n    }\n\n    #[external("public")]\n    #[only_self]\n    fn _fill_private(\n        order_id: Field,\n        order_id_bytes: [u8; 32],\n        origin_data_bytes: [u8; ORDER_DATA_LENGTH],\n        filler_data_bytes: [u8; 32],\n        fill_deadline: u32,\n    ) {\n        assert(self.storage.order_status.at(order_id).read() == UNKNOWN, "Invalid status");\n        assert(self.context.timestamp() as u32 <= fill_deadline, "Order is expired");\n\n        let order_commitment = _get_claimable_order_commitment(order_id, filler_data_bytes);\n        self.storage.claimable_orders.at(order_id).write(order_commitment);\n        self.storage.order_status.at(order_id).write(FILLED_PRIVATELY);\n        self.context.emit_public_log(Filled {\n            order_id: order_id_bytes,\n            origin_data: origin_data_bytes,\n            filler_data: filler_data_bytes,\n        }\n            .pack());\n    }\n\n    #[external("public")]\n    #[only_self]\n    fn _trigger_settlement(order_id: Field, content_hash: Field) {\n        self.storage.orders_settlement_block_numbers.at(order_id).write(\n            self.context.block_number() as Field,\n        );\n        self.context.message_portal(self.storage.config.read().forwarder, content_hash);\n    }\n\n    #[external("public")]\n    #[only_self]\n    fn _update_order_status_private(order_id: Field, status: Field) {\n        self.storage.order_status.at(order_id).write(status);\n    }\n\n    #[contract_library_method]\n    fn _get_claimable_order_commitment(order_id: Field, filler_data_bytes: [u8; 32]) -> Field {\n        poseidon2_hash([order_id, Field::from_be_bytes(filler_data_bytes)])\n    }\n\n    #[contract_library_method]\n    fn _get_settle_content_hash(order_id_bytes: [u8; 32], filler_data_bytes: [u8; 32]) -> Field {\n        let mut hash_bytes = [0; 96];\n        for i in 0..32 {\n            hash_bytes[i] = SETTLE_ORDER_TYPE[i];\n            hash_bytes[i + 32] = order_id_bytes[i];\n            hash_bytes[i + 64] = filler_data_bytes[i];\n        }\n        sha256_to_field(hash_bytes)\n    }\n\n    #[contract_library_method]\n    fn _get_refund_content_hash(order_id_bytes: [u8; 32]) -> Field {\n        let mut hash_bytes = [0; 64];\n        for i in 0..32 {\n            hash_bytes[i] = REFUND_ORDER_TYPE[i];\n            hash_bytes[i + 32] = order_id_bytes[i];\n        }\n        sha256_to_field(hash_bytes)\n    }\n\n    #[contract_library_method]\n    fn _resolve(\n        order: OnchainCrossChainOrder,\n        sender: AztecAddress,\n        timestamp: u32,\n    ) -> InternalRCOParams {\n        let mut order_data = OrderData::decode(order.order_data);\n        let order_id = order_data.id();\n\n        assert(order_data.fill_deadline == order.fill_deadline, "Invalid fill deadline");\n        assert(u8_32_to_aztec_address(order_data.sender) == sender, "Invalid sender");\n\n        let destination_domain_bytes = u32_to_u8_4(order_data.destination_domain);\n        let min_received_output = Output {\n            token: order_data.input_token,\n            recipient: [0; 32],\n            amount: order_data.amount_in,\n            chain_id: u32_to_u8_4(order_data.origin_domain),\n        };\n        let min_received: [Output; MIN_RECEIVED_MAX_OUTPUTS] =\n            [min_received_output; MIN_RECEIVED_MAX_OUTPUTS];\n\n        let max_spent_output = Output {\n            token: order_data.output_token,\n            recipient: order_data.recipient,\n            amount: order_data.amount_out,\n            chain_id: destination_domain_bytes,\n        };\n        let max_spent: [Output; MAX_SPENT_MAX_OUTPUTS] = [max_spent_output; MAX_SPENT_MAX_OUTPUTS];\n\n        let fill_instruction = FillInstruction {\n            destination_chain_id: destination_domain_bytes,\n            destination_settler: order_data.destination_settler,\n            origin_data: order.order_data,\n        };\n        let fill_instructions: [FillInstruction; FILL_INSTRUCTIONS_MAX_INSTRUCTIONS] =\n            [fill_instruction; FILL_INSTRUCTIONS_MAX_INSTRUCTIONS];\n\n        let order_id_bytes = order_id.to_be_bytes();\n        let resolved_order = ResolvedCrossChainOrder {\n            user: order_data.sender,\n            origin_chain_id: u32_to_u8_4(LOCAL_DOMAIN),\n            open_deadline: u32_to_u8_4(timestamp),\n            fill_deadline: u32_to_u8_4(order.fill_deadline),\n            order_id: order_id_bytes,\n            min_received,\n            max_spent,\n            fill_instructions,\n        };\n\n        InternalRCOParams { order_id, resolved_cross_chain_order: resolved_order, order_data }\n    }\n}\n'
    },
    "6": {
      path: "std/collections/bounded_vec.nr",
      source: 'use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a [`Vec`][crate::collections::vec::Vec]`<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`\'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can\'t infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, "Attempted to read past end of BoundedVec");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, "Attempted to write past end of BoundedVec");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we\'re safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We\'ve now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won\'t cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion "push out of bounds"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, "push out of bounds");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, "extend_from_array out of bounds");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, "extend_from_slice out of bounds");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, "extend_from_bounded_vec out of bounds");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, "from array out of bounds");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, "cannot pop from an empty vector");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we\'d expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = "Attempted to read past end of BoundedVec")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = "Attempted to read past end of BoundedVec")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = "Attempted to write past end of BoundedVec")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = "Attempted to write past end of BoundedVec")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = "Attempted to read past end of BoundedVec")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = "from array out of bounds")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we\'d expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = "push out of bounds")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = "cannot pop from an empty vector")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = "extend_from_array out of bounds")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = "extend_from_slice out of bounds")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = "extend_from_bounded_vec out of bounds")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn\'t change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n'
    },
    "60": {
      path: "/home/ubuntu/Dropbox/WEB/aztec/nft-portal-example/substance-aztec-evm-bridge/packages/aztec/aztec_gateway_7683/src/types/events.nr",
      source: 'use crate::types::{\n    order_data::ORDER_DATA_LENGTH, resolved_cross_chain_order::RESOLVED_CROSS_CHAIN_LENGTH,\n};\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n// #[event]\n#[derive(Serialize)]\npub struct Filled {\n    pub order_id: [u8; 32],\n    pub origin_data: [u8; ORDER_DATA_LENGTH],\n    pub filler_data: [u8; 32],\n}\n\n// 301 + 32 + 32 = 365      365 / 31 = 11.74 = 12 + 1 (residual bytes) = 13\nimpl Packable for Filled {\n    let N: u32 = 13;\n    \n    fn pack(self) -> [Field; Self::N] {\n        let mut packed: [Field; 13] = [0; 13];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        let mut filler_data_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n            filler_data_31[i] = self.filler_data[i];\n        }\n        residual_bytes[0] = self.order_id[31];\n        residual_bytes[10] = self.filler_data[31];\n\n        for i in 0..10 {\n            let mut partial = [0; 31];\n            let offset = 32 * i;\n\n            for j in 0..31 {\n                let k = offset + j;\n                if k < ORDER_DATA_LENGTH {\n                    partial[j] = self.origin_data[k];\n                }\n            }\n            packed[i + 1] = Field::from_be_bytes(partial);\n\n            if i < 9 {\n                // no residual bytes for the last one\n                residual_bytes[i + 1] = self.origin_data[offset + 31];\n            }\n        }\n\n        packed[0] = Field::from_be_bytes::<31>(order_id_31);\n        packed[11] = Field::from_be_bytes::<31>(filler_data_31);\n        packed[12] = Field::from_be_bytes::<31>(residual_bytes);\n        packed\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        assert(true == false, "not implemented");\n        Self { order_id: [0; 32], origin_data: [0; ORDER_DATA_LENGTH], filler_data: [0; 32] }\n    }\n}\n\n// #[event]\n#[derive(Serialize)]\npub struct Open1 {\n    pub order_id: [u8; 32],\n    pub resolved_order: [u8; 340],\n}\n\nimpl Packable for Open1 {\n    let N: u32 = 13;\n    \n    fn pack(self) -> [Field; Self::N] {\n        let mut packed: [Field; 13] = [0; 13];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n        }\n        residual_bytes[0] = self.order_id[31];\n\n        for i in 0..12 {\n            let mut partial = [0; 31];\n            let offset = 32 * i;\n\n            for j in 0..31 {\n                let k = offset + j;\n                if k < 340 {\n                    partial[j] = self.resolved_order[k];\n                }\n            }\n            packed[i + 1] = Field::from_be_bytes(partial);\n\n            let residual_bytes_offset = offset + 31;\n            if residual_bytes_offset < 340 {\n                residual_bytes[i + 1] = self.resolved_order[residual_bytes_offset];\n            }\n        }\n\n        packed[0] = Field::from_be_bytes::<31>(order_id_31);\n        packed[12] = Field::from_be_bytes::<31>(residual_bytes);\n        packed\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        assert(true == false, "not implemented");\n        Self { order_id: [0; 32], resolved_order: [0; 340] }\n    }\n}\n\n// #[event]\n#[derive(Serialize)]\npub struct Open2 {\n    pub order_id: [u8; 32],\n    pub resolved_order: [u8; 273],\n}\n\nimpl Packable for Open2 {\n    let N: u32 = 11;\n    \n    fn pack(self) -> [Field; Self::N] {\n        let mut packed: [Field; 11] = [0; 11];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n        }\n        residual_bytes[0] = self.order_id[31];\n\n        for i in 0..10 {\n            let mut partial = [0; 31];\n            let offset = 32 * i;\n\n            for j in 0..31 {\n                let k = offset + j;\n                if k < 273 {\n                    partial[j] = self.resolved_order[k];\n                }\n            }\n            packed[i + 1] = Field::from_be_bytes(partial);\n\n            let residual_bytes_offset = offset + 31;\n            if residual_bytes_offset < 273 {\n                residual_bytes[i + 1] = self.resolved_order[residual_bytes_offset];\n            }\n        }\n\n        packed[0] = Field::from_be_bytes::<31>(order_id_31);\n        packed[10] = Field::from_be_bytes::<31>(residual_bytes);\n        packed\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        assert(true == false, "not implemented");\n        Self { order_id: [0; 32], resolved_order: [0; 273] }\n    }\n}\n\npub struct Open {\n    pub open1: Open1,\n    pub open2: Open2,\n}\n\nimpl Open {\n    pub fn new(order_id: [u8; 32], resolved_order: [Field; RESOLVED_CROSS_CHAIN_LENGTH]) -> Self {\n        let mut resolved_order1 = [0; 340];\n        for i in 0..340 {\n            resolved_order1[i] = resolved_order[i] as u8;\n        }\n        let mut resolved_order2 = [0; 273];\n        for i in 0..273 {\n            resolved_order2[i] = resolved_order[i + 340] as u8;\n        }\n\n        Self {\n            open1: Open1 { order_id, resolved_order: resolved_order1 },\n            open2: Open2 { order_id, resolved_order: resolved_order2 },\n        }\n    }\n}\n\n//#[event]\n#[derive(Serialize)]\npub struct Settled {\n    pub order_id: [u8; 32],\n    pub receiver: [u8; 32],\n}\n\nimpl Packable for Settled {\n    let N: u32 = 3;\n    \n    fn pack(self) -> [Field; Self::N] {\n        let mut packed: [Field; 3] = [0; 3];\n        let mut residual_bytes = [0; 31];\n\n        let mut order_id_31 = [0; 31];\n        let mut receiver_31 = [0; 31];\n        for i in 0..31 {\n            order_id_31[i] = self.order_id[i];\n            receiver_31[i] = self.receiver[i]\n        }\n        residual_bytes[0] = self.order_id[31];\n        residual_bytes[1] = self.receiver[31];\n\n        packed[0] = Field::from_be_bytes::<31>(order_id_31);\n        packed[1] = Field::from_be_bytes::<31>(receiver_31);\n        packed[2] = Field::from_be_bytes::<31>(residual_bytes);\n        packed\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        assert(true == false, "not implemented");\n        Self { order_id: [0; 32], receiver: [0; 32] }\n    }\n}\n'
    },
    "63": {
      path: "/home/ubuntu/Dropbox/WEB/aztec/nft-portal-example/substance-aztec-evm-bridge/packages/aztec/aztec_gateway_7683/src/types/order_data.nr",
      source: "use crate::utils::u8_4_to_u32;\nuse dep::aztec::protocol_types::{hash::poseidon2_hash, traits::{Deserialize, Serialize}};\n\npub global ORDER_DATA_LENGTH: u32 = 301;\npub global ORDER_DATA_TYPE: [u8; 32] = [\n    240, 12, 59, 246, 12, 115, 235, 151, 9, 127, 28, 152, 53, 83, 125, 160, 20, 224, 183, 85, 254,\n    148, 178, 93, 122, 200, 64, 29, 246, 103, 22, 160,\n];\n\npub global PUBLIC_ORDER: u8 = 0;\npub global PRIVATE_ORDER: u8 = 1;\npub global PUBLIC_ORDER_WITH_HOOK: u8 = 2;\npub global PRIVATE_ORDER_WITH_HOOK: u8 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OrderData {\n    pub sender: [u8; 32],\n    pub recipient: [u8; 32],\n    pub input_token: [u8; 32],\n    pub output_token: [u8; 32],\n    pub amount_in: [u8; 32],\n    pub amount_out: [u8; 32],\n    pub sender_nonce: [u8; 32],\n    pub origin_domain: u32,\n    pub destination_domain: u32,\n    pub destination_settler: [u8; 32],\n    pub fill_deadline: u32,\n    pub order_type: u8,\n    pub data: [u8; 32],\n}\n\nimpl OrderData {\n    pub fn decode(bytes: [u8; ORDER_DATA_LENGTH]) -> OrderData {\n        let sender = u8_order_data_length_to_u8_32(bytes, 0);\n        let recipient = u8_order_data_length_to_u8_32(bytes, 32);\n        let input_token = u8_order_data_length_to_u8_32(bytes, 64);\n        let output_token = u8_order_data_length_to_u8_32(bytes, 96);\n        let amount_in = u8_order_data_length_to_u8_32(bytes, 128);\n        let amount_out = u8_order_data_length_to_u8_32(bytes, 160);\n        let sender_nonce = u8_order_data_length_to_u8_32(bytes, 192);\n        let origin_domain = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 224));\n        let destination_domain = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 228));\n        let destination_settler = u8_order_data_length_to_u8_32(bytes, 232);\n        let fill_deadline = u8_4_to_u32(u8_order_data_length_to_u8_4(bytes, 264));\n        let order_type = u8_order_data_length_to_u8(bytes, 268);\n        let data = u8_order_data_length_to_u8_32(bytes, 269);\n\n        OrderData {\n            sender,\n            recipient,\n            input_token,\n            output_token,\n            amount_in,\n            amount_out,\n            sender_nonce,\n            origin_domain,\n            destination_domain,\n            destination_settler,\n            fill_deadline,\n            order_type,\n            data,\n        }\n    }\n\n    pub fn id(self: Self) -> Field {\n        let mut fields: [Field; 13] = [0; 13];\n        fields[0] = Field::from_be_bytes(self.sender);\n        fields[1] = Field::from_be_bytes(self.recipient);\n        fields[2] = Field::from_be_bytes(self.input_token);\n        fields[3] = Field::from_be_bytes(self.output_token);\n        fields[4] = Field::from_be_bytes(self.amount_in);\n        fields[5] = Field::from_be_bytes(self.amount_out);\n        fields[6] = Field::from_be_bytes(self.sender_nonce);\n        fields[7] = self.origin_domain as Field;\n        fields[8] = self.destination_domain as Field;\n        fields[9] = Field::from_be_bytes(self.destination_settler);\n        fields[10] = self.fill_deadline as Field;\n        fields[11] = self.order_type as Field;\n        fields[12] = Field::from_be_bytes(self.data);\n        poseidon2_hash(fields)\n    }\n}\n\nfn u8_order_data_length_to_u8_32(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> [u8; 32] {\n    let mut result = [0; 32];\n    for i in 0..32 {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\nfn u8_order_data_length_to_u8_4(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> [u8; 4] {\n    let mut result = [0; 4];\n    for i in 0..4 {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\nfn u8_order_data_length_to_u8(bytes: [u8; ORDER_DATA_LENGTH], start: u32) -> u8 {\n    bytes[start]\n}\n"
    },
    "66": {
      path: "/home/ubuntu/Dropbox/WEB/aztec/nft-portal-example/substance-aztec-evm-bridge/packages/aztec/aztec_gateway_7683/src/utils.nr",
      source: "use dep::aztec::protocol_types::{address::{AztecAddress, EthAddress}, traits::FromField};\n\npub(crate) fn u8_32_to_u128(input: [u8; 32]) -> u128 {\n    let mut result = 0u128;\n    for i in 0..16 {\n        result += (input[31 - i] as u128) << ((i * 8) as u128);\n    }\n    result\n}\n\npub(crate) fn u8_4_to_u32(bytes: [u8; 4]) -> u32 {\n    let field = Field::from_be_bytes(bytes);\n    field.assert_max_bit_size::<32>();\n    field as u32\n}\n\npub(crate) fn u8_32_to_aztec_address(bytes: [u8; 32]) -> AztecAddress {\n    let field = Field::from_be_bytes(bytes);\n    AztecAddress::from_field(field)\n}\n\npub(crate) fn u8_32_to_eth_address(bytes: [u8; 32]) -> EthAddress {\n    let field = Field::from_be_bytes(bytes);\n    EthAddress::from_field(field)\n}\n\npub(crate) fn u32_to_u8_4(x: u32) -> [u8; 4] {\n    [((x >> 24) & 0xFF) as u8, ((x >> 16) & 0xFF) as u8, ((x >> 8) & 0xFF) as u8, (x & 0xFF) as u8]\n}\n"
    },
    "75": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      source: 'use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE\'s non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract\'s capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), "Attempted to read past the length of a CapsuleArray");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, "Attempted to delete past the length of a CapsuleArray");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don\'t end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won\'t change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = "Attempted to read past the length of a CapsuleArray")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = "Attempted to read past the length of a CapsuleArray")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock("utilityCopyCapsule");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n'
    },
    "76": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/context/calls.nr",
      source: 'use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata_array};\nuse crate::oracle::execution_cache;\n\n// PrivateCall\n\n#[must_use = "Your private call needs to be passed into the `self.call(...)` method to be executed (e.g. `self.call(MyContract::at(address).my_private_function(...args))`"]\npub struct PrivateCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PrivateCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n}\n\nimpl<let M: u32, let N: u32, T> PrivateCall<M, N, T>\nwhere\n    T: Deserialize,\n{\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.call(MyContract::at(address).my_private_function(...args))`\n    /// instead of manually constructing and calling `PrivateCall`.\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\n// PrivateStaticCall\n\n#[must_use = "Your private static call needs to be passed into the `self.view(...)` method to be executed (e.g. `self.view(MyContract::at(address).my_private_static_function(...args))`"]\npub struct PrivateStaticCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PrivateStaticCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.view(MyContract::at(address).my_private_static_function(...args))`\n    /// instead of manually constructing and calling `PrivateCall`.\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\n// PublicCall\n\n#[must_use = "Your public call needs to be passed into the `self.call(...)`, `self.enqueue(...)` or `self.enqueue_incognito(...)` method to be executed (e.g. `self.call(MyContract::at(address).my_public_function(...args))`"]\npub struct PublicCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    pub args: [Field; N],\n    gas_opts: GasOpts,\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> PublicCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n        }\n    }\n\n    pub fn with_gas(mut self, gas_opts: GasOpts) -> Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.call(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub unconstrained fn call(self, context: PublicContext) -> T\n    where\n        T: Deserialize,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()\'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_incognito(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and calling `PublicCall`.\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.set_as_teardown(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and setting the teardown function `PublicCall`.\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.set_as_teardown_incognito(MyContract::at(address).my_public_function(...args))`\n    /// instead of manually constructing and setting the teardown function `PublicCall`.\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\n// PublicStaticCall\n\n#[must_use = "Your public static call needs to be passed into the `self.view(...)`, `self.enqueue_view(...)` or `self.enqueue_view_incognito(...)` method to be executed (e.g. `self.view(MyContract::at(address).my_public_static_function(...args))`"]\npub struct PublicStaticCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    pub args: [Field; N],\n    return_type: T,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, let N: u32, T> PublicStaticCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(mut self, gas_opts: GasOpts) -> Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.view(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub unconstrained fn view(self, context: PublicContext) -> T\n    where\n        T: Deserialize,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_view(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    /// **[DEPRECATED]**\n    /// This function is deprecated. Please use the new contract API:\n    /// `self.enqueue_view_incognito(MyContract::at(address).my_public_static_function(...args))`\n    /// instead of manually constructing and calling `PublicStaticCall`.\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = [self.selector.to_field()].concat(self.args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\n// UtilityCall\n\npub struct UtilityCall<let M: u32, let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<M>,\n    args_hash: Field,\n    pub args: [Field; N],\n    return_type: T,\n}\n\nimpl<let M: u32, let N: u32, T> UtilityCall<M, N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field; N],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n}\n'
    },
    "83": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/context/note_hash_read.nr",
      source: `use protocol_types::address::aztec_address::AztecAddress;

pub struct NoteHashRead {
    note_hash: Field,
    contract_address: Option<AztecAddress>,
}

impl NoteHashRead {
    pub fn new_transient(note_hash: Field, contract_address: AztecAddress) -> Self {
        assert(
            !contract_address.is_zero(),
            "Can't read a transient note with a zero contract address",
        );
        Self { note_hash, contract_address: Option::some(contract_address) }
    }

    pub fn new_settled(note_hash: Field) -> Self {
        Self { note_hash, contract_address: Option::none() }
    }

    pub fn note_hash(self) -> Field {
        self.note_hash
    }

    pub fn contract_address(self) -> Option<AztecAddress> {
        self.contract_address
    }
}
`
    },
    "84": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      source: 'use crate::{\n    context::{\n        inputs::PrivateContextInputs, note_hash_read::NoteHashRead, returns_hash::ReturnsHash,\n    },\n    hash::{hash_args, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            is_side_effect_counter_revertible_oracle_wrapper, notify_enqueued_public_function_call,\n            notify_set_min_revertible_side_effect_counter, notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::{Counted, scoped::Scoped},\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, find_first_index, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external("private")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external("private")] macro, so you\'ll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external("private")] function in your smart contract.\n///\n/// > For those used to "vanilla" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr\'s own functions, so typically a smart contract developer won\'t\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the "Anchor block" header.\n///     Recall, a private function cannot read from the "current" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user\'s device),\n///     the public state of the chain (the "current state") will have progressed\n///     forward. We call this reference the "Anchor block".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are "enqueued").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external("private")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external("private")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given "app-siloed" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a "key validation request" to the\n///     protocol\'s kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol\'s kernel circuits.\n///   A well-known misnomer:\n///   - "public inputs" contain both inputs and outputs of this function.\n///     - By "outputs" we mean a lot more side-effects than just the\n///       "return values" of the function.\n///   - Most of the so-called "public inputs" are kept _private_, and never leak\n///     to the outside world, because they are \'swallowed\' by the protocol\'s\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user\'s wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you\'ll see the\n/// arguably-ugly pervasiveness of the "context" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function\'s parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don\'t make sense if\n/// they\'re called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they\'re making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n\n    pub expected_non_revertible_side_effect_counter: u32,\n    pub expected_revertible_side_effect_counter: u32,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn\'t have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is "null" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user\'s\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user\'s account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// "Unsafe" versus calling `context.msg_sender()`, because it doesn\'t\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract\'s address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external("private")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol\'s kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn\'t need to call this. The #[external("private")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain\'s global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr\'s state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol\'s kernel circuits will take over and insert the\n    /// note_hash into the protocol\'s "note hash tree" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - "Silo" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain\'s global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr\'s state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of "tx unlinkability".\n    ///\n    /// Usually, a nullifier will be emitted to "spend" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol\'s kernel circuits will take over and insert the\n    /// nullifier into the protocol\'s "nullifier tree" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - "Silo" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr\'s state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it\'s nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn\'t mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate "tx unlinkability"); it simply informs the user\'s PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// "squashing" purposes: If a note is nullified during the same tx which\n    /// created it, we can "squash" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the "current" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user\'s device),\n    /// the public state of the chain (the "current state") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx\'s chosen anchor\n    ///   block header. This enables the network\'s nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user\'s\n    /// PXE. Depending on how much blockchain data the user\'s PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol\'s\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function\'s circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don\'t do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block\'s merkle membership proof is handled by Aztec\'s protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external("private")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol\'s kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external("private")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n            expected_non_revertible_side_effect_counter: self\n                .expected_non_revertible_side_effect_counter,\n            expected_revertible_side_effect_counter: self.expected_revertible_side_effect_counter,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don\'t need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            "Setting {0} as fee payer",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn in_revertible_phase(&mut self) -> bool {\n        let current_counter = self.side_effect_counter;\n\n        // Safety: Kernel will validate that the claim is correct by validating the expected counters.\n        let is_revertible =\n            unsafe { is_side_effect_counter_revertible_oracle_wrapper(current_counter) };\n\n        if is_revertible {\n            if (self.expected_revertible_side_effect_counter == 0)\n                | (current_counter < self.expected_revertible_side_effect_counter) {\n                self.expected_revertible_side_effect_counter = current_counter;\n            }\n        } else if current_counter > self.expected_non_revertible_side_effect_counter {\n            self.expected_non_revertible_side_effect_counter = current_counter;\n        }\n\n        is_revertible\n    }\n\n    /// Declares the end of the "setup phase" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The "setup" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec\'s state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext\'s _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // Incrementing the side effect counter when ending setup ensures non\n        // ambiguity for the counter where we change phases.\n        self.side_effect_counter += 1;\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     "Ending setup at counter {0}",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.next_counter();\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an "include-by timestamp") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions\'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the "Advanced" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block\'s timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardize on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact approach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol\'s kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// "Read requests" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr\'s state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash_read` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In "traditional" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn\'t yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol\'s\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For "settled notes" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For "pending notes" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash_read: NoteHashRead) {\n        let note_hash = note_hash_read.note_hash();\n        let contract_address = note_hash_read.contract_address().unwrap_or(AztecAddress::zero());\n        let side_effect = Scoped::new(\n            Counted::new(note_hash, self.next_counter()),\n            contract_address,\n        );\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Asserts that a NoteHashRead has been requested to the kernel by this context.\n    /// Asserts instead of returning a boolean to save on gates.\n    ///\n    /// # Arguments\n    /// * `note_hash_read` - The note hash read to assert that has been requested.\n    ///\n    pub fn assert_has_been_requested(self, note_hash_read: NoteHashRead) {\n        let note_hash = note_hash_read.note_hash();\n        let contract_address = note_hash_read.contract_address().unwrap_or(AztecAddress::zero());\n\n        // Safety: The index is constrained by the checks below.\n        let hinted_index = unsafe {\n            find_first_index(\n                self.note_hash_read_requests.storage(),\n                |r| (r.contract_address == contract_address) & (r.innermost() == note_hash),\n            )\n        };\n        // This assertion is not necessary, since the .get would fail. But it enables us to have a more explicit error message.\n        assert(\n            hinted_index != self.note_hash_read_requests.max_len(),\n            "Note hash read has not been requested",\n        );\n\n        let request = self.note_hash_read_requests.get(hinted_index);\n        assert_eq(request.contract_address, contract_address);\n        assert_eq(request.innermost(), note_hash);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr\'s state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    /// * `contract_address` - The contract address that emitted the nullifier\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the nullifier is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(\n        &mut self,\n        nullifier: Field,\n        contract_address: AztecAddress,\n    ) {\n        let request = Scoped::new(\n            Counted::new(nullifier, self.next_counter()),\n            contract_address,\n        );\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user\'s PXE.\n    ///\n    /// Advanced function: Only needed if you\'re designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an "app-siloed secret key", which is\n    /// constructed by hashing the user\'s master nullifier secret key with the\n    /// contract\'s address.\n    /// However, because contracts cannot be trusted with a user\'s master\n    /// nullifier secret key (because we don\'t know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user\'s PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the "outgoing" keypair is to provide a second secret\n    /// key for all of a user\'s outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user\'s outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the "incoming" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user\'s address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user\'s master secret keys,\n    /// because we do not trust them. They are instead given "app-siloed" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a "key\n    /// validation request" to the protocol\'s kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user\'s\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named "request_" instead of "get_" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn\'t get a match meaning the cached result is stale\n            // Typically we\'d validate keys by showing that they are the preimage of `pk_m_hash`, but that\'d require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, "Obtained invalid key validation request");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an "L2 -> L1 message" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called "Portal Contracts".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec "Outbox" contract on L1,\n    /// when this transaction\'s block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be "referred to"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec "Inbox" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the "commitment" corresponding to this can be "empty")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a "privacy\n    /// anti-pattern", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it\'s already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0\'s for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol\'s kernel circuits can then append random\n    ///   fields as "padding" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It\'s up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: "this log relates to this note".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won\'t be able to check that we didn\'t add extra padding (trailing zeroes) or that we cut trailing zeroes from the end.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function\'s return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This "composability" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user\'s transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract\'s private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction\'s context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity\'s `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function\'s return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don\'t\n    /// require any input parameters. It\'s equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function\'s return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function\'s return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function\'s return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user\'s device,\n    /// public function calls are "enqueued" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user\'s tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a "null" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity\'s `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a "null" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don\'t\n    /// take any input parameters. It\'s otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a "null" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a "null" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a "null" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The "setup" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a "null" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a "null" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a "side-effect counter",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec\'s kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we\'re in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn\'t know why, and given the order of proving, the\n    /// kernel hasn\'t _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren\'t exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn\'t know _when_ B.b() was called within A.a1(), because\n    /// it can\'t see what\'s going on within an app circuit. So the kernel\n    /// wouldn\'t know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters\' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a "good" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n}\n'
    },
    "85": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      source: 'use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external("public")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external("public")] macro, so you\'ll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external("public")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr\'s own functions, so typically a smart contract developer won\'t\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     "partial notes")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user\'s device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed "live" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the "AVM"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to "AVM\n/// bytecode" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can\'t compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external("public")]\n    /// macro, so you shouldn\'t need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as "read".\n    ///\n    /// Use this function if you only want the message to ever be "referred to"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec "Inbox" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn\'t exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            "L1-to-L2 message is already nullified",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            "Tried to consume nonexistent L1-to-L2 message",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an "L2 -> L1 message" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called "Portal Contracts".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec "Outbox" contract on L1,\n    /// when this transaction\'s block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity\'s `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain\'s global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search "Partial Note" for a very common pattern which enables a note\n    /// to be "partially" populated with some data in a _private_ function, and\n    /// then later "completed" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain\'s global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you\'re seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract\'s address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user\'s account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// "Unsafe" versus calling `context.msg_sender()`, because it doesn\'t\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external("public")] macro uses this internally.\n    /// Smart contract developers typically won\'t need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the "transaction fee" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer\'s\n    /// "fee-juice" balance (in the protocol\'s Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that\'s been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the "setup" and "app-logic" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the "teardown" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the "L2 gas\n    /// price"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user\'s wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favorite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the "DA gas\n    /// price").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\nunconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir\'s `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir\'s `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n'
    },
    "86": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      source: 'use crate::{hash::hash_args, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call\'s return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don\'t process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don\'t utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`\'s deserialization length).\n        // `hash_args` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args(preimage), "Preimage mismatch");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = "Preimage mismatch")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args(serialized);\n\n        let _ = OracleMock::mock("privateLoadFromExecutionCache").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with="Preimage mismatch")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args(serialized);\n\n    //     let _ = OracleMock::mock("privateLoadFromExecutionCache").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n'
    },
    "87": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      source: "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "88": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/contract_self.nr",
      source: "use crate::{\n    context::{\n        calls::{PrivateCall, PrivateStaticCall, PublicCall, PublicStaticCall},\n        private_context::PrivateContext,\n        public_context::PublicContext,\n        utility_context::UtilityContext,\n    },\n    event::{\n        event_emission::{emit_event_in_private, emit_event_in_public},\n        event_interface::EventInterface,\n        event_message::EventMessage,\n    },\n};\nuse protocol_types::{\n    address::AztecAddress,\n    constants::NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    traits::{Deserialize, Serialize},\n};\n\n/// `ContractSelf` is the core interface for interacting with an Aztec contract's own state and context.\n///\n/// This struct is automatically injected into every #[external(...)] contract function by the Aztec macro system and is\n/// accessible through the `self` variable.\n///\n/// # Usage in Contract Functions\n///\n/// Once injected, you can use `self` to:\n/// - Access storage: `self.storage.balances.at(owner).read()`\n/// - Call contracts: `self.call(Token::at(address).transfer(recipient, amount))`\n/// - Emit events: `self.emit(event).deliver_to(recipient, delivery_mode)` (private) or `self.emit(event)` (public)\n/// - Get the contract address: `self.address`\n/// - Get the caller: `self.msg_sender()`\n/// - Access low-level Aztec.nr APIs through the context: `self.context`\n///\n/// # Example\n///\n/// ```noir\n/// #[external(\"private\")]\n/// fn withdraw(amount: u128, recipient: AztecAddress) {\n///     // Get the caller of this function\n///     let sender = self.msg_sender().unwrap();\n///\n///     // Access storage\n///     let token = self.storage.donation_token.get_note().get_address();\n///\n///     // Call contracts\n///     self.call(Token::at(token).transfer(recipient, amount));\n/// }\n/// ```\n///\n/// # Type Parameters\n///\n/// - `Context`: The execution context type - either `&mut PrivateContext`, `PublicContext`, or `UtilityContext`\n/// - `Storage`: The contract's storage struct (defined with `#[storage]`), or `()` if the contract has no storage\n/// - `CallSelf`: Macro-generated type for calling contract's own non-view functions\n/// - `EnqueueSelf`: Macro-generated type for enqueuing calls to the contract's own non-view functions\n/// - `CallSelfStatic`: Macro-generated type for calling contract's own view functions\n/// - `EnqueueSelfStatic`: Macro-generated type for enqueuing calls to the contract's own view functions\npub struct ContractSelf<Context, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// The address of this contract\n    pub address: AztecAddress,\n    /// The contract's storage instance, representing the struct to which the `#[storage]` macro was applied in your\n    /// contract. If the contract has no storage, the type of this will be `()`.\n    ///\n    /// This storage instance is specialized for the current execution context (private, public, or utility) and\n    /// provides access to the contract's state variables. Each state variable accepts the context as a generic\n    /// parameter, which determines its available functionality. For example, a PublicImmutable variable can be read\n    /// from any context (public, private, or utility) but can only be written to from public contexts.\n    ///\n    /// # Developer Note\n    /// If you've arrived here while trying to access your contract's storage while the `Storage` generic type is set to\n    /// unit type `()`, it means you haven't yet defined a Storage struct using the #[storage] macro in your contract.\n    /// For guidance on setting this up, please refer to our docs:\n    /// https://docs.aztec.network/developers/docs/guides/smart_contracts/storage\n    pub storage: Storage,\n    /// The execution context whose type is determined by the #[external(...)] attribute of the contract function based\n    /// on the external function type (private, public, or utility).\n    pub context: Context,\n\n    /// Provides type-safe methods for calling this contract's own non-view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self.some_private_function(args)\n    /// ```\n    pub call_self: CallSelf,\n    /// Provides type-safe methods for enqueuing calls to this contract's own non-view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self.some_public_function(args)\n    /// ```\n    pub enqueue_self: EnqueueSelf,\n    /// Provides type-safe methods for calling this contract's own view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self_static.some_view_function(args)\n    /// ```\n    pub call_self_static: CallSelfStatic,\n    /// Provides type-safe methods for enqueuing calls to this contract's own view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self_static.some_public_view_function(args)\n    /// ```\n    pub enqueue_self_static: EnqueueSelfStatic,\n    /// Provides type-safe methods for calling internal functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.internal.some_internal_function(args)\n    /// ```\n    pub internal: CallInternal,\n}\n\n/// Implementation for `ContractSelf` in private execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"private\")]`.\n/// Private functions execute client-side and generate zero-knowledge proofs of their execution.\nimpl<Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> ContractSelf<&mut PrivateContext, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// Creates a new `ContractSelf` instance for a private function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_private(\n        context: &mut PrivateContext,\n        storage: Storage,\n        call_self: CallSelf,\n        enqueue_self: EnqueueSelf,\n        call_self_static: CallSelfStatic,\n        enqueue_self_static: EnqueueSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self,\n            call_self_static,\n            enqueue_self_static,\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call. This is similar to `msg.sender` in Solidity.\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA ( Externally-owned Account), the msg_sender is\n    /// \"null\" for the first function call of every transaction. The first function call of a tx is likely to be a call\n    /// to the user's account contract, so this quirk will most often be handled by account contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract). Returns `Option<AztecAddress>::none` for the first function call of the tx. No\n    ///   other _private_ function calls in the tx will have a `none` msg_sender, but _public_ function calls might (see\n    ///   the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event privately.\n    ///\n    /// Unlike public events, private events do not reveal their contents publicly. They instead create an\n    /// [EventMessage] containing the private event information, which **MUST** be delivered to a recipient via\n    /// [EventMessage::deliver_to] in order for them to learn about the event. Multiple recipients can have the same\n    /// message be delivered to them.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Transfer { from: AztecAddress, to: AztecAddress, amount: u128 }\n    ///\n    /// #[external(\"private\")]\n    /// fn transfer(to: AztecAddress, amount: u128) {\n    ///     let from = self.msg_sender().unwrap();\n    ///\n    ///     let message: EventMessage = self.emit(Transfer { from, to, amount });\n    ///     message.deliver_to(from, MessageDelivery.UNCONSTRAINED_OFFCHAIN);\n    ///     message.deliver_to(to, MessageDelivery.CONSTRAINED_ONCHAIN);\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Private event emission always results in the creation of a nullifer, which acts as a commitment to the event and\n    /// is used by third parties to verify its authenticity. See [EventMessage::deliver_to] for the costs associated to\n    /// delivery.\n    ///\n    /// # Privacy\n    ///\n    /// The nullifier created when emitting a private event leaks nothing about the content of the event - it's a\n    /// commitment that includes a random value, so even with full knowledge of the event preimage determining if an\n    /// event was emitted or not requires brute-forcing the entire `Field` space.\n    pub fn emit<Event>(&mut self, event: Event) -> EventMessage<Event>\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_private(self.context, event)\n    }\n\n    /// Makes a call to the private function defined by the `call` parameter.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_private(recipient, amount));\n    /// ```\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call<let M: u32, let N: u32, T>(&mut self, call: PrivateCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes a read-only call to the private function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_private(recipient));\n    /// ```\n    pub fn view<let M: u32, let N: u32, T>(&mut self, call: PrivateStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `call` - The interface representing the public function to enqueue.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view<let M: u32, let N: u32, T>(&mut self, call: PublicStaticCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_incognito(Token::at(address).increase_total_supply_by(amount));\n    /// ```\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_incognito<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_incognito(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view_incognito(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicStaticCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view_incognito(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to designate as teardown.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown_incognito(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in public execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"public\")]`.\n/// Public functions are executed by the sequencer in the Aztec Virtual Machine (AVM) and can work only with public\n/// state.\nimpl<Storage, CallSelf, CallSelfStatic, CallInternal> ContractSelf<PublicContext, Storage, CallSelf, (), CallSelfStatic, (), CallInternal> {\n    /// Creates a new `ContractSelf` instance for a public function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_public(\n        context: PublicContext,\n        storage: Storage,\n        call_self: CallSelf,\n        call_self_static: CallSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self: (),\n            call_self_static,\n            enqueue_self_static: (),\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then it had the option of hiding its address\n    /// when enqueuing this public function call. In such cases, this `context.msg_sender()` method will return\n    /// `Option<AztecAddress>::none`. If the calling function is a _public_ function, it will always return an\n    /// `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original transaction sender\n    ///\n    pub fn msg_sender(self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event publicly.\n    ///\n    /// Public events are emitted as plaintext and are therefore visible to everyone. This is is the same as Solidity\n    /// events on EVM chains.\n    ///\n    /// Unlike private events, they don't require delivery of an event message.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Update { value: Field }\n    ///\n    /// #[external(\"public\")]\n    /// fn publish_update(value: Field) {\n    ///     self.emit(Update { value });\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Public event emission is achieved by emitting public transaction logs. A total of `N+1` fields are emitted,\n    /// where `N` is the serialization length of the event.\n    pub fn emit<Event>(&mut self, event: Event)\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_public(self.context, event);\n    }\n\n    /// Makes the call to the public function defined by the `call` parameter.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_public(recipient, amount));\n    /// ```\n    ///\n    pub unconstrained fn call<let M: u32, let N: u32, T>(self, call: PublicCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes the read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be static calls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_public(recipient));\n    /// ```\n    ///\n    pub unconstrained fn view<let M: u32, let N: u32, T>(self, call: PublicStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in utility execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"utility\")]`.\n/// Utility functions are unconstrained functions that can read private state for offchain queries.\n/// They are typically used for view functions that need to access private notes (e.g. a Token's balance_of function).\nimpl<Storage> ContractSelf<UtilityContext, Storage, (), (), (), (), ()> {\n    /// Creates a new `ContractSelf` instance for a utility function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_utility(context: UtilityContext, storage: Storage) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self: (),\n            enqueue_self: (),\n            call_self_static: (),\n            enqueue_self_static: (),\n            internal: (),\n        }\n    }\n}\n"
    },
    "92": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      source: "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "94": {
      path: "/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.20251212/noir-projects/aztec-nr/aztec/src/hash.nr",
      source: "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    }
  },
  functions: [
    {
      abi: {
        error_types: {
          "10452171673112122008": {
            error_kind: "string",
            string: "Function _assert_nonce_and_set_order_status_private can only be called by the same contract"
          },
          "10886555653199409003": {
            error_kind: "string",
            string: "Invalid nonce"
          },
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          }
        },
        parameters: [
          {
            name: "order_id",
            type: {
              kind: "field"
            },
            visibility: "private"
          },
          {
            name: "nonce",
            type: {
              kind: "field"
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public",
        "abi_only_self"
      ],
      debug_symbols: "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",
      is_unconstrained: true,
      name: "_assert_nonce_and_set_order_status_private"
    },
    {
      abi: {
        error_types: {
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "2265285467782432990": {
            error_kind: "string",
            string: "Function _assert_order_status_private can only be called by the same contract"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          },
          "7335179940076463214": {
            error_kind: "string",
            string: "Invalid status"
          }
        },
        parameters: [
          {
            name: "order_id",
            type: {
              kind: "field"
            },
            visibility: "private"
          },
          {
            name: "status",
            type: {
              kind: "field"
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public",
        "abi_only_self"
      ],
      debug_symbols: "tZndbts8DIbvJcc5kCiSknorwzBkXTYECNIiaz/gw9B7H+mQdNLBQud2J81junrDP/3Y+bX5tv/6/OPL4fT94efm7tOvzdfz4Xg8/PhyfLjfPR0eTmL9tUn6J+e6uSvbTQbY3FX9lOucBYoYMiqoRW8hCTQBSg7NgMvmDkBBLKCjanGodquBg1pYoIODWSCRQU4OKFAVuoF6OIF6WFChGmB2YANyC7mF3cLk0A0qOjSDVhz0K2i7KakZZHDwW+AWcEtxS2EDTA7k0A0IHfwrNKsXUEGpUqnZgQ1ackCHbtCLgw3HBA5uydmBDMAEEfV/JM845XACNmC3sFuqWyo5dIPJsQmaweTYBPoV0j+UsgM5dANNJiYBzRhmhW5AxaEaqGMXYIMq4WBRQIdu0NzS3NLd0s3CySysDYmogA7dANwCzaAUB3VMKsjamRcgh26g5UZpdWZwYIPJ+apABtqQF2gXqMkSXtXDC6CDlaCCW8BKUEtxsBJUzA7kYCWobCWozUpQm5Wg9uJgJWgpO1gJWrYStIwOlt4GbgG3FLcUt6BbyErQCB2sBI3dwlaCVouDlaC17EAOVoLWdVTfbrpOEEoK1UDnxQQ6LybQ1JGsY13nBRUFcugGOnMvUA0qOEhaSL6068y9ABl0t3Sz5JRSUNhy2LJq6WKdJu8uhEHNSdch4omqk9ab2kTsRGGbIplIU8u6QyTtRsaJyEn70ahf0pJTL0HVKGtXGOlY9T6DJUmoOZWwqaesnmaEoLCpp1wnYh/BKYicath0/ht1pxa2Fh50CHJlSCnIx4J6r5Mig69QElAOoiAZwZpJ8FUqwzTTLxQ2XUG5T8ROLWzaI3XS0ya5jJhWqwvZdMwlYVBzyiUobABB7FRSUKhgjCWPsnAOoqDupBNvirf07GO7fwf66iBEFhtqPxvNtm7xIrgvCO49lhIUNoQgzylS2Cg84BQUyhwq02qRX162Gz8rfXk67/d6VLo6PMmR6nF33p+eNnen5+Nxu/lvd3ye/unn4+40fT7tznJXItifvsmnCH4/HPdKL9t5dFoeCrKR22jA1ENAKnsjkZclsqzBzTSEaw2RRjcasKxRgHStmTSEa17SGIXSsrsBHfJiKDiQkN5IkQ6Z1rMb7UaDPiAd/G/TgaAr1ySBMq0W09EGoUBhj0SOtrMElBuJ/gHZyOkD0jGKRRYo96OUshhLho8IpvzjYKBCFKYvFyYP+rS2iKV2wMVQRm1aGF1DuL83FNFYDGXYHlgjoQzLa9igT4Ewe68LIy/NfBg4Ik+Yc3/0WnlxJcyjaBhgDqcsN9k4HM4RDuWyGM6oU9H7FOUIEQq0qi51eUGGUZeyz9rrdCKs8qEt72+jfUVaNDYWGXeViVs3YNDmBNnrQfJyICQg1VuN0VpK0aFp7nJ5Nr9RKINQ6tyftWWaNV5FUkb9SRBdMadCGvVWAUYJ7dGbcHXm+EOjjPLpxxYqaZ1C98bgq0z8VRwwn53KVUX+0OBRTcEPHJmwrtTgHhqtr9MoKTRkoixrDPqzondGRV6l0GPF6bTOB3keje0k8XJdcVBXbDkWvkZX+0n/i3TqWwFLJ60sa4kOFWyrND4ilFyiQzO2dTOlzptrHcxXbP9WIzNHLFzbOo1a4yApB6dFDcrvnSkjhbfNlJHCW2cK4bvba5jOPi88HZbTOdxcM1NsrhUWN1eqw9aIsnK7aq9Xsbz9oHD1CPpqe6XRyQ1g3hyvm+OVHzw69MjLMV9+hIkWH0FH+7y844vDvbzlW36OHT3XE8+eyOvyuua5/jatV89ur9M6mi/J19IOK2cc+3Tpld47ZwcKw/3xTVEMFd4UxRv36NcKn+Vyd3843/wC+KJS58Pu63Fvl9+fT/dXd5/+f/Q7/gvi4/nhfv/t+bxXpflnRPnzqcguUAp91he/eplwKy2ul1kvi95tn1/Umd8=",
      is_unconstrained: true,
      name: "_assert_order_status_private"
    },
    {
      abi: {
        error_types: {
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14731960565267904813": {
            error_kind: "string",
            string: "Invalid order"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "3396427393764509880": {
            error_kind: "string",
            string: "Function _check_if_order_is_claimable_private can only be called by the same contract"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          }
        },
        parameters: [
          {
            name: "order_id",
            type: {
              kind: "field"
            },
            visibility: "private"
          },
          {
            name: "claimable_order_commitment",
            type: {
              kind: "field"
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public",
        "abi_only_self"
      ],
      debug_symbols: "tZndbts8DIbvJcc5kCiSknorwzBkXTYECNIiaz/gw9B7H+mQdNLBQud2J81junrDP/3Y+bX5tv/6/OPL4fT94efm7tOvzdfz4Xg8/PhyfLjfPR0eTmL9tUn6J+e6uSvbTQbY3FX9lOucBYoYMiqoRW8hCTQBSg7NgMvmDkBBLKCjanGodquBg1pYoIODWSCRQU4OKFAVuoF6OIF6WFChGmB2YANyC7mF3cLk0A0qOjSDVhz0K2i7KakZZHDwW+AWcEtxS2EDTA7k0A0IHfwrNKsXUEGpUqnZgQ1ackCHbtCLgw3HBA5uydmBDMAEEfV/JM845XACNmC3sFuqWyo5dIPJsQmaweTYBPoV0j+UsgM5dANNJiYBzRhmhW5AxaEaqGMXYIMq4WBRQIdu0NzS3NLd0s3CySysDYmogA7dANwCzaAUB3VMKsjamRcgh26g5UZpdWZwYIPJ+apABtqQF2gXqMkSXtXDC6CDlaCCW8BKUEtxsBJUzA7kYCWobCWozUpQm5Wg9uJgJWgpO1gJWrYStIwOlt4GbgG3FLcUt6BbyErQCB2sBI3dwlaCVouDlaC17EAOVoLWdVTfbrpOEEoK1UDnxQQ6LybQ1JGsY13nBRUFcugGOnMvUA0qOEhaSL6068y9ABl0t3Sz5JRSUNhy2LJq6WKdJu8uhEHNSdch4omqk9ab2kTsRGGbIplIU8u6QyTtRsaJyEn70ahf0pJTL0HVKGtXGOlY9T6DJUmoOZWwqaesnmaEoLCpp1wnYh/BKYicath0/ht1pxa2Fh50CHJlSCnIx4J6r5Mig69QElAOoiAZwZpJ8FUqwzTTLxQ2XUG5T8ROLWzaI3XS0ya5jJhWqwvZdMwlYVBzyiUobABB7FRSUKhgjCWPsnAOoqDupBNvirf07GO7fwf66iBEFhtqPxvNtm7xIrgvCO49lhIUNoQgzylS2Cg84BQUyhwq02qRX162Gz8rfXk67/d6VLo6PMmR6nF33p+eNnen5+Nxu/lvd3ye/unn4+40fT7tznJXItifvsmnCH4/HPdKL9t5dFoeCrKR22jA1ENAKnsjkZclsqzBzTSEaw2RRjcasKxRgHStmTSEa17SGIXSsrsBHfJiKDiQkN5IkQ6Z1rMb7UaDPiAd/G/TgaAr1ySBMq0W09EGoUBhj0SOtrMElBuJ/gHZyOkD0jGKRRYo96OUshhLho8IpvzjYKBCFKYvFyYP+rS2iKV2wMVQRm1aGF1DuL83FNFYDGXYHlgjoQzLa9igT4Ewe68LIy/NfBg4Ik+Yc3/0WnlxJcyjaBhgDqcsN9k4HM4RDuWyGM6oU9H7FOUIEQq0qi51eUGGUZeyz9rrdCKs8qEt72+jfSVTiU1BDoJzg9GtGzBoc4Ls9SB5ORASkOqtxmgtpejQNDshz+Y3CmUQSp37s7ZMs8arSMqoPwmiK+aKSKPeKsAooT16E67OHH9olFE+/dgixVmn0L0x+CoTfxUHzGenclWRPzR4VFPw3sqEdaUG99BofZ1GSaEhE2VZY9CfFb0zKvIqhR4rTqd1PsjzaGwniZfrioO6Ysux8DW62k/6X6RT3wpYOmllWUt0qGBbpfERoeRY/eTRuK2bKXXeXOtgvmL7txqZOWLh2tZp1BoHSTk4LWpQfu9MGSm8baaMFN46Uwjf3V7DdPZ54emwnM7h5pqZYnOtsLi5Uh22RpSV21V7vYrl7QeFq8eDV9srjU5uAPPmeN0cr/zg0aFHXo758iNMtPgIOtrn5R1fHO7lLd/yc+zouZ549kRel9c1z/U3aeWrA8PrtI7mS/K1tMPKGcc+XXql987ZgcJwf3xTFEOFN0Xxxj36tcJnudzdH843vwC+qNT5sPt63Nvl9+fT/dXdp/8f/Y7/gvh4frjff3s+71Vp/hlR/nwqsguUQp/1xa9eJtxKi+tl1suid9vnF3XmNw==",
      is_unconstrained: true,
      name: "_check_if_order_is_claimable_private"
    },
    {
      abi: {
        error_types: {
          "12142166718796425542": {
            error_kind: "string",
            string: "Order not opened"
          },
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          },
          "6710068896262816422": {
            error_kind: "string",
            string: "Function _check_refund_private can only be called by the same contract"
          }
        },
        parameters: [
          {
            name: "order_id",
            type: {
              kind: "field"
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public",
        "abi_only_self"
      ],
      debug_symbols: "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",
      is_unconstrained: true,
      name: "_check_refund_private"
    },
    {
      abi: {
        error_types: {
          "14332229579798040722": {
            error_kind: "string",
            string: "Function _emit_open_private can only be called by the same contract"
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          }
        },
        parameters: [
          {
            name: "order_id_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "resolved_order_bytes",
            type: {
              kind: "array",
              length: 613,
              type: {
                kind: "field"
              }
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public",
        "abi_only_self"
      ],
      debug_symbols: "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",
      is_unconstrained: true,
      name: "_emit_open_private"
    },
    {
      abi: {
        error_types: {
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          },
          "5182439867169668514": {
            error_kind: "string",
            string: "Function _emit_settled_private can only be called by the same contract"
          }
        },
        parameters: [
          {
            name: "order_id_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "receiver",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public",
        "abi_only_self"
      ],
      debug_symbols: "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",
      is_unconstrained: true,
      name: "_emit_settled_private"
    },
    {
      abi: {
        error_types: {
          "10117862570525238354": {
            error_kind: "string",
            string: "Function _fill_private can only be called by the same contract"
          },
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "2417591072343638585": {
            error_kind: "string",
            string: "Order is expired"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          },
          "7335179940076463214": {
            error_kind: "string",
            string: "Invalid status"
          }
        },
        parameters: [
          {
            name: "order_id",
            type: {
              kind: "field"
            },
            visibility: "private"
          },
          {
            name: "order_id_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "origin_data_bytes",
            type: {
              kind: "array",
              length: 301,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "filler_data_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "fill_deadline",
            type: {
              kind: "integer",
              sign: "unsigned",
              width: 32
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public",
        "abi_only_self"
      ],
      debug_symbols: "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",
      is_unconstrained: true,
      name: "_fill_private"
    },
    {
      abi: {
        error_types: {
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1511320103103073895": {
            error_kind: "string",
            string: "Function _trigger_settlement can only be called by the same contract"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          },
          "8228371833434187583": {
            error_kind: "string",
            string: "Trying to read from uninitialized PublicImmutable"
          }
        },
        parameters: [
          {
            name: "order_id",
            type: {
              kind: "field"
            },
            visibility: "private"
          },
          {
            name: "content_hash",
            type: {
              kind: "field"
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public",
        "abi_only_self"
      ],
      debug_symbols: "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",
      is_unconstrained: true,
      name: "_trigger_settlement"
    },
    {
      abi: {
        error_types: {
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          },
          "7826545090857484415": {
            error_kind: "string",
            string: "Function _update_order_status_private can only be called by the same contract"
          }
        },
        parameters: [
          {
            name: "order_id",
            type: {
              kind: "field"
            },
            visibility: "private"
          },
          {
            name: "status",
            type: {
              kind: "field"
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public",
        "abi_only_self"
      ],
      debug_symbols: "tZlbbhs7DIb34uc8SCIpStlKURRp6hYGDCdwkwMcFNl7SZnk2ClGSJ30Jf6GE/3Dmy5j/9p82359/vFld/j+8HNz++nX5utxt9/vfnzZP9zfPe0eDmL9tUn6J2fe3MLNJpeyuWX9lOucBUAMGRXUoreQBJoAJYdmUGFzW4qCWIqOYnBgu9WKg1qqQC8OZimJDHJyQAFW6Abq4QD1EFCBDTA7VANyC7mluqWSQzdgdGgGDRz0EXSzgdQMcnHwW8UtxS3gFqgGmBzIoRsQOvgjNKsnUEGpEnB2qAYtOaBDN+jgYMMxFQe35OxABsUEEfV/JM84cjigGlS3VLewW5gcusFwbEAzGI4N0EdI/1DKDuTQDTSZmAQ0Y5gVugGBAxuoYyeoBizhICigQzdobmlu6W7pZqnJLFUbElEBHbpBcUtpBgAO6phUsGpnnoAcuoGWG6XVay0O1WA4zwpkoA15gnYCTpZwVg9PgA5WAi5uKVYCBnCwEjBmB3KwEnC1EnCzEnCzEnAHBytBS9nBStCylaBldLD0tuKW4hZwC7gF3UJWgkboYCVo1S3VStAYHKwErWUHcrAStK6j+s2m6wShpMAGOi8G6LwYoKkjWce6zgsCBXLoBjpzT8AGXBwkLSQP7TpzT0AG3S3dLDmlFBS2HLasWrpYp+HdiTCoOek6RHUQO2m9qQ2qThS2EckgTW3VHSLpHNfAhSioOzUIkmdUXfpzssTkPHw+0WKTsVXjyOqzUdg0zbUOaj4CSxA7Udh0eTpRzUFh4/BAVwKjUG6h0n3s2Iy07YW6U4Ygdioyoo69E2xaSEAYFDZdrmob1Jxq2LRTah87cPERXJ1aDgqbtouRzcsMKQVhUHPKJchVoMRY8CgBIcijBO0NI7J4gcHHcjyjhW30gcYGutEbuQ11nRjxoi8UGXMKcq/GfmSEQZ5ThLCBe4BYgkKZQmWsGfnl5Wbjp6EvT8ftVg9DZ8cjOTQ93h23h6fN7eF5v7/Z/He3fx7/9PPx7jA+n+6Oclcysj18k08R/L7bb5VebpbRaX1oka3aRhdMPQSkYhcSeV0iyyrbTEOYOUQaXWiUdQ3pAF1NhoYw5zWNWSgtuxull7waCk4kpOYp0iHTdXGjXWjQB6Sj/tt0YNH5MSQQiFfT0SahFKgeiRxeF4kCFxL9A7KR0wekYxYLZHA/AGA1llw+Ihj4x8HI+hyF6euFyZM+5RaxcC+4GsqsTaGiawj394YiGquhTNsDORJay/oaNunTQpi914Wxrs38MnFE3iGX/ujMdXUlzLNoailLOLDeZPNwao5wKMNqOLNORe9TlKNBKNBVdeH1BbnMurT6rD1PJ5arfGjr+9t8i2TXkNNVoiUTl26USZtTyV4Pktf/kCiJLzVmaylFh6aly+Xt+0IBJqHw0p/c8hIIvIoEZv1JJbpiqYg06qXCZBmVr1GiN8vZmeMPDZjl048tBOk6he5FrWeZ+Ks4ynJ2grOK/KFRZzUtfuDIhHylRu2h0fp1GpBCQybKusakPxm9MxjrVQo9VpxO1/kgb5yxnaS6Xlec1BVbjoWv0dl+0v8infreb+mkK8sK0aGC7SqNjwglQ3RoxnbdTOFlc+XJfMX2bzXkVTxiqdyu02COg6QcnFY1KL93pswU3jZTZgpvnSmE726vaTr7svD0sp7O6eaaK8XmymV1cyWetkaUtbaz9noVy9sPCmevoK+2V5qd3OTrTNeQ7yhX/ajTQw/E9ihMq+fyOtvn5fXXJ5wwrb/Hzt7r5StvD0e4rb5mTHs9eVZ7uXK2VG/1zvTe+TZRmO5tb4piqvCmKN64v75W+CyXd/e748Xvcy8qddzdfd1v7fL78+H+7O7T/49+x3/fezw+3G+/PR+3qrT8yCd/PukruPwe9Vm/oNXLlG8gVb3Megl6lz6/qDO/AQ==",
      is_unconstrained: true,
      name: "_update_order_status_private"
    },
    {
      abi: {
        error_types: {
          "10522114655416116165": {
            error_kind: "string",
            string: "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            error_kind: "string",
            string: "extend_from_bounded_vec out of bounds"
          },
          "11019205087382408538": {
            error_kind: "string",
            string: "Field failed to decompose into specified 4 limbs"
          },
          "11021520179822076911": {
            error_kind: "string",
            string: "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            error_kind: "string",
            string: "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            error_kind: "string",
            string: "push out of bounds"
          },
          "13060541637244024094": {
            error_kind: "fmtstring",
            item_types: [],
            length: 98
          },
          "13450089406971132036": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 144
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15149532737237392223": {
            error_kind: "string",
            string: "Invalid secret"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "16464709583191233416": {
            error_kind: "string",
            string: "Invalid id"
          },
          "16792019527863081935": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 77
          },
          "17154023812102399658": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 128
          },
          "17803644318014042523": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              }
            ],
            length: 58
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 132
          },
          "344423948968719440": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              },
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              },
              {
                kind: "field"
              }
            ],
            length: 98
          },
          "361444214588792908": {
            error_kind: "string",
            string: "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            error_kind: "string",
            string: "Value does not fit in field"
          },
          "4440399188109668273": {
            error_kind: "string",
            string: "Input length must be a multiple of 32"
          },
          "7555607922535724711": {
            error_kind: "string",
            string: "Preimage mismatch"
          },
          "7564993426627941149": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              },
              {
                kind: "field"
              }
            ],
            length: 48
          },
          "7995966536718645961": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              },
              {
                kind: "field"
              }
            ],
            length: 61
          },
          "8171600539936659379": {
            error_kind: "fmtstring",
            item_types: [],
            length: 92
          },
          "8556029555939094797": {
            error_kind: "fmtstring",
            item_types: [],
            length: 75
          },
          "8992688621799713766": {
            error_kind: "string",
            string: "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            error_kind: "string",
            string: "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            error_kind: "string",
            string: "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            error_kind: "string",
            string: "Attempted to read past end of BoundedVec"
          }
        },
        parameters: [
          {
            name: "inputs",
            type: {
              fields: [
                {
                  name: "call_context",
                  type: {
                    fields: [
                      {
                        name: "msg_sender",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        name: "contract_address",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        name: "function_selector",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        name: "is_static_call",
                        type: {
                          kind: "boolean"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  name: "anchor_block_header",
                  type: {
                    fields: [
                      {
                        name: "last_archive",
                        type: {
                          fields: [
                            {
                              name: "root",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "next_available_leaf_index",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        name: "state",
                        type: {
                          fields: [
                            {
                              name: "l1_to_l2_message_tree",
                              type: {
                                fields: [
                                  {
                                    name: "root",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "next_available_leaf_index",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              name: "partial",
                              type: {
                                fields: [
                                  {
                                    name: "note_hash_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    name: "nullifier_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    name: "public_data_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        name: "sponge_blob_hash",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "global_variables",
                        type: {
                          fields: [
                            {
                              name: "chain_id",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "version",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "block_number",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            },
                            {
                              name: "slot_number",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "timestamp",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 64
                              }
                            },
                            {
                              name: "coinbase",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              name: "fee_recipient",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              name: "gas_fees",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        name: "total_fees",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "total_mana_used",
                        type: {
                          kind: "field"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  name: "tx_context",
                  type: {
                    fields: [
                      {
                        name: "chain_id",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "version",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "gas_settings",
                        type: {
                          fields: [
                            {
                              name: "gas_limits",
                              type: {
                                fields: [
                                  {
                                    name: "da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  },
                                  {
                                    name: "l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              name: "teardown_gas_limits",
                              type: {
                                fields: [
                                  {
                                    name: "da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  },
                                  {
                                    name: "l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              name: "max_fees_per_gas",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              name: "max_priority_fees_per_gas",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  name: "start_side_effect_counter",
                  type: {
                    kind: "integer",
                    sign: "unsigned",
                    width: 32
                  }
                }
              ],
              kind: "struct",
              path: "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            visibility: "private"
          },
          {
            name: "secret",
            type: {
              kind: "field"
            },
            visibility: "private"
          },
          {
            name: "order_id_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "origin_data_bytes",
            type: {
              kind: "array",
              length: 301,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "filler_data_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          }
        ],
        return_type: {
          abi_type: {
            fields: [
              {
                name: "call_context",
                type: {
                  fields: [
                    {
                      name: "msg_sender",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "contract_address",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "function_selector",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 32
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      name: "is_static_call",
                      type: {
                        kind: "boolean"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                name: "args_hash",
                type: {
                  kind: "field"
                }
              },
              {
                name: "returns_hash",
                type: {
                  kind: "field"
                }
              },
              {
                name: "min_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "is_fee_payer",
                type: {
                  kind: "boolean"
                }
              },
              {
                name: "include_by_timestamp",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 64
                }
              },
              {
                name: "note_hash_read_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              name: "contract_address",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "nullifier_read_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              name: "contract_address",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "key_validation_requests_and_generators",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "request",
                              type: {
                                fields: [
                                  {
                                    name: "pk_m",
                                    type: {
                                      fields: [
                                        {
                                          name: "x",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "y",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "is_infinite",
                                          type: {
                                            kind: "boolean"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    name: "sk_app",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              name: "sk_app_generator",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "note_hashes",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "nullifiers",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "value",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "note_hash",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "private_call_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 8,
                        type: {
                          fields: [
                            {
                              name: "call_context",
                              type: {
                                fields: [
                                  {
                                    name: "msg_sender",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "contract_address",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "function_selector",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "integer",
                                            sign: "unsigned",
                                            width: 32
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    name: "is_static_call",
                                    type: {
                                      kind: "boolean"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              name: "args_hash",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "returns_hash",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "start_side_effect_counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            },
                            {
                              name: "end_side_effect_counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "public_call_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 32,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "msg_sender",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "contract_address",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "is_static_call",
                                    type: {
                                      kind: "boolean"
                                    }
                                  },
                                  {
                                    name: "calldata_hash",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "public_teardown_call_request",
                type: {
                  fields: [
                    {
                      name: "msg_sender",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "contract_address",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "is_static_call",
                      type: {
                        kind: "boolean"
                      }
                    },
                    {
                      name: "calldata_hash",
                      type: {
                        kind: "field"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                name: "l2_to_l1_msgs",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 8,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "recipient",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    name: "content",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "private_logs",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "log",
                                    type: {
                                      fields: [
                                        {
                                          name: "fields",
                                          type: {
                                            kind: "array",
                                            length: 18,
                                            type: {
                                              kind: "field"
                                            }
                                          }
                                        },
                                        {
                                          name: "length",
                                          type: {
                                            kind: "integer",
                                            sign: "unsigned",
                                            width: 32
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    name: "note_hash_counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "contract_class_logs_hashes",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 1,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "value",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "length",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "start_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "end_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "expected_non_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "expected_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "anchor_block_header",
                type: {
                  fields: [
                    {
                      name: "last_archive",
                      type: {
                        fields: [
                          {
                            name: "root",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "next_available_leaf_index",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      name: "state",
                      type: {
                        fields: [
                          {
                            name: "l1_to_l2_message_tree",
                            type: {
                              fields: [
                                {
                                  name: "root",
                                  type: {
                                    kind: "field"
                                  }
                                },
                                {
                                  name: "next_available_leaf_index",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            name: "partial",
                            type: {
                              fields: [
                                {
                                  name: "note_hash_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  name: "nullifier_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  name: "public_data_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      name: "sponge_blob_hash",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "global_variables",
                      type: {
                        fields: [
                          {
                            name: "chain_id",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "version",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "block_number",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 32
                            }
                          },
                          {
                            name: "slot_number",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "timestamp",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 64
                            }
                          },
                          {
                            name: "coinbase",
                            type: {
                              fields: [
                                {
                                  name: "inner",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            name: "fee_recipient",
                            type: {
                              fields: [
                                {
                                  name: "inner",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            name: "gas_fees",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      name: "total_fees",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "total_mana_used",
                      type: {
                        kind: "field"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                name: "tx_context",
                type: {
                  fields: [
                    {
                      name: "chain_id",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "version",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "gas_settings",
                      type: {
                        fields: [
                          {
                            name: "gas_limits",
                            type: {
                              fields: [
                                {
                                  name: "da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                },
                                {
                                  name: "l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            name: "teardown_gas_limits",
                            type: {
                              fields: [
                                {
                                  name: "da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                },
                                {
                                  name: "l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            name: "max_fees_per_gas",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            name: "max_priority_fees_per_gas",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            kind: "struct",
            path: "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          visibility: "databus"
        }
      },
      bytecode: "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",
      custom_attributes: [
        "abi_private"
      ],
      debug_symbols: "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24LbgtuC24bbhtuG24bbhtuG24bbhtuG24bbgduB24HbgduB24EbakmglgRqSaCWBGpJoJYEakmglgRqSaCWBGpJoJYEakmglgRqSaCWBGpJoJYEakmglgRqSaCWBGpJoJYEakmglgRqSaCWBGpJoJYEakmglgRqSaCWBGpJoJYEakmglgRqSaCWBGpJoJYEakmglgRqSaCWBGpJoJYEakmglgRqSaCWBGpJoJZc1JKLWnJRSy5qyUUtuaglF7XkopZc1JKLWnJRSy5qyUUtuaglF7XkopZc1JKLWnJRSy5qyUUtuaglF7XkopZc1JJbteQkGtCBAbyDVUsKBbiAG3iAcNtw23DbcNtwO3A7cDtwO3A7cDtwO3A7cDtwO3BTuCncFG4KN4Wbwk3hpnBTuCncDG4GN4Obwc3gZnAzuBncDG4GN4ebw83h5nBzuDncHG4ON4ebwy3gFnALuAXcAm4Bt6ollujAAKbbd7V9q5YUCnABN/AAFWhABwaw3fbv9wMKcAE38AAVaEAHBhBuAjeBm8BN4CZwE7gJ3ARuAjeB24LbgtuC24LbgtuC24LbgtuC24LbhtuG24bbhtuG24bbhtuG24bbhtuB24HbgduB24HbgduB24HbgduBm8JN4aZwU7gp3BRuCjeFm8JN4WZwM7gZ3AxuBjeDm8HN4GZwM7g53BxuDjeHm8PN4eZwc7g53BxuAbeAW8At4BZwC7gF3AJuAbeA24XbhduF24XbhduF24XbhduFG2qJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqiaCWCGqJoJYIaomglghqyUItWaglC7VkoZYs1JKFWrJQSxZqyUItWaglC7VkoZYs1JKFWrJQSxZqyUItWaglC7VkoZYs1JKFWrJQSxZqyUItWaglC7VkoZYs1JKF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vSotjZWkPJJZk0WTVZOkSdakaLJpsq9kPzSpuXXNrWtuXXPrmlvX3Lrm1jW3vnKrx6HJpMmsyaLJqknSJGtSNNk0qbklzS1pbklzS5pb0tyS5pY0t6S5Jc0taW5Zc8uaW9bcsuaWNbesuWXNLWtuWXPLmlvR3IrmVjS3orkVza1obkVzK5pb0dyK5lY1t6q5Vc2tam5Vc6uaW9XcquZWNbequZHmRpobaW6kuZHmRpobaW6kuZHmRpoba26subHmxpoba26subHmxpoba26suYnmJpqbaG6iuYnmJpqbaG6iuYnmJppb09xUS6pqSVUtqaolVbWkqpZU1ZKqWlJVS6pqSVUtqaolVbWkqpZU1ZKqWlJVS6pqSVUtIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLSHVElItIdUSUi0h1RJSLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi1h1RJWLWHVElYtYdUSVi0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtEdUSUS0R1RJRLRHVElEtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZKmWtJUS5pqSVMtaaolTbWkqZY01ZI2teRxlLxNLRnJqSWPk+FtaslMjtwe0Y7a1JKZHLk9jsO1qSUzOXJ7HIBuU0tmsmmyL4apJeOnU0tmcuT2CITWppbM5MjtcaikTS2hkWRNjtwefos2tWQmR258moXb1JKZfOQmj6sBbWjJV7JosmqSNMmaFE02TfZnsg8t+UomTWZNFk1WTZImWZOiyaZJzS1pbklzS5pb0tyS5pY0t6S5Jc1taIk8rlP1oSUzObREHq7APrTkK5k1WTQ5cnt4B/rQkq8ka1I0OXJ7tHEfWjKTQ0vk4UftQ0vkcT6pDy35So7cHiFv+tASebRxH1rylWRNiiabJvtKDi35So7cHsdT+tCSr+TI7XEerw8t+UqO3B5HBvrQEnn4sfvQkq/kI7cRxqQPLWkPP14fWvKVTCP5yHhoSXsM0z605CtZNUkj2R9J1uQjt1YGQ9NkX8mhJePQcx9a0h4jqw8t+UqO3EatDy35So7c6mAYuT1GVh9a0h6XGfrQkjbqbGjJTA4t+UomTWZNFk1WTZImWZOiSc1NNLemuTXNrWluTXNrmlvT3Jrm1jS3prk1za1rbl1z65pb19y65tY1t665dc1taMlwM/ahJSOZjiEmz/TI73H+4XFU0KSLSY8s+/z9kecjJPCZZpMeuT765pl+ZNsffe9Md00PWemPkIhnOpl0Hunxt0NZ+mP8nulq0jTSowxDXHqdPxeTbibdNT0E5plOJp1Nuph0NemRbx35ZjZpMelm0l3T5TDpZNLZpItJV5M2+RaTbzH5FpNvMflWk2+d+cpIZ5MuJl1NmkyaTVpMupl01zQdJm3yJZMvmXzJ5EsmXzL5ksmXZr59pLum+TDpZNLZpItJV5Mmk2aTHvnS6LdDkJ7prukhSc90Muls0sWkq0mTSbNJm3zF5Csm32bybSbfZvId+jSOTJzpatJk0iNfHnU7NOqZbibdNT1k6plOJp1Nuph0NWkyaZNvN/l2k2/XfNNxmHQy6WzSxaSrSZNJs0mLSTeTNvkmk28y+SaTbzL5JpNvMvkmk28y+SaTbzL5ZpNvNvlmk282+WaTbzb5ZpNvNvlmk282+RaTbzH5FpNvMflOvRr6n6ZefaV5vig+0mLSbZz8OEa6j/RDo9JDr1Y6jTSNdB7p8bcPvVrpOtJtpMmk2aTFpGe+faS7pukw6WTSI988ykkj38eF6jNdTZpMmrX8NPJ9nI47082ku6b5MOmkf8vZpItJm3x55vs4jfJ//vT3v/zpf/31z//+h//xX4/DKf/5t395HkQ54X/8f//2/Jf/9fe//PWvf/l///nf/v6v//Ln//2ff//z49DKOK9yPP7z6Ob/M/Efc3ocakn6o/7HXB8/yl+/ev5SPZdw5385/dMf/1DmT3j8RPI//fHJVM9qP/+by+NHaf5I+uNHbWRRxlGZ8+e5/rHU59/V44+VHv9cVwnOT878+BHhv+D1F+dqtI4yy/qL/sfSf/xFw4T9+cXn6vSP5ajPry3HH8/e+vz1fA6DPD/88ZXnOv+E7Z/++3E66P8H",
      is_unconstrained: false,
      name: "claim_private",
      verification_key: "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"
    },
    {
      abi: {
        error_types: {
          "12142166718796425542": {
            error_kind: "string",
            string: "Order not opened"
          },
          "12469291177396340830": {
            error_kind: "string",
            string: "call to assert_max_bit_size"
          },
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14942831874215426972": {
            error_kind: "string",
            string: "Invalid destination domain"
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15130664124905246775": {
            error_kind: "string",
            string: "L1-to-L2 message is already nullified"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "16070420376462343922": {
            error_kind: "string",
            string: "Not a public order"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "16464709583191233416": {
            error_kind: "string",
            string: "Invalid id"
          },
          "16882345102269044371": {
            error_kind: "string",
            string: "Tried to consume nonexistent L1-to-L2 message"
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "361444214588792908": {
            error_kind: "string",
            string: "attempt to multiply with overflow"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          },
          "5167727358818866312": {
            error_kind: "string",
            string: "Invalid destination settler"
          },
          "8228371833434187583": {
            error_kind: "string",
            string: "Trying to read from uninitialized PublicImmutable"
          }
        },
        parameters: [
          {
            name: "order_id_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "order_data_bytes",
            type: {
              kind: "array",
              length: 301,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "message_leaf_index",
            type: {
              kind: "field"
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "JwACBAEoAAABBIHOKAAAAAQBzigCAAQEAU4nAgUEAB8KAAQABQCAHACAgAIcAIGBAhwAgoICHACDgwIcAISEAhwAhYUCHACGhgIcAIeHAhwAiIgCHACJiQIcAIqKAhwAi4sCHACMjAIcAI2NAhwAjo4CHACPjwIcAJCQAhwAkZECHACSkgIcAJOTAhwAlJQCHACVlQIcAJaWAhwAl5cCHACYmAIcAJmZAhwAmpoCHACbmwIcAJycAhwAnZ0CHACengIcAJ+fAhwAoKACHAChoQIcAKKiAhwAo6MCHACkpAIcAKWlAhwApqYCHACnpwIcAKioAhwAqakCHACqqgIcAKurAhwArKwCHACtrQIcAK6uAhwAr68CHACwsAIcALGxAhwAsrICHACzswIcALS0AhwAtbUCHAC2tgIcALe3AhwAuLgCHAC5uQIcALq6AhwAu7sCHAC8vAIcAL29AhwAvr4CHAC/vwIcAMDAAhwAwcECHADCwgIcAMPDAhwAxMQCHADFxQIcAMbGAhwAx8cCHADIyAIcAMnJAhwAysoCHADLywIcAMzMAhwAzc0CHADOzgIcAM/PAhwA0NACHADR0QIcANLSAhwA09MCHADU1AIcANXVAhwA1tYCHADX1wIcANjYAhwA2dkCHADa2gIcANvbAhwA3NwCHADd3QIcAN7eAhwA398CHADg4AIcAOHhAhwA4uICHADj4wIcAOTkAhwA5eUCHADm5gIcAOfnAhwA6OgCHADp6QIcAOrqAhwA6+sCHADs7AIcAO3tAhwA7u4CHADv7wIcAPDwAhwA8fECHADy8gIcAPPzAhwA9PQCHAD19QIcAPb2AhwA9/cCHAD4+AIcAPn5AhwA+voCHAD7+wIcAPz8AhwA/f0CHAD+/gIcAP//Ah0AAQABAAIdAAEBAQECHQABAgECAh0AAQMBAwIdAAEEAQQCHQABBQEFAh0AAQYBBgIdAAEHAQcCHQABCAEIAh0AAQkBCQIdAAEKAQoCHQABCwELAh0AAQwBDAIdAAENAQ0CHQABDgEOAh0AAQ8BDwIdAAEQARACHQABEQERAh0AARIBEgIdAAETARMCHQABFAEUAh0AARUBFQIdAAEWARYCHQABFwEXAh0AARgBGAIdAAEZARkCHQABGgEaAh0AARsBGwIdAAEcARwCHQABHQEdAh0AAR4BHgIdAAEfAR8CHQABIAEgAh0AASEBIQIdAAEiASICHQABIwEjAh0AASQBJAIdAAElASUCHQABJgEmAh0AAScBJwIdAAEoASgCHQABKQEpAh0AASoBKgIdAAErASsCHQABLAEsAh0AAS0BLQIdAAEuAS4CHQABLwEvAh0AATABMAIdAAExATECHQABMgEyAh0AATMBMwIdAAE0ATQCHQABNQE1Ah0AATYBNgIdAAE3ATcCHQABOAE4Ah0AATkBOQIdAAE6AToCHQABOwE7Ah0AATwBPAIdAAE9AT0CHQABPgE+Ah0AAT8BPwIdAAFAAUACHQABQQFBAh0AAUIBQgIdAAFDAUMCHQABRAFEAh0AAUUBRQIdAAFGAUYCHQABRwFHAh0AAUgBSAIdAAFJAUkCHQABSgFKAh0AAUsBSwIdAAFMAUwCHQABTQFNAh0AAU4BTgIdAAFPAU8CHQABUAFQAh0AAVEBUQIdAAFSAVICHQABUwFTAh0AAVQBVAIdAAFVAVUCHQABVgFWAh0AAVcBVwIdAAFYAVgCHQABWQFZAh0AAVoBWgIdAAFbAVsCHQABXAFcAh0AAV0BXQIdAAFeAV4CHQABXwFfAh0AAWABYAIdAAFhAWECHQABYgFiAh0AAWMBYwIdAAFkAWQCHQABZQFlAh0AAWYBZgIdAAFnAWcCHQABaAFoAh0AAWkBaQIdAAFqAWoCHQABawFrAh0AAWwBbAIdAAFtAW0CHQABbgFuAh0AAW8BbwIdAAFwAXACHQABcQFxAh0AAXIBcgIdAAFzAXMCHQABdAF0Ah0AAXUBdQIdAAF2AXYCHQABdwF3Ah0AAXgBeAIdAAF5AXkCHQABegF6Ah0AAXsBewIdAAF8AXwCHQABfQF9Ah0AAX4BfgIdAAF/AX8CHQABgAGAAh0AAYEBgQIdAAGCAYICHQABgwGDAh0AAYQBhAIdAAGFAYUCHQABhgGGAh0AAYcBhwIdAAGIAYgCHQABiQGJAh0AAYoBigIdAAGLAYsCHQABjAGMAh0AAY0BjQIdAAGOAY4CHQABjwGPAh0AAZABkAIdAAGRAZECHQABkgGSAh0AAZMBkwIdAAGUAZQCHQABlQGVAh0AAZYBlgIdAAGXAZcCHQABmAGYAh0AAZkBmQIdAAGaAZoCHQABmwGbAh0AAZwBnAIdAAGdAZ0CHQABngGeAh0AAZ8BnwIdAAGgAaACHQABoQGhAh0AAaIBogIdAAGjAaMCHQABpAGkAh0AAaUBpQIdAAGmAaYCHQABpwGnAh0AAagBqAIdAAGpAakCHQABqgGqAh0AAasBqwIdAAGsAawCHQABrQGtAh0AAa4BrgIdAAGvAa8CHQABsAGwAh0AAbEBsQIdAAGyAbICHQABswGzAh0AAbQBtAIdAAG1AbUCHQABtgG2Ah0AAbcBtwIdAAG4AbgCHQABuQG5Ah0AAboBugIdAAG7AbsCHQABvAG8Ah0AAb0BvQIdAAG+Ab4CHQABvwG/Ah0AAcABwAIdAAHBAcECHQABwgHCAh0AAcMBwwIdAAHEAcQCHQABxQHFAh0AAcYBxgIdAAHHAccCHQAByAHIAh0AAckByQIdAAHKAcoCHQABywHLAh0AAcwBzAInAgEEgCcCBQQgLQgBBCcCBgQhAAgBBgEnAwQEAQAiBAIGLQIBAy0CBgQtAgUFJQAACNYtCgQBJwICBKAoAgAFBAEtLQgBBCgCAAYEAS4ACAEGAScDBAQBACIEAgYtAgIDLQIGBC0CBQUlAAAI1i0KBAIuCAHNAAMlAAAJCCUAAAw4KAIAAQQBzicCAgQAOw4AAgABAAADBQctAAMILQAECQoACAcKJAAACgAACQctAQgGLQQGCQAACAIIAAAJAgkjAAAI4yYnAEMAAScARAAFJwBFAgAnAEYCAicARwJTJwBIAkUnAEkCQycASgJSJwBLAlQtAAFMJwBNBAcAAAFNAScBTAQBAABMAk0tAE1OLQRHTgAATgJOLQRITgAATgJOLQRJTgAATgJOLQRKTgAATgJOLQRITgAATgJOLQRLTicATQJmJwBOAq0nAE8CNicAUALYJwBRAsonAFICECcAUwJtJwBUAqknAFUCZScAVgJjJwBXAlUnAFgCYScAWQKrJwBaAqQnAFsCuScAXAIWJwBdAuwnAF4CaScAXwJuJwBgAs0nAGEC0CcAYgKKJwBjAj4nAGQCXicAZQLTJwBmAmgnAGcC9CcAaALkJwBpAnMnAGoCpScAawI4LQABbCcAbQQhAAABbQEnAWwEAQAAbAJtLQBtbi0ETW4AAG4Cbi0ETm4AAG4Cbi0ET24AAG4Cbi0EUG4AAG4Cbi0EUW4AAG4Cbi0EUm4AAG4Cbi0EU24AAG4Cbi0EVG4AAG4Cbi0EVW4AAG4Cbi0EVm4AAG4Cbi0EV24AAG4Cbi0EWG4AAG4Cbi0ESm4AAG4Cbi0EWW4AAG4Cbi0EWm4AAG4Cbi0EW24AAG4Cbi0EXG4AAG4Cbi0EXW4AAG4Cbi0EXm4AAG4Cbi0EX24AAG4Cbi0EYG4AAG4Cbi0EYW4AAG4Cbi0EYm4AAG4Cbi0EY24AAG4Cbi0EZG4AAG4Cbi0EZW4AAG4Cbi0EZm4AAG4Cbi0EZ24AAG4Cbi0EaG4AAG4Cbi0EaW4AAG4Cbi0Eam4AAG4Cbi0Ea24nAG0EBScAbgQGKQAAbwT/////KQAAcARqCeZnKQAAcQS7Z66FKQAAcgQ8bvNyKQAAcwSlT/U6KQAAdARRDlJ/KQAAdQSbBWiMKQAAdgQfg9mrKQAAdwRb4M0ZLQABeCcAeQQJAAABeQEnAXgEAQAAeAJ5LQB5ei0EcHoAAHoCei0EcXoAAHoCei0EcnoAAHoCei0Ec3oAAHoCei0EdHoAAHoCei0EdXoAAHoCei0EdnoAAHoCei0Ed3onAHkEAycAegRAJwB7BAQoAAB8BAEAKQAAfQSAAAAAJwB+BIAnAH8EDiYlAABahh4CAAUAHgIABgAtCAEHAAABAgEtDgYHLQgBBgAAAQIBLQxDBi0IAQgAAAECAScCCQAGLQ4JCB4CAAoAHgIACwAzKgAKAAsADCcCCgEBJAIADAAADJclAABarC0LAQsAIgsCCy0OCwEtCAELAAABAgEtDEMLLQgBDAAAAQIBJwINAAAtDg0MJwIOBAAnAg8EICcCEAQfKAIAEQABACcCEgQBLQoOBCMAAAznDCoEDwUkAgAFAABaHSMAAAz5LQsMBS0LAgsAIgsCCy0OCwItCAELJwIMBCEACAEMAScDCwQBACILAgwnAhMEIAAqEwwTLQoMFA4qExQVJAIAFQAADUstDEUUACIUAhQjAAANMC0IAQwAAAECAS0OCwwtCg4EIwAADWEMKgQPCyQCAAsAAFnZIwAADXMtCwwLLQsCDAAiDAIMLQ4MAi0IAQwnAhMEIQAIARMBJwMMBAEAIgwCEycCFAQgACoUExQtChMVDioUFRYkAgAWAAANxS0MRRUAIhUCFSMAAA2qLQgBEwAAAQIBLQ4MEygCAAwEAS0tCg4EIwAADeIMKgQPFCQCABQAAFl+IwAADfQtCxMULQsCEwAiEwITLQ4TAi0IARMnAhUEIQAIARUBJwMTBAEAIhMCFScCFgQgACoWFRYtChUXDioWFxgkAgAYAAAORi0MRRcAIhcCFyMAAA4rLQgBFQAAAQIBLQ4TFS0KDgQjAAAOXAwqBA8TJAIAEwAAWSMjAAAObi0LFRMtCwIVACIVAhUtDhUCLQgBFScCFgQhAAgBFgEnAxUEAQAiFQIWJwIXBCAAKhcWFy0KFhgOKhcYGSQCABkAAA7ALQxFGAAiGAIYIwAADqUtCAEWAAABAgEtDhUWJwIVBGAtCg4EIwAADtsMKgQPFyQCABcAAFjIIwAADu0tCxYXLQsCFgAiFgIWLQ4WAi0IARYnAhgEIQAIARgBJwMWBAEAIhYCGCcCGQQgACoZGBktChgaDioZGhskAgAbAAAPPy0MRRoAIhoCGiMAAA8kLQgBGAAAAQIBLQ4WGC0KDgQjAAAPVQwqBA8WJAIAFgAAWG0jAAAPZy0LGBYtCwIYACIYAhgtDhgCLQgBGCcCGQQhAAgBGQEnAxgEAQAiGAIZJwIaBCAAKhoZGi0KGRsOKhobHCQCABwAAA+5LQxFGwAiGwIbIwAAD54tCAEZAAABAgEtDhgZJwIYBKAtCg4EIwAAD9QMKgQPGiQCABoAAFgSIwAAD+YtCxkaLQsCGQAiGQIZLQ4ZAi0IARknAhsEIQAIARsBJwMZBAEAIhkCGycCHAQgACocGxwtChsdDiocHR4kAgAeAAAQOC0MRR0AIh0CHSMAABAdLQgBGwAAAQIBLQ4ZGycCGQTALQoOBCMAABBTDCoEDxwkAgAcAABXtyMAABBlLQsbHC0LAhsAIhsCGy0OGwItCAEbJwIdBAUACAEdAScDGwQBACIbAh0tCh0eLQxFHgAiHgIeLQxFHgAiHgIeLQxFHgAiHgIeLQxFHi0IAR0AAAECAS0OGx0nAhsE4C0KDgQjAAAQzAwiBHseJAIAHgAAV1wjAAAQ3i0LHR4tCAEdAAABAgEtDEMdLQgBHwAAAQIBLQ4NHy0KDgQjAAARBQwiBHsgJAIAIAAAVvMjAAARFy0LHx0cCh0eACkCAB8A/////w4qHh8gJAIAIAAAETslAABavi0LAh4AIh4CHi0OHgItCAEeJwIfBAUACAEfAScDHgQBACIeAh8tCh8gLQxFIAAiIAIgLQxFIAAiIAIgLQxFIAAiIAIgLQxFIC0IAR8AAAECAS0OHh8nAh4E5C0KDgQjAAARngwiBHsgJAIAIAAAVpgjAAARsC0LHx4tCAEfAAABAgEtDEMfLQgBIAAAAQIBLQ4NIC0KDgQjAAAR1wwiBHshJAIAIQAAVi8jAAAR6S0LIB4cCh4fACkCACAA/////w4qHyAhJAIAIQAAEg0lAABavi0LAh8AIh8CHy0OHwItCAEfJwIgBCEACAEgAScDHwQBACIfAiAnAiEEIAAqISAhLQogIg4qISIjJAIAIwAAElstDEUiACIiAiIjAAASQC0IASAAAAECAS0OHyAnAh8E6C0KDgQjAAASdgwqBA8hJAIAIQAAVdQjAAASiC0LIB8tCwIgACIgAiAtDiACLQgBICcCIQQFAAgBIQEnAyAEAQAiIAIhLQohIi0MRSIAIiICIi0MRSIAIiICIi0MRSIAIiICIi0MRSItCAEhAAABAgEtDiAhKAIAIAQBCC0KDgQjAAAS8QwiBHsiJAIAIgAAVXkjAAATAy0LISAtCAEhAAABAgEtDEMhLQgBIgAAAQIBLQ4NIi0KDgQjAAATKgwiBHsjJAIAIwAAVRAjAAATPC0LIiAcCiAhACkCACIA/////w4qISIjJAIAIwAAE2AlAABavi0LAiEAIiECIS0OIQIoAgAhBAENACoCISMtCyMiLQgBIycCJAQhAAgBJAEnAyMEAQAiIwIkJwIlBCAAKiUkJS0KJCYOKiUmJyQCACcAABO+LQxFJgAiJgImIwAAE6MtCAEkAAABAgEtDiMkLQoOBCMAABPUDCoEDyMkAgAjAABUtSMAABPmLQskBC0LCwwAIgwCDC0ODAstCxQMACIMAgwtDgwULQsTDAAiDAIMLQ4MEy0LFwwAIgwCDC0ODBctCxYMACIMAgwtDgwWLQsaDAAiDAIMLQ4MGi0LHAwAIgwCDC0ODBwtCx8MACIMAgwtDgwfLQsEDAAiDAIMLQ4MBC0IAQwnAiEEDgAIASEBJwMMBAEAIgwCIScCIwQNACojISMtCiEkDiojJCUkAgAlAAAUoC0ODSQAIiQCJCMAABSFLQgBIQAAAQIBLQ4MIS0LCwwAIgwCDC0ODAstCAEMAAABAgEtDEMMLQgBIwAAAQIBLQ4NIy0KDgIjAAAU3QwqAg8kJAIAJAAAVEwjAAAU7y0LIwwtCyEjLQIjAycABAQOJQAAWtAtCAUkACokEiUtDgwlLQ4kIS0LFAwAIgwCDC0ODBQtCAEMAAABAgEtDEMMLQgBIwAAAQIBLQ4NIy0KDgIjAAAVRgwqAg8kJAIAJAAAU+MjAAAVWC0LIwwtCyEUJwIjBAItAhQDJwAEBA4lAABa0C0IBSQAKiQjJS0ODCUtDiQhLQsTDAAiDAIMLQ4MEy0IAQwAAAECAS0MQwwtCAEUAAABAgEtDg0ULQoOAiMAABW0DCoCDyQkAgAkAABTeiMAABXGLQsUDC0LIRQtAhQDJwAEBA4lAABa0C0IBSQAIiR5JS0ODCUtDiQhLQsXDAAiDAIMLQ4MFy0IAQwAAAECAS0MQwwtCAEUAAABAgEtDg0ULQoOAiMAABYdDCoCDyQkAgAkAABTESMAABYvLQsUDC0LIRQtAhQDJwAEBA4lAABa0C0IBRcAIhd7JC0ODCQtDhchLQsWDAAiDAIMLQ4MFi0IAQwAAAECAS0MQwwtCAEUAAABAgEtDg0ULQoOAiMAABaGDCoCDxckAgAXAABSqCMAABaYLQsUDC0LIRQtAhQDJwAEBA4lAABa0C0IBRcAIhdtJC0ODCQtDhchLQsaDAAiDAIMLQ4MGi0IAQwAAAECAS0MQwwtCAEUAAABAgEtDg0ULQoOAiMAABbvDCoCDxckAgAXAABSPyMAABcBLQsUDC0LIRQtAhQDJwAEBA4lAABa0C0IBRcAIhduGi0ODBotDhchLQscDAAiDAIMLQ4MHC0IAQwAAAECAS0MQwwtCAEUAAABAgEtDg0ULQoOAiMAABdYDCoCDxckAgAXAABR1iMAABdqLQsUDC0LIRQnAhcEBy0CFAMnAAQEDiUAAFrQLQgFGgAqGhccLQ4MHCcCDAQILQIaAycABAQOJQAAWtAtCAUUACoUDBctDh0XJwIXBAktAhQDJwAEBA4lAABa0C0IBRoAKhoXHC0OHhwtDhohLQsfFAAiFAIULQ4UHy0IARQAAAECAS0MQxQtCAEaAAABAgEtDg0aLQoOAiMAABgGDCoCDxwkAgAcAABRbSMAABgYLQsaFC0LIRonAhwECi0CGgMnAAQEDiUAAFrQLQgFHQAqHRwkLQ4UJCcCFAQLLQIdAycABAQOJQAAWtAtCAUaACoaFBwtDiAcHAoiFAAnAhwEDC0CGgMnAAQEDiUAAFrQLQgFHQAqHRwgLQ4UIC0OHSEtCAEUAAABAgEtDEMULQgBGgAAAQIBLQ4NGi0KDgIjAAAYrAwqAg8cJAIAHAAAUQQjAAAYvi0LGgQtCyEUJwIaBA0tAhQDJwAEBA4lAABa0C0IBRwAKhwaHS0OBB0tDhwhLQgBBCcCFAQEAAgBFAEnAwQEAQAiBAIULQoUHS0ODR0AIh0CHS0ODR0AIh0CHS0ODR0rAgAUAAAAAAAAAAANAAAAAAAAAAAtCAEdJwIgBAUACAEgAScDHQQBACIdAiAtCiAhLQ4NIQAiIQIhLQ4NIQAiIQIhLQ4NIQAiIQIhLQ4UIS0IARQAAAECAS0OBBQtCAEEAAABAgEtDh0ELQgBHQAAAQIBLQ4OHS0IASAAAAECAScCIQEALQ4hIC0KDgIjAAAZrgwqAhokJAIAJAAAT0AjAAAZwC0LIBoKKhohHCQCABwAABnaJwIkBAA8BiQBLQoOAiMAABnjDCICeRokAgAaAABOuiMAABn1LQsUAi0LBBotCx0cLQsaJAAiJAIkLQ4kGi0IASQnAiUEBQAIASUBJwMkBAEAIhoCJScCJgQEACIkAic/DwAlACctDgIULQ4kBC0OHB0tDgogACokEgQtCwQCCioCBQQkAgAEAAAaYSUAAFsvLQsIAi0IAQQnAhQEBAAIARQBJwMEBAEAIgQCFC0KFBotDg0aACIaAhotDg0aACIaAhotDg0aKwIAFAAAAAAAAAAAAgAAAAAAAAAALQgBGicCHAQFAAgBHAEnAxoEAQAiGgIcLQocHS0ODR0AIh0CHS0ODR0AIh0CHS0ODR0AIh0CHS0OFB0tCAEcAAABAgEtDgQcLQgBBAAAAQIBLQ4aBC0IAR0AAAECAS0ODh0tCAEgAAABAgEtDiEgJAIAIQAAG28jAAAbKC0IASQnAiUEBAAIASUBJwMkBAEAIiQCJS0KJSYtDgImACImAiYtDg0mACImAiYtDg0mLQ4kHC0OGgQtDhIdLQ4hICMAABv7LQoOGiMAABt4DCIaeSQkAgAkAABONCMAABuKLQscGi0LBCQtCyAlLQskJgAiJgImLQ4mJC0IASYnAicEBQAIAScBJwMmBAEAIiQCJycCKAQEACImAik/DwAnACktAhoDJwAEBAQlAABa0C0IBSQAKiQSJy0OAictDiQcLQ4mBC0OEh0tDiUgIwAAG/stCxwCLQsEGi0LICQKKiQhJSQCACUAABwdJwImBAA8BiYBJAIAIQAAHFojAAAcKi0CAgMnAAQEBCUAAFrQLQgFJAAqJCMlLQ4FJS0OJBwtDhoELQ4jHS0OISAjAAAc5i0KDgIjAAAcYwwiAnkaJAIAGgAATa4jAAAcdS0LHAItCwQaLQsgJC0LGiUAIiUCJS0OJRotCAElJwImBAUACAEmAScDJQQBACIaAiYnAicEBAAiJQIoPw8AJgAoLQICAycABAQEJQAAWtAtCAUaACoaEiYtDgUmLQ4aHC0OJQQtDhIdLQ4kICMAABzmLQsgGgoqGiEkJAIAJAAAHQAnAiUEADwGJQEtCg4CIwAAHQkMIgJ5GiQCABoAAE0oIwAAHRstCxwCLQsEGi0LHSQtCxolACIlAiUtDiUaLQgBJScCJgQFAAgBJgEnAyUEAQAiGgImJwInBAQAIiUCKD8PACYAKC0OAhwtDiUELQ4kHS0OCiAAKiUSBC0LBAIKKgINBAoqBCEaJAIAGgAAHYwlAABbQS8KAAIABAoiBEMCJAIAAgAAHaQlAABbUy0LCAItCAEEJwIIBAQACAEIAScDBAQBACIEAggtCggaLQ4NGgAiGgIaLQ4NGgAiGgIaLQ4NGi0IAQgnAhoEBQAIARoBJwMIBAEAIggCGi0KGhwtDg0cACIcAhwtDg0cACIcAhwtDg0cACIcAhwtDhQcLQgBGgAAAQIBLQ4EGi0IAQQAAAECAS0OCAQtCAEcAAABAgEtDg4cLQgBHQAAAQIBLQ4hHSQCACEAAB6dIwAAHlYtCAEgJwIkBAQACAEkAScDIAQBACIgAiQtCiQlLQ4CJQAiJQIlLQ4NJQAiJQIlLQ4NJS0OIBotDggELQ4SHC0OIR0jAAAfKS0KDggjAAAepgwiCHkgJAIAIAAATKIjAAAeuC0LGggtCwQgLQsdJC0LICUAIiUCJS0OJSAtCAElJwImBAUACAEmAScDJQQBACIgAiYnAicEBAAiJQIoPw8AJgAoLQIIAycABAQEJQAAWtAtCAUgACogEiYtDgImLQ4gGi0OJQQtDhIcLQ4kHSMAAB8pLQsaAi0LBAgtCx0gCiogISQkAgAkAAAfSycCJQQAPAYlASQCACEAAB+IIwAAH1gtAgIDJwAEBAQlAABa0C0IBSAAKiAjJC0OBSQtDiAaLQ4IBC0OIxwtDiEdIwAAIBQtCg4CIwAAH5EMIgJ5CCQCAAgAAEwcIwAAH6MtCxoCLQsECC0LHSAtCwgkACIkAiQtDiQILQgBJCcCJQQFAAgBJQEnAyQEAQAiCAIlJwImBAQAIiQCJz8PACUAJy0CAgMnAAQEBCUAAFrQLQgFCAAqCBIlLQ4FJS0OCBotDiQELQ4SHC0OIB0jAAAgFC0LHQUKKgUhCCQCAAgAACAuJwIgBAA8BiABLQoOAiMAACA3DCICeQUkAgAFAABLliMAACBJLQsaAi0LBAUtCxwILQsFIAAiIAIgLQ4gBS0IASAnAiQEBQAIASQBJwMgBAEAIgUCJCcCJQQEACIgAiY/DwAkACYtDgIaLQ4gBC0OCBwtDgodACogEgQtCwQCCioCDQQKKgQhBSQCAAUAACC6JQAAW0EwCABEAAIKIiJFAgoiIkYEEioCBAUkAgAFAAAg3CUAAFtlLQsGAi0IAQQnAgUEBAAIAQUBJwMEBAEAIgQCBS0KBQgtDg0IACIIAggtDg0IACIIAggtDg0ILQgBBScCCAQFAAgBCAEnAwUEAQAiBQIILQoIGi0ODRoAIhoCGi0ODRoAIhoCGi0ODRoAIhoCGi0OFBotCAEIAAABAgEtDgQILQgBBAAAAQIBLQ4FBC0IARoAAAECAS0ODhotCAEcAAABAgEtDiEcJAIAIQAAIdUjAAAhji0IAR0nAiAEBAAIASABJwMdBAEAIh0CIC0KICItDgkiACIiAiItDg0iACIiAiItDg0iLQ4dCC0OBQQtDhIaLQ4hHCMAACJhLQoOBSMAACHeDCIFeR0kAgAdAABLECMAACHwLQsIBS0LBB0tCxwgLQsdIgAiIgIiLQ4iHS0IASInAiQEBQAIASQBJwMiBAEAIh0CJCcCJQQEACIiAiY/DwAkACYtAgUDJwAEBAQlAABa0C0IBR0AKh0SJC0OCSQtDh0ILQ4iBC0OEhotDiAcIwAAImEtCwgFLQsEHS0LHCAKKiAhIiQCACIAACKDJwIkBAA8BiQBJAIAIQAAIsAjAAAikC0CBQMnAAQEBCUAAFrQLQgFIAAqICMiLQ4CIi0OIAgtDh0ELQ4jGi0OIRwjAAAjTC0KDgUjAAAiyQwiBXkdJAIAHQAASoojAAAi2y0LCAUtCwQdLQscIC0LHSIAIiICIi0OIh0tCAEiJwIkBAUACAEkAScDIgQBACIdAiQnAiUEBAAiIgImPw8AJAAmLQIFAycABAQEJQAAWtAtCAUdACodEiQtDgIkLQ4dCC0OIgQtDhIaLQ4gHCMAACNMLQscHQoqHSEgJAIAIAAAI2YnAiIEADwGIgEtCg4FIwAAI28MIgV5HSQCAB0AAEoEIwAAI4EtCwgdLQsEIC0LGiItCyAkACIkAiQtDiQgLQgBJCcCJQQFAAgBJQEnAyQEAQAiIAIlJwImBAQAIiQCJz8PACUAJy0OHQgtDiQELQ4iGi0OChwAKiQSCC0LCAQeAgAIADMqAAQACAAaJAIAGgAAI/UlAABbdy0IAQQnAggEBAAIAQgBJwMEBAEAIgQCCC0KCBotDg0aACIaAhotDg0aACIaAhotDg0aLQgBCAAAAQIBLQ4ECC0KDgUjAAAkPQwiBXkEJAIABAAASb4jAAAkTy0LCAQAKgQSCC0LCAUAKgQjGi0LGggcCggaBBwKGgQALQsfCAAiCAIILQ4IHy0IAQgAAAECAS0MQwgtCAEaAAABAgEtDg0aLQoOAiMAACSfDCoCDxwkAgAcAABJVSMAACSxLQsaCBwKCBoALAIAHAAAAAAAAAAAAAAAAAD//////////////////////////w4qGhwdJAIAHQAAJPElAABavgoqCAUaJAIAGgAAJQMlAABbiQoqHgQFJAIABQAAJRUlAABbmy0IAQQnAgUEQQAIAQUBJwMEBAEAIgQCBScCCARAACoIBQgtCgUaDioIGhwkAgAcAAAlVi0MRRoAIhoCGiMAACU7LQgBBQAAAQIBLQ4EBS0KDgIjAAAlbAwqAg8EJAIABAAASMwjAAAlfi0LBQItCXgEACIEAgQtBgR4LQgBBAAAAQIBLQx4BC0IAQUnAggEEQAIAQgBJwMFBAEAIgUCCCcCGgQQACoaCBotCggcDioaHB0kAgAdAAAl3S0ODhwAIhwCHCMAACXCLQsCCAAiCAIILQ4IAi0LAggAIggCCC0OCAItCwUIACIIAggtDggFLQgBCAAAAQIBLQ4FCCcCBQQQLQoOASMAACYfDCoBBRokAgAaAABH2CMAACYxLQsIAi0LBAgtCwgaACIaAhotDhoILQgBGicCHAQJAAgBHAEnAxoEAQAiAgIcACIIAh0AIhoCHkA/AB4AHQAcLQ4aBC0LGgIAIgICAi0OAhotCxoCACICAgItDgIaKAIAAgQCAC0IAQQnAggEEQAIAQgBJwMEBAEAIgQCCC0KCBwtDH0cACIcAhwtDg4cACIcAhwtDg4cACIcAhwtDg4cACIcAhwtDg4cACIcAhwtDg4cACIcAhwtDg4cACIcAhwtDg4cACIcAhwtDg4cACIcAhwtDg4cACIcAhwtDg4cACIcAhwtDg4cACIcAhwtDg4cACIcAhwtDg4cACIcAhwtDg4cACIcAhwtDgIcLQgBAgAAAQIBLQsaCAAiCAIILQ4IGi0IAQgnAhwECQAIARwBJwMIBAEAIgQCHAAiGgIdACIIAh5APwAeAB0AHC0OCAItCAEEJwIIBCEACAEIAScDBAQBACIEAggnAhoEIAAqGggaLQoIHA4qGhwdJAIAHQAAJ8EtDEUcACIcAhwjAAAnpi0IAQgAAAECAS0OBAgtCg4BIwAAJ9cMKgEMBCQCAAQAAEb3IwAAJ+ktCwgCLQgBBAAAAQIBLQxDBC0IAQgAAAECAS0ODQgtCAEaAAABAgEtDg0aJwIcBA8nAh0EHi0KDgEjAAAoJwwqARweJAIAHgAARlIjAAAoOS0LGh4AKgIFIC0LIB8cCh8CAC0LBB8EKgIfBAAqHgQCLQ4CGi0LCAQEKgQfCAAqAggELQlMAgAiAgICLQYCTC0IAQIAAAECAS0MQwItCAEIAAABAgEtDg0ILQoOASMAACibDCIBbhokAgAaAABF6SMAACitLQsIAS0LBgItCAEGJwIIBAQACAEIAScDBgQBACIGAggtCggaLQ4NGgAiGgIaLQ4NGgAiGgIaLQ4NGi0IAQgnAhoEBQAIARoBJwMIBAEAIggCGi0KGh4tDg0eACIeAh4tDg0eACIeAh4tDg0eACIeAh4tDhQeLQgBGgAAAQIBLQ4GGi0IAQYAAAECAS0OCAYtCAEeAAABAgEtDg4eLQgBHwAAAQIBLQ4hHyQCACEAACmqIwAAKWMtCAEgJwIiBAQACAEiAScDIAQBACIgAiItCiIkLQ4JJAAiJAIkLQ4NJAAiJAIkLQ4NJC0OIBotDggGLQ4SHi0OIR8jAAAqNi0KDggjAAApswwiCHkgJAIAIAAARWMjAAApxS0LGggtCwYgLQsfIi0LICQAIiQCJC0OJCAtCAEkJwIlBAUACAElAScDJAQBACIgAiUnAiYEBAAiJAInPw8AJQAnLQIIAycABAQEJQAAWtAtCAUgACogEiUtDgklLQ4gGi0OJAYtDhIeLQ4iHyMAACo2LQsaCC0LBgktCx8gCiogISIkAgAiAAAqWCcCJAQAPAYkASQCACEAACqVIwAAKmUtAggDJwAEBAQlAABa0C0IBSAAKiAjIi0OAiItDiAaLQ4JBi0OIx4tDiEfIwAAKyEtCg4IIwAAKp4MIgh5CSQCAAkAAETdIwAAKrAtCxoILQsGCS0LHyAtCwkiACIiAiItDiIJLQgBIicCJAQFAAgBJAEnAyIEAQAiCQIkJwIlBAQAIiICJj8PACQAJi0CCAMnAAQEBCUAAFrQLQgFCQAqCRIkLQ4CJC0OCRotDiIGLQ4SHi0OIB8jAAArIS0LHwkKKgkhICQCACAAACs7JwIiBAA8BiIBLQoOCCMAACtEDCIIeQkkAgAJAABEVyMAACtWLQsaCS0LBiAtCx4iLQsgJAAiJAIkLQ4kIC0IASQnAiUEBQAIASUBJwMkBAEAIiACJScCJgQEACIkAic/DwAlACctDgkaLQ4kBi0OIh4tDgofACokEgktCwkGHgIACQAzKgAGAAkAGiQCABoAACvKJQAAW3ctCAEGJwIJBAQACAEJAScDBgQBACIGAgktCgkaLQ4NGgAiGgIaLQ4NGgAiGgIaLQ4NGi0IAQkAAAECAS0OBgktCg4IIwAALBIMIgh5BiQCAAYAAEQRIwAALCQtCwkCACICeQgtCwgGLQgBAicCCAQEAAgBCAEnAwIEAQAiAgIILQoICS0ODQkAIgkCCS0ODQkAIgkCCS0ODQktCAEIJwIJBAUACAEJAScDCAQBACIIAgktCgkaLQ4NGgAiGgIaLQ4NGgAiGgIaLQ4NGgAiGgIaLQ4UGi0IAQkAAAECAS0OAgktCAECAAABAgEtDggCLQgBFAAAAQIBLQ4OFC0IARoAAAECAS0OIRonAh4AFCQCACEAAC0rIwAALOQtCAEfJwIgBAQACAEgAScDHwQBACIfAiAtCiAiLQ4eIgAiIgIiLQ4NIgAiIgIiLQ4NIi0OHwktDggCLQ4SFC0OIRojAAAtty0KDggjAAAtNAwiCHkfJAIAHwAAQ4sjAAAtRi0LCQgtCwIfLQsaIC0LHyIAIiICIi0OIh8tCAEiJwIkBAUACAEkAScDIgQBACIfAiQnAiUEBAAiIgImPw8AJAAmLQIIAycABAQEJQAAWtAtCAUfACofEiQtDh4kLQ4fCS0OIgItDhIULQ4gGiMAAC23LQsJCC0LAh4tCxofCiofISAkAgAgAAAt2ScCIgQAPAYiASQCACEAAC4WIwAALeYtAggDJwAEBAQlAABa0C0IBR8AKh8jIC0OASAtDh8JLQ4eAi0OIxQtDiEaIwAALqItCg4IIwAALh8MIgh5HiQCAB4AAEMFIwAALjEtCwkILQsCHi0LGh8tCx4gACIgAiAtDiAeLQgBICcCIgQFAAgBIgEnAyAEAQAiHgIiJwIjBAQAIiACJD8PACIAJC0CCAMnAAQEBCUAAFrQLQgFHgAqHhIiLQ4BIi0OHgktDiACLQ4SFC0OHxojAAAuoi0LGh4KKh4hHyQCAB8AAC68JwIgBAA8BiABLQoOCCMAAC7FDCIIeR4kAgAeAABCfyMAAC7XLQsJHi0LAh8tCxQgLQsfIgAiIgIiLQ4iHy0IASInAiMEBQAIASMBJwMiBAEAIh8CIycCJAQEACIiAiU/DwAjACUtDh4JLQ4iAi0OIBQtDgoaACoiEgktCwkCHgIACQMeAgAUAB4CABoELQgBHicCHwThAAgBHwEnAx4EAQAiHgIfJwIgBOAAKiAfIC0KHyIOKiAiIyQCACMAAC+BLQxFIgAiIgIiIwAAL2YtCAEfAAABAgEtDh4fJwIgAQAtCAEeJwIiBCEACAEiAScDHgQBACIeAiInAiMEIEMDogAGAHwAIwAgACInAiABAC0IAQYnAiIEIQAIASIBJwMGBAEAIgYCIicCIwQgQwOiAAkAfAAjACAAIicCIAEALQgBCScCIgQhAAgBIgEnAwkEAQAiCQIiJwIjBCBDA6IAFAB8ACMAIAAiJwIgAQAtCAEUJwIiBCEACAEiAScDFAQBACIUAiInAiMEIEMDogAaAHwAIwAgACInAiABAC0IARonAiIEIQAIASIBJwMaBAEAIhoCIicCIwQgQwOiAAQAfAAjACAAIicCIAEALQgBBCcCIgQhAAgBIgEnAwQEAQAiBAIiJwIjBCBDA6IAAgB8ACMAIAAiJwIgAQAtCAECJwIiBCEACAEiAScDAgQBACICAiInAiMEIEMDogADAHwAIwAgACItCg4IIwAAMOAMKggPICQCACAAAECdIwAAMPItCx8ELQl4BgAiBgIGLQYGeC0IAQYAAAECAS0MeAYtCAEIJwIJBBEACAEJAScDCAQBACIIAgknAhQEEAAqFAkULQoJFQ4qFBUYJAIAGAAAMVEtDg4VACIVAhUjAAAxNi0KDgIjAAAxWgwiAnkJJAIACQAAPhYjAAAxbC0LBAkAIgkCCS0OCQQtCwQJACIJAgktDgkELQsICQAiCQIJLQ4JCC0IAQkAAAECAS0OCAktCg4CIwAAMakMKgIMCCQCAAgAAD0GIwAAMbstCwkELQsGCC0LCAYAIgYCBi0OBggAKgQXCS0LCQYAIgZ9CQ4qBgkUJAIAFAAAMfAlAABbrS0CBAMnAAQEESUAAFrQLQgFBgAqBhcULQ4JFC0LCAQAIgQCBC0OBAgtCwYEACIEAgQtDgQGLQIGAycABAQRJQAAWtAtCAUEACoEHAktDg4JKAIABgQHAC0CBAMnAAQEESUAAFrQLQgFCQAqCQUULQ4GFC0IAQQAAAECAS0LCAYAIgYCBi0OBggtCAEGJwIUBAkACAEUAScDBgQBACIJAhQAIggCFQAiBgIXQD8AFwAVABQtDgYELQgBBicCCAQhAAgBCAEnAwYEAQAiBgIIJwIJBCAAKgkICS0KCBQOKgkUFSQCABUAADLnLQxFFAAiFAIUIwAAMswtCAEIAAABAgEtDgYILQoOAiMAADL9DCoCDAYkAgAGAAA8JSMAADMPLQsIBC0IAQYAAAECAS0MQwYtCAEIAAABAgEtDg0ILQgBCQAAAQIBLQ4NCS0KDgIjAAAzQwwqAhwUJAIAFAAAO4AjAAAzVS0LCRQAKgQFFy0LFxUcChUEAC0LBhUEKgQVBgAqFAYELQ4ECS0LCAYEKgYVCAAqBAgGLQgBBCcCCAQEAAgBCAEnAwQEAQAiBAIILQoICS0MRAkAIgkCCS0OBgkAIgkCCS0OAQktCAEBJwIIBAQACAEIAScDAQQBACIBAggtCggJLQ4NCQAiCQIJLQ4NCQAiCQIJLQ4NCSsCAAgAAAAAAAAAAAMAAAAAAAAAAC0IAQknAhQEBQAIARQBJwMJBAEAIgkCFC0KFBUtDg0VACIVAhUtDg0VACIVAhUtDg0VACIVAhUtDggVLQgBCAAAAQIBLQ4BCC0IAQEAAAECAS0OCQEtCAEJAAABAgEtDg4JLQgBFAAAAQIBLQ4hFC0KDgIjAAA0eAwiAnkVJAIAFQAAObwjAAA0ii0LFAQKKgQhFSQCABUAADSkJwIXBAA8BhcBLQoOAiMAADStDCICeQQkAgAEAAA5NiMAADS/LQsIBC0LARUtCwkXLQsVGAAiGAIYLQ4YFS0IARgnAhkEBQAIARkBJwMYBAEAIhUCGScCGgQEACIYAhs/DwAZABstDgQILQ4YAS0OFwktDgoUACoYEgQtCwQBHgIABAAzKgABAAQACAoqCCEEJAIABAAANTglAABbvxwKAwgFHAoIBAAcCgQDBTUqAAYAAwAEJAIABAAANVwlAABb0TQCAAEtCxMBACIBAgEtDgETLQgBAQAAAQIBLQxDAS0IAQMAAAECAS0ODQMtCg4CIwAANZAMKgIPBCQCAAQAADjNIwAANaItCwMCLQsHAy0LCwQAIgQCBC0OBAstCAEEAAABAgEtDEMELQgBBgAAAQIBLQ4NBi0KDgEjAAA12gwqAQ8HJAIABwAAOGQjAAA17C0LBgQtCAEGAAABAgEnAgcGAC0OBwYtCg4BIwAANgsMKgEFByQCAAcAADf+IwAANh0tCwYFHAoFBgAtCAEFJwIHBAUACAEHAScDBQQBACIFAgctCgcILQ4DCAAiCAIILQ4ECAAiCAIILQ4GCAAiCAIILQ4NCC0LBQMAIgMCAy0OAwUtCAEDAAABAgEpAgAEAMR63qAtCAEGJwIHBAYACAEHAScDBgQBACIGAgctCgcILQ4ECAAiCAIILQ4NCAAiCAIILQ4NCAAiCAIILQ4NCAAiCAIILQ4NCC0OBgMtCg4BIwAANtEMIgF7BCQCAAQAADeoIwAANuMtCwMBACIBAgM5AyAAbwBvAAIAbQADIAIAASECAAItCAEEACIEAgctCwcHLQoHBicCCAQDACoECAUiOgACAA4ABS0KAgYnAwQEAQAiBAIHLQ4GBwAiBwIHLQ4GBycCCAQDACoGCAcACAEHAS0KBgMGIgMCAyQCAAEAADeRIwAAN2QtCwQBACIBAgEtDgEEACIEAgUtCwUFLQoFAicCBgQDACoEBgE8DgIBIwAAN5EKKgMOASQCAAEAADenJwICBAA8BgIBJgAqARIEACIFAgcAKgcBCC0LCAYtCwMHDCIEbQgkAgAIAAA30SUAAFvjLQIHAycABAQGJQAAWtAtCAUIACIIAgkAKgkECy0OBgstDggDLQoEASMAADbRLQsGBwIqEAEIDCoIDwkkAgAJAAA4GSUAAFvjACIWAgsAKgsIES0LEQkcCgkIBgQqAQwJHAoJCwYYKggLCQAqBwkIDioHCAskAgALAAA4UiUAAFutLQ4IBgAqARIHLQoHASMAADYLLQsGBwIqEAEIDioBEAkkAgAJAAA4fyUAAFv1DCoIDwkkAgAJAAA4kSUAAFvjACILAhMAKhMIFC0LFAkcCgkIAC0LBAkEKggJEwAqBxMILQ4IBgQqCREHLQ4HBAAqARIHLQoHASMAADXaLQsDBAIqEAIGDioCEAgkAgAIAAA46CUAAFv1DCoGDwgkAgAIAAA4+iUAAFvjACITAgkAKgkGFC0LFAgcCggGAC0LAQgEKgYICQAqBAkGLQ4GAwQqCBEELQ4EAQAqAhIELQoEAiMAADWQLQsIBC0LARUtCwkXLQsUGAwqAhcZJAIAGQAAOVgjAAA5rgAiFQIaACoaAhstCxsZACIEAhsAKhsCHC0LHBoAKhkaGy0CFQMnAAQEBSUAAFrQLQgFGQAiGQIaACoaAhwtDhscLQ4ECC0OGQEtDhcJLQ4YFCMAADmuACoCEgQtCgQCIwAANK0AIgQCFwAqFwIYLQsYFS0LCBctCwEYLQsJGS0LFBoKKhohGyQCABsAADnwJwIcBAA8BhwBCiIZeRokAgAaAAA6YCMAADoCDCIZeRokAgAaAAA6FCUAAFvjLQIXAycABAQEJQAAWtAtCAUaACIaAhsAKhsZHC0OFRwAKhkSFQ4qGRUXJAIAFwAAOkslAABbrS0OGggtDhgBLQ4VCS0OIRQjAAA67C0KDhcjAAA6aQwiF3kYJAIAGAAAOvojAAA6ey0LCBctCwEYLQsUGS0LGBoAIhoCGi0OGhgtCAEaJwIbBAUACAEbAScDGgQBACIYAhsnAhwEBAAiGgIdPw8AGwAdLQIXAycABAQEJQAAWtAtCAUYACoYEhstDhUbLQ4YCC0OGgEtDhIJLQ4ZFCMAADrsACoCEhUtChUCIwAANHgtCwgYLQsBGS0LCRotCxQbDCoXGhwkAgAcAAA7HCMAADtyACIZAh0AKh0XHi0LHhwAIhgCHgAqHhcfLQsfHQAqHB0eLQIZAycABAQFJQAAWtAtCAUcACIcAh0AKh0XHy0OHh8tDhgILQ4cAS0OGgktDhsUIwAAO3IAKhcSGC0KGBcjAAA6aS0LCRQCKh0CFQwqFQ8XJAIAFwAAO5slAABb4wAiBAIYACoYFRktCxkXHAoXFQAtCwYXBCoVFxgAKhQYFS0OFQkEKhcRFC0OFAYtCwgVAih/AhcOIgJ/GCQCABgAADvkJQAAW/UMKhcPGCQCABgAADv2JQAAW+MAIgQCGQAqGRcaLQsaGBwKGBcABCoXFBgAKhUYFC0OFAgAKgISFC0KFAIjAAAzQy0LBAkAIgkCFQAqFQIXLQsXFBwKFAkAJwIVAQAtCAEUJwIXBAUACAEXAScDFAQBACIUAhcnAhgEBEMDogAJAHwAGAAVABcEKHsCCS0KDgYjAAA8eQwiBnsVJAIAFQAAPJkjAAA8iwAqAhIGLQoGAiMAADL9ACoJBhUOKgkVFyQCABcAADywJQAAW60AIhQCGAAqGAYZLQsZFy0LCBgMKhUPGSQCABkAADzUJQAAW+MtAhgDJwAEBCElAABa0C0IBRkAIhkCGgAqGhUbLQ4XGy0OGQgAKgYSFS0KFQYjAAA8eS0IARQAAAECAS0ODhQEIgJ7FS0KDggjAAA9IQwiCHsYJAIAGAAAPW0jAAA9My0LFAgtCwkULQIUAycABAQRJQAAWtAtCAUVACIVAhgAKhgCGi0OCBotDhUJACoCEggtCggCIwAAMakAKhUIGg4qFRoeJAIAHgAAPYQlAABbrQwqGg8eJAIAHgAAPZ8jAAA9li0IRRgjAAA93wAqGRoeDioZHh8kAgAfAAA9tiUAAFutDCoeGxokAgAaAAA9yCUAAFvjACIEAh8AKh8eIC0LIBotChoYIwAAPd8tCxQaGCoaDB4cChgaBAAqHhoYDioeGB8kAgAfAAA+BCUAAFutLQ4YFAAqCBIYLQoYCCMAAD0hLQsEFAAiFAIULQ4UBAQoegIULQsEFQAiFQIVLQ4VBC0LCBUAIhUCFS0OFQgtCAEVAAABAgEtDggVDCobFBgkAgAYAAA+vCMAAD5hACIUehoOKhQaHiQCAB4AAD54JQAAW60MKhsaHiQCAB4AAD6TIwAAPootCHoYIwAAPrMCKhsUGg4qFBseJAIAHgAAPqolAABb9S0KGhgjAAA+sy0KGAkjAAA+xS0KDgkjAAA+xQAiCXsaDioJGh4kAgAeAAA+3CUAAFutAioaEh4OKhIaHyQCAB8AAD7zJQAAW/UGIh57Gi0KDhgjAAA/AQwqGBoeJAIAHgAAP2QjAAA/Ey0LFQktCwYULQsUFQAiFQIVLQ4VFC0IARUnAhgECQAIARgBJwMVBAEAIgkCGAAiFAIaACIVAh5APwAeABoAGC0OFQYAKgISCS0KCQIjAAAxWi0IAR8AAAECAS0ODh8EIhh7IAYiIHsjCiojGCIkAgAiAAA/jSUAAFwHLQoOHiMAAD+WDCIeeyIkAgAiAAA/9CMAAD+oLQsfHi0LFR8MKhgFICQCACAAAD/CJQAAW+MtAh8DJwAEBBElAABa0C0IBSAAIiACIgAqIhgjLQ4eIy0OIBUAKhgSHi0KHhgjAAA/AQAqIB4jDiogIyQkAgAkAABACyUAAFutDCojCSQkAgAkAABAJiMAAEAdLQhFIiMAAEBmACoUIyQOKhQkJSQCACUAAEA9JQAAW60MKiQbIyQCACMAAEBPJQAAW+MAIgQCJQAqJSQmLQsmIy0KIyIjAABAZi0LHyMYKiMMJBwKIiMEACokIyIOKiQiJSQCACUAAECLJQAAW60tDiIfACoeEiItCiIeIwAAP5YAIh4CIgAqIggjLQsjIC0LHyItAiIDJwAEBOElAABa0C0IBSMAIiMCJAAqJAglLQ4gJQAqCA8gACIGAiQAKiQIJS0LJSIMKiAbJCQCACQAAED0JQAAW+MtAiMDJwAEBOElAABa0C0IBSQAIiQCJQAqJSAmLQ4iJgAiCHogACIJAiMAKiMIJS0LJSIMKiAbIyQCACMAAEE5JQAAW+MtAiQDJwAEBOElAABa0C0IBSMAIiMCJQAqJSAmLQ4iJgAqCBUgACIUAiQAKiQIJS0LJSIMKiAbJCQCACQAAEF+JQAAW+MtAiMDJwAEBOElAABa0C0IBSQAIiQCJQAqJSAmLQ4iJgAiCH4gACIaAiMAKiMIJS0LJSIMKiAbIyQCACMAAEHDJQAAW+MtAiQDJwAEBOElAABa0C0IBSMAIiMCJQAqJSAmLQ4iJgAqCBggACIEAiQAKiQIJS0LJSIMKiAbJCQCACQAAEIIJQAAW+MtAiMDJwAEBOElAABa0C0IBSQAIiQCJQAqJSAmLQ4iJgAqCBkgACICAiMAKiMIJS0LJSIMKiAbIyQCACMAAEJNJQAAW+MtAiQDJwAEBOElAABa0C0IBSMAIiMCJQAqJSAmLQ4iJi0OIx8AKggSIC0KIAgjAAAw4C0LCR4tCwIfLQsUIC0LGiIMKgggIyQCACMAAEKhIwAAQvcAIh8CJAAqJAglLQslIwAiHgIlAColCCYtCyYkACojJCUtAh8DJwAEBAUlAABa0C0IBSMAIiMCJAAqJAgmLQ4lJi0OHgktDiMCLQ4gFC0OIhojAABC9wAqCBIeLQoeCCMAAC7FLQsJHi0LAh8tCxQgLQsaIgwqCCAjJAIAIwAAQycjAABDfQAiHwIkACokCCUtCyUjACIeAiUAKiUIJi0LJiQAKiMkJS0CHwMnAAQEBSUAAFrQLQgFIwAiIwIkACokCCYtDiUmLQ4eCS0OIwItDiAULQ4iGiMAAEN9ACoIEh4tCh4IIwAALh8tCwkfLQsCIC0LFCItCxokDCoIIiUkAgAlAABDrSMAAEQDACIgAiYAKiYIJy0LJyUAIh8CJwAqJwgoLQsoJgAqJSYnLQIgAycABAQFJQAAWtAtCAUlACIlAiYAKiYIKC0OJygtDh8JLQ4lAi0OIhQtDiQaIwAARAMAKggSHy0KHwgjAAAtNBwKCAYAACoCBhovCgAaAAYtCwkaLQIaAycABAQEJQAAWtAtCAUeACIeAh8AKh8IIC0OBiAtDh4JACoIEgYtCgYIIwAALBItCxoJLQsGIC0LHiItCx8kDCoIIiUkAgAlAABEeSMAAETPACIgAiYAKiYIJy0LJyUAIgkCJwAqJwgoLQsoJgAqJSYnLQIgAycABAQFJQAAWtAtCAUlACIlAiYAKiYIKC0OJygtDgkaLQ4lBi0OIh4tDiQfIwAARM8AKggSCS0KCQgjAAArRC0LGgktCwYgLQseIi0LHyQMKggiJSQCACUAAET/IwAARVUAIiACJgAqJggnLQsnJQAiCQInAConCCgtCygmAColJictAiADJwAEBAUlAABa0C0IBSUAIiUCJgAqJggoLQ4nKC0OCRotDiUGLQ4iHi0OJB8jAABFVQAqCBIJLQoJCCMAACqeLQsaIC0LBiItCx4kLQsfJQwqCCQmJAIAJgAARYUjAABF2wAiIgInAConCCgtCygmACIgAigAKigIKS0LKScAKiYnKC0CIgMnAAQEBSUAAFrQLQgFJgAiJgInAConCCktDigpLQ4gGi0OJgYtDiQeLQ4lHyMAAEXbACoIEiAtCiAIIwAAKbMtCwgaAihtAR4OIgFtHyQCAB8AAEYEJQAAW/UMIh5uHyQCAB8AAEYWJQAAW+MAIEwCIAAqIB4iLQsiHxwKHx4ALQsCHwQqHh8gACoaIB4tDh4IBCofERotDhoCACoBEhotChoBIwAAKJstCxoeAiodAR8MKh8PICQCACAAAEZtJQAAW+MAIgICIgAqIh8kLQskIBwKIB8ALQsEIAQqHyAiACoeIh8tDh8aBCogER4tDh4ELQsIHwIofwEgDiIBfyIkAgAiAABGtiUAAFv1DCogDyIkAgAiAABGyCUAAFvjACICAiQAKiQgJS0LJSIcCiIgAAQqIB4iACofIh4tDh4IACoBEh4tCh4BIwAAKCctCwIaACIaAh0AKh0BHi0LHhwcChwaACcCHQEALQgBHCcCHgQFAAgBHgEnAxwEAQAiHAIeJwIfBARDA6IAGgB8AB8AHQAeBCh7ARotCg4EIwAAR0sMIgR7HSQCAB0AAEdrIwAAR10AKgESBC0KBAEjAAAn1wAqGgQdDioaHR4kAgAeAABHgiUAAFutACIcAh8AKh8EIC0LIB4tCwgfDCodDyAkAgAgAABHpiUAAFvjLQIfAycABAQhJQAAWtAtCAUgACIgAiIAKiIdJC0OHiQtDiAIACoEEh0tCh0EIwAAR0stCAEcAAABAgEtDg4cBCIBex0tCg4aIwAAR/MMIhp7HiQCAB4AAEg/IwAASAUtCxwaLQsIHC0CHAMnAAQEESUAAFrQLQgFHQAiHQIeACoeAR8tDhofLQ4dCAAqARIaLQoaASMAACYfACodGh8OKh0fICQCACAAAEhWJQAAW60MIh96ICQCACAAAEhxIwAASGgtCEUeIwAASJUkAgAgAABIfiUAAFvjACICAiIAKiIfJC0LJCAtCiAeIwAASJUtCxwfGCofDCAcCh4fBAAqIB8eDiogHiIkAgAiAABIuiUAAFutLQ4eHAAqGhIeLQoeGiMAAEfzACBsAggAKggCGi0LGgQtCwUILQIIAycABARBJQAAWtAtCAUaACIaAhwAKhwCHS0OBB0AKgIPBAAiAQIcACocAh0tCx0IDCIEehwkAgAcAABJIyUAAFvjLQIaAycABARBJQAAWtAtCAUcACIcAh0AKh0EHi0OCB4tDhwFACoCEgQtCgQCIwAAJWwtCxocAioQAh0OKgIQICQCACAAAElwJQAAW/UMKh0PICQCACAAAEmCJQAAW+MAIh8CIgAqIh0kLQskIBwKIB0ALQsIIAQqHSAiACocIh0tDh0aBCogERwtDhwIACoCEhwtChwCIwAAJJ8cCgUEAAAqAgQaLwoAGgAELQsIGi0CGgMnAAQEBCUAAFrQLQgFHAAiHAIdACodBSAtDgQgLQ4cCAAqBRIELQoEBSMAACQ9LQsIHS0LBCAtCxoiLQscJAwqBSIlJAIAJQAASiYjAABKfAAiIAImAComBSctCyclACIdAicAKicFKC0LKCYAKiUmJy0CIAMnAAQEBSUAAFrQLQgFJQAiJQImAComBSgtDicoLQ4dCC0OJQQtDiIaLQ4kHCMAAEp8ACoFEh0tCh0FIwAAI28tCwgdLQsEIC0LGiItCxwkDCoFIiUkAgAlAABKrCMAAEsCACIgAiYAKiYFJy0LJyUAIh0CJwAqJwUoLQsoJgAqJSYnLQIgAycABAQFJQAAWtAtCAUlACIlAiYAKiYFKC0OJygtDh0ILQ4lBC0OIhotDiQcIwAASwIAKgUSHS0KHQUjAAAiyS0LCB0tCwQgLQsaIi0LHCQMKgUiJSQCACUAAEsyIwAAS4gAIiACJgAqJgUnLQsnJQAiHQInAConBSgtCygmAColJictAiADJwAEBAUlAABa0C0IBSUAIiUCJgAqJgUoLQ4nKC0OHQgtDiUELQ4iGi0OJBwjAABLiAAqBRIdLQodBSMAACHeLQsaBS0LBAgtCxwgLQsdJAwqAiAlJAIAJQAAS7gjAABMDgAiCAImAComAictCyclACIFAicAKicCKC0LKCYAKiUmJy0CCAMnAAQEBSUAAFrQLQgFJQAiJQImAComAigtDicoLQ4FGi0OJQQtDiAcLQ4kHSMAAEwOACoCEgUtCgUCIwAAIDctCxoILQsEIC0LHCQtCx0lDCoCJCYkAgAmAABMPiMAAEyUACIgAicAKicCKC0LKCYAIggCKAAqKAIpLQspJwAqJicoLQIgAycABAQFJQAAWtAtCAUmACImAicAKicCKS0OKCktDggaLQ4mBC0OJBwtDiUdIwAATJQAKgISCC0KCAIjAAAfkS0LGiAtCwQkLQscJS0LHSYMKgglJyQCACcAAEzEIwAATRoAIiQCKAAqKAgpLQspJwAiIAIpACopCCotCyooAConKCktAiQDJwAEBAUlAABa0C0IBScAIicCKAAqKAgqLQ4pKi0OIBotDicELQ4lHC0OJh0jAABNGgAqCBIgLQogCCMAAB6mLQscGi0LBCQtCx0lLQsgJgwqAiUnJAIAJwAATUojAABNoAAiJAIoACooAiktCyknACIaAikAKikCKi0LKigAKicoKS0CJAMnAAQEBSUAAFrQLQgFJwAiJwIoACooAiotDikqLQ4aHC0OJwQtDiUdLQ4mICMAAE2gACoCEhotChoCIwAAHQktCxwaLQsEJC0LHSUtCyAmDCoCJSckAgAnAABN0CMAAE4mACIkAigAKigCKS0LKScAIhoCKQAqKQIqLQsqKAAqJygpLQIkAycABAQFJQAAWtAtCAUnACInAigAKigCKi0OKSotDhocLQ4nBC0OJR0tDiYgIwAATiYAKgISGi0KGgIjAAAcYy0LHCQtCwQlLQsdJi0LICcMKhomKCQCACgAAE5WIwAATqwAIiUCKQAqKRoqLQsqKAAiJAIqACoqGistCyspACooKSotAiUDJwAEBAUlAABa0C0IBSgAIigCKQAqKRorLQ4qKy0OJBwtDigELQ4mHS0OJyAjAABOrAAqGhIkLQokGiMAABt4LQsUGi0LBBwtCx0kLQsgJQwqAiQmJAIAJgAATtwjAABPMgAiHAInAConAigtCygmACIaAigAKigCKS0LKScAKiYnKC0CHAMnAAQEBSUAAFrQLQgFJgAiJgInAConAiktDigpLQ4aFC0OJgQtDiQdLQ4lICMAAE8yACoCEhotChoCIwAAGeMAIhwCJQAqJQImLQsmJC0LFCUtCwQmLQsdJy0LICgKKighKSQCACkAAE90JwIqBAA8BioBCiIneSgkAgAoAABP5CMAAE+GDCIneSgkAgAoAABPmCUAAFvjLQIlAycABAQEJQAAWtAtCAUoACIoAikAKiknKi0OJCoAKicSJA4qJyQlJAIAJQAAT88lAABbrS0OKBQtDiYELQ4kHS0OISAjAABQcC0KDiUjAABP7QwiJXkmJAIAJgAAUH4jAABP/y0LFCUtCwQmLQsgJy0LJigAIigCKC0OKCYtCAEoJwIpBAUACAEpAScDKAQBACImAiknAioEBAAiKAIrPw8AKQArLQIlAycABAQEJQAAWtAtCAUmAComEiktDiQpLQ4mFC0OKAQtDhIdLQ4nICMAAFBwACoCEiQtCiQCIwAAGa4tCxQmLQsEJy0LHSgtCyApDColKCokAgAqAABQoCMAAFD2ACInAisAKislLC0LLCoAIiYCLAAqLCUtLQstKwAqKissLQInAycABAQFJQAAWtAtCAUqACIqAisAKisl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",
      custom_attributes: [
        "abi_public"
      ],
      debug_symbols: "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",
      is_unconstrained: true,
      name: "claim_refund"
    },
    {
      abi: {
        error_types: {
          "10522114655416116165": {
            error_kind: "string",
            string: "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            error_kind: "string",
            string: "extend_from_bounded_vec out of bounds"
          },
          "11019205087382408538": {
            error_kind: "string",
            string: "Field failed to decompose into specified 4 limbs"
          },
          "11021520179822076911": {
            error_kind: "string",
            string: "Attempted to delete past the length of a CapsuleArray"
          },
          "12370419938245003393": {
            error_kind: "string",
            string: "Field failed to decompose into specified 36 limbs"
          },
          "12469291177396340830": {
            error_kind: "string",
            string: "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            error_kind: "string",
            string: "push out of bounds"
          },
          "13060541637244024094": {
            error_kind: "fmtstring",
            item_types: [],
            length: 98
          },
          "13450089406971132036": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 144
          },
          "14942831874215426972": {
            error_kind: "string",
            string: "Invalid destination domain"
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15149532737237392223": {
            error_kind: "string",
            string: "Invalid secret"
          },
          "15711892660910782274": {
            error_kind: "string",
            string: "Hint values do not match hash"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "15835548349546956319": {
            error_kind: "string",
            string: "Field failed to decompose into specified 32 limbs"
          },
          "16216212843441549037": {
            error_kind: "string",
            string: "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "16464709583191233416": {
            error_kind: "string",
            string: "Invalid id"
          },
          "16792019527863081935": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 77
          },
          "17154023812102399658": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 128
          },
          "17803644318014042523": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              }
            ],
            length: 58
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            error_kind: "string",
            string: "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 132
          },
          "344423948968719440": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              },
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              },
              {
                kind: "field"
              }
            ],
            length: 98
          },
          "361444214588792908": {
            error_kind: "string",
            string: "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            error_kind: "string",
            string: "Value does not fit in field"
          },
          "4440399188109668273": {
            error_kind: "string",
            string: "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            error_kind: "string",
            string: "Public data tree index doesn't match witness"
          },
          "5167727358818866312": {
            error_kind: "string",
            string: "Invalid destination settler"
          },
          "6609888949476313245": {
            error_kind: "string",
            string: "Message not in state"
          },
          "7555607922535724711": {
            error_kind: "string",
            string: "Preimage mismatch"
          },
          "755921036432567449": {
            error_kind: "string",
            string: "Not a private order"
          },
          "7564993426627941149": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              },
              {
                kind: "field"
              }
            ],
            length: 48
          },
          "7995966536718645961": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              },
              {
                kind: "field"
              }
            ],
            length: 61
          },
          "8171600539936659379": {
            error_kind: "fmtstring",
            item_types: [],
            length: 92
          },
          "8556029555939094797": {
            error_kind: "fmtstring",
            item_types: [],
            length: 75
          },
          "8992688621799713766": {
            error_kind: "string",
            string: "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            error_kind: "string",
            string: "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            error_kind: "string",
            string: "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            error_kind: "string",
            string: "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            error_kind: "string",
            string: "Attempted to read past end of BoundedVec"
          }
        },
        parameters: [
          {
            name: "inputs",
            type: {
              fields: [
                {
                  name: "call_context",
                  type: {
                    fields: [
                      {
                        name: "msg_sender",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        name: "contract_address",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        name: "function_selector",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        name: "is_static_call",
                        type: {
                          kind: "boolean"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  name: "anchor_block_header",
                  type: {
                    fields: [
                      {
                        name: "last_archive",
                        type: {
                          fields: [
                            {
                              name: "root",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "next_available_leaf_index",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        name: "state",
                        type: {
                          fields: [
                            {
                              name: "l1_to_l2_message_tree",
                              type: {
                                fields: [
                                  {
                                    name: "root",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "next_available_leaf_index",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              name: "partial",
                              type: {
                                fields: [
                                  {
                                    name: "note_hash_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    name: "nullifier_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    name: "public_data_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        name: "sponge_blob_hash",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "global_variables",
                        type: {
                          fields: [
                            {
                              name: "chain_id",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "version",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "block_number",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            },
                            {
                              name: "slot_number",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "timestamp",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 64
                              }
                            },
                            {
                              name: "coinbase",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              name: "fee_recipient",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              name: "gas_fees",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        name: "total_fees",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "total_mana_used",
                        type: {
                          kind: "field"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  name: "tx_context",
                  type: {
                    fields: [
                      {
                        name: "chain_id",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "version",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "gas_settings",
                        type: {
                          fields: [
                            {
                              name: "gas_limits",
                              type: {
                                fields: [
                                  {
                                    name: "da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  },
                                  {
                                    name: "l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              name: "teardown_gas_limits",
                              type: {
                                fields: [
                                  {
                                    name: "da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  },
                                  {
                                    name: "l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              name: "max_fees_per_gas",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              name: "max_priority_fees_per_gas",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  name: "start_side_effect_counter",
                  type: {
                    kind: "integer",
                    sign: "unsigned",
                    width: 32
                  }
                }
              ],
              kind: "struct",
              path: "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            visibility: "private"
          },
          {
            name: "secret",
            type: {
              kind: "field"
            },
            visibility: "private"
          },
          {
            name: "order_id_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "origin_data_bytes",
            type: {
              kind: "array",
              length: 301,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "message_leaf_index",
            type: {
              kind: "field"
            },
            visibility: "private"
          }
        ],
        return_type: {
          abi_type: {
            fields: [
              {
                name: "call_context",
                type: {
                  fields: [
                    {
                      name: "msg_sender",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "contract_address",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "function_selector",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 32
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      name: "is_static_call",
                      type: {
                        kind: "boolean"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                name: "args_hash",
                type: {
                  kind: "field"
                }
              },
              {
                name: "returns_hash",
                type: {
                  kind: "field"
                }
              },
              {
                name: "min_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "is_fee_payer",
                type: {
                  kind: "boolean"
                }
              },
              {
                name: "include_by_timestamp",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 64
                }
              },
              {
                name: "note_hash_read_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              name: "contract_address",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "nullifier_read_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              name: "contract_address",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "key_validation_requests_and_generators",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "request",
                              type: {
                                fields: [
                                  {
                                    name: "pk_m",
                                    type: {
                                      fields: [
                                        {
                                          name: "x",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "y",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "is_infinite",
                                          type: {
                                            kind: "boolean"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    name: "sk_app",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              name: "sk_app_generator",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "note_hashes",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "nullifiers",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "value",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "note_hash",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "private_call_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 8,
                        type: {
                          fields: [
                            {
                              name: "call_context",
                              type: {
                                fields: [
                                  {
                                    name: "msg_sender",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "contract_address",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "function_selector",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "integer",
                                            sign: "unsigned",
                                            width: 32
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    name: "is_static_call",
                                    type: {
                                      kind: "boolean"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              name: "args_hash",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "returns_hash",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "start_side_effect_counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            },
                            {
                              name: "end_side_effect_counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "public_call_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 32,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "msg_sender",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "contract_address",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "is_static_call",
                                    type: {
                                      kind: "boolean"
                                    }
                                  },
                                  {
                                    name: "calldata_hash",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "public_teardown_call_request",
                type: {
                  fields: [
                    {
                      name: "msg_sender",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "contract_address",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "is_static_call",
                      type: {
                        kind: "boolean"
                      }
                    },
                    {
                      name: "calldata_hash",
                      type: {
                        kind: "field"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                name: "l2_to_l1_msgs",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 8,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "recipient",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    name: "content",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "private_logs",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "log",
                                    type: {
                                      fields: [
                                        {
                                          name: "fields",
                                          type: {
                                            kind: "array",
                                            length: 18,
                                            type: {
                                              kind: "field"
                                            }
                                          }
                                        },
                                        {
                                          name: "length",
                                          type: {
                                            kind: "integer",
                                            sign: "unsigned",
                                            width: 32
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    name: "note_hash_counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "contract_class_logs_hashes",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 1,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "value",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "length",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "start_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "end_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "expected_non_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "expected_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "anchor_block_header",
                type: {
                  fields: [
                    {
                      name: "last_archive",
                      type: {
                        fields: [
                          {
                            name: "root",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "next_available_leaf_index",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      name: "state",
                      type: {
                        fields: [
                          {
                            name: "l1_to_l2_message_tree",
                            type: {
                              fields: [
                                {
                                  name: "root",
                                  type: {
                                    kind: "field"
                                  }
                                },
                                {
                                  name: "next_available_leaf_index",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            name: "partial",
                            type: {
                              fields: [
                                {
                                  name: "note_hash_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  name: "nullifier_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  name: "public_data_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      name: "sponge_blob_hash",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "global_variables",
                      type: {
                        fields: [
                          {
                            name: "chain_id",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "version",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "block_number",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 32
                            }
                          },
                          {
                            name: "slot_number",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "timestamp",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 64
                            }
                          },
                          {
                            name: "coinbase",
                            type: {
                              fields: [
                                {
                                  name: "inner",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            name: "fee_recipient",
                            type: {
                              fields: [
                                {
                                  name: "inner",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            name: "gas_fees",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      name: "total_fees",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "total_mana_used",
                      type: {
                        kind: "field"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                name: "tx_context",
                type: {
                  fields: [
                    {
                      name: "chain_id",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "version",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "gas_settings",
                      type: {
                        fields: [
                          {
                            name: "gas_limits",
                            type: {
                              fields: [
                                {
                                  name: "da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                },
                                {
                                  name: "l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            name: "teardown_gas_limits",
                            type: {
                              fields: [
                                {
                                  name: "da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                },
                                {
                                  name: "l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            name: "max_fees_per_gas",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            name: "max_priority_fees_per_gas",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            kind: "struct",
            path: "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          visibility: "databus"
        }
      },
      bytecode: "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rhd42tfb6tD2rp729S60lGnKS0E1rujaHy7f2dvmqT8ucuiPOk/ft7zYQaYGTzJd4iDTqZ5kutRBpkWe7g9c5imGXu4J5wpPOFd6wvmYJ5yrPOFc7QnnGk8413rCuc4TzvWecG7whHOjJ5ybPOF83BPOJzzhfNITzs2ecD7lCefTnnA+4wnns55wbvGEc6snnM95wvm8J5wveML5oiecL3nCuc0Tzu2ecL7sCecrnnC+6gnnDk84d3rCucsTztc84XzdE87dnnC+4QnnHk8493rC+aYnnG95wvm2J5zveML5riec+zzh3O8J53uecL7vCecHnnB+6AnnAU84P/KE8+MSvDf3oNC9IEmZfuJJJpd7Zj8Vkikfzs8cbOSwSj8y/dxBpo4l+E3RX3iyp632OOEvS9DGf+XJxh9ysKetnu53/tpBpsWe7nf+xtO49FtPOA97wvmdJ5z/84TziCec33vCedQTzh884fzRE85jnnD+5Annz55wHveE8xdPOE94wnnSE85TnnCe9oTzjCecZz3h/NUTznOecJ73hPM3Tzh/94TzgiecFz3hvOQJ5x+ecF72hPOKJ5x/esJ51RPOa55wXveE84YnnH95wnnTE85bnnDe9oTzjiecdz3h/NsTzn884bznCee/nnDe94TzP084H3jC+dATjtp0tixLKrrhhJ5wyjzhlHvCyXjCaeUJp8ITTmtPOJWecKo84bTxhNPWE061J5x2nnDae8LJesLp4AmnoyecTp5wOnvCqfGE08UTzl6ecLp6wunmCae7J5wennD29oTT0xNOL084+3jC6e0JJ+cJp48nnH094fT1hNPPE85+nnD6e8IZ4AlnoCecQZ5wBnvCGeIJZ6gnnGGecIZ7wtnfE84ITzgHeMIZ6QnnQE84B3nCOdgTzihPOId4whntCedQTziHecI53BPOGE84R3jCOdITzlhPOLWecMZ5wjnKE854TzgTPOEc7QlnoiecYzzhHOsJ5zhPOMd7wjnBE84kTziTPeFM8YQz1RPONE84J3rCme4JZ4YnnJmecGZ5wpntCWeOJ5yTPOGc7AnnFE84p3rCmesJZ54nnNM84cz3hFPnCWeBJ5yFnnDqEY7pHezXPvzww0JwFnlqT4MnnMWecJZ4wjndE85STzhneMJZ5glnuSecMz3hnOUJZ4UnnJWecM72hLPKE85qTzhr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",
      custom_attributes: [
        "abi_private"
      ],
      debug_symbols: "TL3LjjU9j5x7L9+4B0sHUpRvZQ+M7X0wGmi4AR9GDd+7KxkiIyb9PvH3VwqllMGVK5OV9R///L//33/5X//1P//rf/v///1//POf/q//+Oe//Pd//bd/+9f/+p//7d//n//7f/7rv/+3v//1P/75ff9n7H/+0/Rh//tf/hmpPfX+0/PT/vdfjX/5xwf+mfhn4Z+Nfwz/OP45+Cfwz81/DkY5GOVglINRDkY5GOVglINRDkY5GCUwSmCUwCiBUQKjBEYJjBIYJTBKYJSLUS5GuRjlYpSLUS5GuRjlYpSLUS5GGb/f+3e8f+f7d71/9/vX3r/+/j3v33j/vvHGG2+88cYbb7zxxhtvvPHGG2+88cYbb7zx5htvvvHmG2++8eYbb77x5htvvvHmG2/+jbf+/l2/9+94/8737994/v2737/2/v0b737/fuPlfxgF98H+FYyCWfDN8nywC6zAC76R44MouA/sG/mbvY2CWfA38twf7AIr8IJTEAX3wZcHwCiYBTWy18heI3um6oNTEAX3wZcRwCiYBatgF1hBjXxq5FMjnxo5auSokaNGjho5auSokaNGjho5auSokW+NfGvkL0/z24IvUYBdYAVecAqi4ALmFy/AKJgFq2AXWIEXnIIoqJFHjTxq5FEjjxp51MijRh418qiRR408auRZI88aedbIs0aeNfKskWeNPGvkWSPPGnnVyKtGXjXyqpFXjbxq5FUjrxp51cirRt418q6Rd428a+RdI+8aedfIu0beNfKuka1GthrZamSrka1GthrZauQvg2t8EAX3wZdBwCiYBatgF1iBF9TIXiN7jfxlcO0PRsEs+Ea+H+wCK/CCUxAF98GXQcAomAU1ctTIUSPHq0gzTkEUvIo0769gFMyCVbALrKBGvjXyrZG/DO75L/+sL4OAUTALVsEusAIvOAVRUCOPGnnUyKNG/jK41we7wAq84BREwX3wZRAwCmZBjTxr5Fkjfxm03wenIArugy+DgFEwC1bBLrCCGnnVyKtGXjXyrpF3jbxr5F0j7xp518i7Rt418q6Rd41sNbLVyFYjW41sNbLVyFYjW41sNbLVyF4je43sNbLXyF4je43sNbLXyF4je418auRTI58a+dTIp0Y+NfKpkU+NfGrkUyNHjRw1ctTIUSNHjRw1ctTIUSNHjRw18q2Rb418a+RbI98a+dbIt0a+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56NzPjrno3M+Ouejcz4656NzPjrno3M+Ouejcz4656NzPjrno3M+Ouejcz4656NzPjrno3M+Ouejcz4656NzPjrno3M+Ouejcz4656NzPjrno3M+Ouejcz4656NzPjrns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4757NzPjvns3M+O+ezcz4756tzvjrnq3O+Ouerc74656tzvjrnq3O+Ouerc74656tzvjrnq3O+Ouerc74656tzvjrnq3O+Ouerc74656tzvjrnq3O+Ouerc74656tzvjrnq3O+Ouerc74656tzvjrnq3O+Ouerc74656tzvjrnq3O+Ouerc74656tzvjrnq3O+Ouerc74656tzvjrnq3Oe3Ug+kqLpFn0592wv/nL+aDatpt1kTd50mqLpFp32OO1x2uO0x2mP0x6nPU57nPY47RHtEe0R7RHtEe0R7RHtEe0R7RHtcdvjtsdtj9setz1ue9z2uO1x2+OWRzYuPRpNs2k17SZr8qbTFE3tMdpjtMdoj9Eeoz1Ge4z2GO0x2mO0x2yP2R6zPWZ7zPaY7THbY7bHbI/ZHqs9Vnus9ljtsdpjtcdqj9Ueqz1We+z22O2x22O3x26P3R67PXZ77PbY7WHtYe1h7WHtYe1h7WHtYe1h7WHt0TnfnfPdOd+d82x8ckuyJm86TdF0izLnoNE0m1ZTe5z2OO1x2uO0x2mPaI9oj2iPaI9oj2iPaI9oj2iPaI/bHrc9bnvc9rjtcdvjtsdtj9setzyyOerRaJpNq2k3WZM3naZoao/RHqM9RnuM9hjtMdpjtMdoj9Eeoz1me8z2mO0x22O2x2yP2R6zPWZ7zPZY7bHaY7XHao/VHqs9Vnus9ljtsdpjt8duj90euz12e+z22O2x22O3x24Paw9rD2sPaw9rD2sP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ul26XbrddssmyMJBnMRF3EQjOvEQg0i3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt0031pJgLQnWkmAtCdaSYC0J1pJgLQnWkmAtCdaSYC0J1pJgLQnWkmAtCdaSYC0J1pJgLQnWkmAtCdaSYC0J1pJgLQnWkmAtCdaSYC0J1pJgLQnWkmAtCdaSYC0J1pJgLQnWkmAtCdaSYC0J1pJgLQnWkmAtCdaSYC0J1pJgLQnWkmAtCdaSYC25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCUXtWQnOvEQg3gbUUuAgziJi7iJdFt0W3RbdFt023TbdNt023TbdNt023TbdNt023QzuhndjG5GN6Ob0c3oZnQzuhndnG5ON6eb083p5nRzujndnG5Ot0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3oFvQLegWdAu6Bd1QSzzxEIOYbt/V9kUtAQ7iJC7iJhrRiYcYxHJbv9+POIiTuIibaEQnHmIQ6TboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbpZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG6Hboduh26Hboduh26Hboduh26HbkG3oFvQLegWdAu6Bd2CbkG3oNul26Xbpdul26Xbpdul26XbpRtryWAtGawlg7VksJYM1pLBWjJYSwZryWAtGawlg7VksJYM1pLBWjJYSwZryWAtGawlg7VksJYM1pLBWjJYSwZryWAtGawlg7VksJYM1pLBWjJYSwZryWAtGawlg7VksJYM1pLBWjJYSwZryWAtGawlg7VksJYM1pLBWjJYSwZryWAtGawlg7VksJYM1pLBWjJYSwZryWAtGawlg7VksJYM1pLBWjJYSwZryWAtGawlg7VksJYM1pLBWjJYSwZryWAtGawlg7VksJYM1pLBWjJYSwZryWAtGawlg7VksJYM1pLBWjJYSwZryWAtGawlg7VksJYM1pLBWjJYSwZryWAtGawlg7VksJZM1pLJ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TZeaLjVdarrUdKnpUtOlpkutLLWy1MpSK0utLLWy1MpSK0utLLWy1OpSq0utLrW61OpSq0utLrW61OpSq0utLbW21NpSa0utLbW21NpSa0utLbU21cJxHLAD7Ag7wc6wBbbCLrArbOgG6AboBugG6AboBugG6AboBugG6EboRuhG6EboRuhG6EboRuhG6EboJugm6CboJugm6CboJugm6CboJuhm6GboZuhm6GboZuhm6GboZuhm6Ap0BboCXYGuQFegK9AV6Ap0BboKXYWuQlehq9BV6Cp0FboKXYVugW6BboFugW6BboFugW6BboFugW6FboVuhW6FboVuhW6FboVuhW6FboNug26DboNug26DboNug26DLngVwKsAXgXwKoBXAbwK4FUArwJ4FcCrAF4F8CqAVwG8CuBVAK8CeBXAqwBeBfAqgFcBvArgVQCvAngVwKsAXgXwKoBXAbwK4FUArwJ4FcCrAF4F8CqAVwG8CuBVuHjVut11Hyu/z2I7YAfYEXbXfazxPu0Mu+s+1m+ddtd9LFc+7QK7wu66jw/i8xEdsLuu9piDV5edYHdd7XkZvLrsrvs4SuO0C+wKu+uWns7Bq8vuurWnbfCq9vQMXl121629HAavLrvr1p6GwavLrrC7bu1lPnh12V239TQMXl12gv3QbUdPW+fV09Zu97R1Xj3th257fBc/TpJbdufV0w7dTt2OsNNfrlssTrvrhp6GzqunrbC7buzp6bx62l039pidV087wO66sT/Tzqun3XVTL9vOq6etsLtu6unsvHraXfexJepsvl33sRHotAPsrvv4kj/tBLvrPj7rT1tgK+yu29tR7Lx62l33cZzViYoDdoDddXsbiZ1XT7vr9nYRO6+edtd9fMGfdoFdYXfdxwLpx8lKsLtur/Ox8+ppJ9gZdtctPS+dV0+76/Z2ETuvWm8LsfPqsjuvnnbX7e0idl497a7b20LsvHraArvr9nYRU4HddXtbiJ1Xl9159bTDY3Fibxfxwatpp273tD14ddo9PQ9eTVu73cvhwatp1273NDx49bQfvJp21+1tKkqE3XV7W4iSYQvsrht72qTA7rqxp03asrXrPjbZn3aAHWF33dTrqmbYXXe0C+26oy1ogV1hd93RLsoBu+uOtlAi7AS76452UQR21x1toRTYFXbXHe2iHrC77mgXtev290WsCXbX1V5WVWB33f6OiLXArrC77mhT7YDddfs7IrYIO8HuuqONNIHddUe7aAV21229nrQ27XQcsMNY7tvtCDuNtbzd7rqP7VCn3XUfu4sfFx/A7rq9jaSjwm7LDgfsodu6HWEn2Lkv/j26LbAVdul27naF3brd0//g1Wn39D94dYr333nwatoJdoYtsBV2gV1ht2WnrtvfcSkF2BF2gp1hC2yFXWBX2G3ZGboZuhm6GboZuhm6nVd9I8JpF9gVdlt259XTDrAj7AQ7wxbY0BXoCnQFugpdha5CV4durw+aYQvsrpvG7xfYFXZbdufV0w6wI+wEO8MW2NAt0C3QLdCt0K3QrdCt0K3QrdCt0K3QrdCt0G3QbdBt0G3QbdBt0G3QbdBt0G1Lty9EnnaAHWEn2Bm2wFbYBXaFDd0A3QDdAN0A3cGrx9bnkAevLrvr6vidrvuYOAl58Kr3o/Lg1bAHry676z7mUUIevLrsBLvrPibyQh68umyF3XUfe6hCHrzq/bE8eDXswavLHrql21239r8dvGrj5xn20G3dfujGo6e/8+ppV9ht2Z1XTzvAjrAT7AxbYEM3QzdDN0NXoCvQFegKdAW6Al2BrkBXoCvQVegqdBW6Cl2FrkJXoavQVegqdAt0C3QLdAt0C3QLdAt0C3TL0E3dbsvuvOp73ENf2TztCDvBzrAFtsIusCvstuwG3QbdBt0G3QbdBt0G3QbdBt22dPti52kH2BF2gp1hC2yFXWBX2NAN0A3QDdAN0A3QDdAN0A3QDdAN0I3QjdCN0I3QjdCN0I3QjdCN0I3QTdBN0E3QTdBN0E3QTdBN0E3QTdDN0M3QzdDN0M3QzdDN0M3QzdDN0BXoCnQFugJdga5AV6Ar0BXoCnQVugpdha5CV6Gr0FXoKnQVugrdAt0C3QLdAt0C3QLdAt0C3QLdAl3wSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvBLwSsArAa8EvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErBa8UvFLwSsErvXil3e66j4NBgw5eXXaAHWF33T7up4NXl911+/evDl49zlkLOnh12RX20H3083Xw6rK7buoxB68uO8Huun1cXQevLrvrPlZABh28uuwKu+v2cb8yeHXZXbeP+5XBqz7fVAavLrvrPlZNhjJ4ddldt883lcGry66wu24fMyyDV5fddfs8URm8uuwEu+v2cb8yeHXZXbeP+5XBq8vuun2srwxeDXvw6rK7bh/3K4NXl911Hzv4Qxm86t9rZfDqshV21+3j4WXw6rK7busxB68uO8Duuo+j9EIZvLrsh27q3wJ9Xfe0FXbpdk9n59XTbt3uaeu8SkdPT+fV047d7mXVefW0u27oaei8etoKu+v2dtQXeU+76/Z5or7Me9oBdtftbaSv9J521+3toq/1nnbX7fNEfbX3tCvsrtvHyfuC72l33V7n+5LvaSfYGXbXzT0vnVdPu+uOdtF5lUZb6Ly67M6rp911R7vovHraXXe0hc6rpy2wu+5oF51XT7vrjrbQeXXZnVdPu+uOdtF59bS77mgXnVepj4f0leDT7rqll0Pn1dPuun0co68Gf9qdV0+764421Xn1tLvuaAudV09bYHfdPmfUV4VPu+v2cfW+Lvyy+8Lwc1D26HaAHWGnbsduZ9jSbem2drt0u8CusFu3H+npS8Sn3XV7W+iLxKedYHfd3i76OvFpd93eFvpK8WlX2F23t4u+WHzaXbe3i75c/LR7ejqvnnbXTb2sOq+edtft74i+ZnzaFXbX7W2qLxufdtft74i+cHzaCXbX7W2krx2fdtft7aKvHp921+3zRH39+NPuvHraXbeP9fUl5NPuun3+qC8iP+1ebp1Xuc8f9WXk0+66vY30heTTbsvuvHraQ7fnXSLsBHvo9jyKwFbYXbe3o76kfNpt2Z1XTzvAjrAT7AxbYCts6Cp0FboFugW6BboFugW6BboFugW6BboFuhW6FboVuhW6FboVuhW6FboVuhW6DboNug26bej2OtAybIE9dHsdaAV2hd2m3QavLjvMOG3w6rIT7IzfF9gKu8CusKEboBugG6AboBsybIEN3QDdAN0A3QjdwavLjrATbOQ3Qnfw6rIL7Aq7LTtBN0E3QTdBN0E3oZwT8puQ34T8JugOXl02yjmjnDPKOUM3QzdDN0M3QzejnAX5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V1K3C+wKuy178OqyA+wIO8HOsAU2dBt0G3Tb0r3Wt192gB1hJ9gZtsBW2AV2hQ3dAN0A3QDdAN0A3QDdAN0A3QDdAN0I3QjdCN0I3QjdCN0I3QjdCN0I3QTdBN0E3QTdwSst3e665ei2wi6wK+y27MGryw6wI+wEO8OGboZuhm6GboauQFegK9AV6Ap0BboCXYGuQFegq9BV6Cp0FboKXYWuQlehq9BV6BboFugW6A5e1f58B68uW2Ar7AK7wm7LHry67AA7woZuhW6FboVuhW6FboVug26DboNug26DboNug26DboNuW7rX+vbLDrAj7AQ7wxbYCrvArrChG6AboBugG6AboBugG6AboBugG6AboRuhG6EboRuhG6EboRuhG6EboZugm6CboJugm6CboJugm6CboJugm6GboZuhm6GboZuhm6GboZuhm6Er0BXoCnQFugJdga5AV6Ar0BXoKnQVugpdha5CV6Gr0FXoKnQVugW6BboFuuBVBa8qeFXBqwpeVfCqglcVvKrgVQWvKnhVwasKXlXwqoJXFbyq4FUFryp4VcGrCl5V8KqCVxW8quBVBa8qeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAqwZeNfCqgVcNvGrgVQOvGnjVwKsGXjXwqoFXDbxq4FUDrxp41cCrBl418KqBVw28auBVA68aeNXAq2t9e5Vud93HeYn5Wt9+2Qq7wH7oniM23W7d7jE7r5526LZ2O8JOsHO3a7cF9kP3HAnpdoHddeP4na6bHn3Fsb79aXfdPg4w1rc/7a6bepzOq3MkodtdN7dud10Zv1NgV9jtactY3/60A+wIO8HOsAW2wi6wK2zoBugG6AboBugG6AboBugG6AboBuhG6EboRuhG6EboRuh2Xp2jE90usCvsrlvaw+68etoBdtet/fc7r/RRn2Wsb3/aXbeWbnfdOv62wO667eh2W3bn1dMOsLvu4yxZGevbn3aGLbC7buvp7Lw6Rye6XWG3ZXdeXemXoZu7HWEn2Bm24G8VdoENXRm68p9//cv/+tu//8vf/s+///P/+Mt/+d+n+3//z3/9p//4l3/718v9j//3vz//5f/893/5+9//5f/5b//93//tn/75//qf//7P/+3v//ZPj3/7y/H4z6N6/h/niH8M//X85bB+1P4a8+NH8frV85fOCay/nv/V+l//+pc0fqL9J6WdP7kinZPLjx+l4/GjMH5U9fGjWh/x0iPe469j/mvKz787x5yyPP45zxTE8Neojx/J/FFqf809UfoMksNfJTyDSPyrlMc/l+/ZqCtu/mtsjx+1FfdMSv9ROJ65jWewWMKV01b/Go761Inn78fUnhmMOZ0iPfUhPP/+nPP/6zknfv19lHpmZgZITf6aj1lC+cin2/Ma4jNn6fH3s3jOXxgJTP/goWW7SMM/KMAwSzC2v6b2/W+KFfM///O//uf/Bw==",
      is_unconstrained: false,
      name: "claim_refund_private",
      verification_key: "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"
    },
    {
      abi: {
        error_types: {
          "14415304921900233953": {
            error_kind: "string",
            string: "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "9967937311635654895": {
            error_kind: "string",
            string: "Initialization hash does not match"
          }
        },
        parameters: [
          {
            name: "l2Gateway",
            type: {
              fields: [
                {
                  name: "inner",
                  type: {
                    kind: "field"
                  }
                }
              ],
              kind: "struct",
              path: "aztec::protocol_types::address::eth_address::EthAddress"
            },
            visibility: "private"
          },
          {
            name: "l2GatewayDomain",
            type: {
              kind: "integer",
              sign: "unsigned",
              width: 32
            },
            visibility: "private"
          },
          {
            name: "forwarder",
            type: {
              fields: [
                {
                  name: "inner",
                  type: {
                    kind: "field"
                  }
                }
              ],
              kind: "struct",
              path: "aztec::protocol_types::address::eth_address::EthAddress"
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public",
        "abi_initializer"
      ],
      debug_symbols: "tZ3bbl23robfxde50Ik65FWKokjbdCFAkBZZyQY2irz7En/xMN1iKMqc9k38+bcnh0RRlEQNI38//f7+16//+eXDpz/+/O/T25/+fvr184ePHz/855ePf/727suHPz9N9e+nwP/EVJ/e5jdPMcent42/zu/L/FqCfKX1leR7Kk9vY2QYE1ipWaELNFWaKl2VMc1EYqAFKQSFojAEoiqxC6SswMpsb8pZoESFKsBNToGhKAyBqkpVpanSp50UGaoAt3kBKYwFmdu8gJXpxxybQEoKbKdOYBcvIAF28gJVSBVShd2bGkMXaGx5MDSBPpXMzeA2A0ZUEKWwnxcUhSEQVWE/5zlMhRu/oAlkVbIqRRVuc+4MRYEtz4YV9vMCVTg2FnSBrkpXZagy2gIKUaEKxKBACvIISkVBDBKHRJmDS9yeEhnmj8p0L7EzFzSBrkpXZajCzmSo7MwFpDAE2JkL+BFzvGoeAiUr6I9IFVKlqlKbQIsKVaAHBVLQR4yiwAbnTGkhKTSBGBVIIAWFoqAf5/m1QD9e9OPwKgOpAvfOAGjsQwoM83doOrxxQC4YCzrHIYCnDM2Z0nleUGEYAuyxBU2An7WgCtTZeKoMRWEINFWaKl2VrsoQZfCYUmIoCl0gJgV+6HTvSFGB29wZhgB7bEETYI9V/jh7DMBTZgEJVFWqKk0V7sWCLsBTZkET4BBdwI/gRB64P0KkFE2LpiXTePSFuhL3Rqgp8cwX4qd1Jg7XRRyvQvbTblo3bZjGeVVoCEUeBKGuFLORPi1yphJiy5UpByMyGkocU0JdiZKRWanRyKxUs4JBAWEMZpaJif3cImj+XktMnA4WcUuFmhIvAI3XxcQJoPHCmGoyqkocC0LFaChxOLQGakocEEKq5ZCMTIumRdN4lW3YFKClIOwPFpERt4B9n0sx4n6wNzLntkXsSaHZo84eyhwlvYBYY09mjhIh0p/y4ivEWsfWJBh1JY4NodnmEZjY4yOCmhK3fhH7Hh/gxo8B6krceCHTqmnVNF4+hKoSd0OIlLgbQrypCdw+LF2KwzD5LyRXs6vZVY5lxWbI0axYDXkUFP3BHFmK7IcO6kocWkJNiSeuUBXCgihUjIZSzEZqpWJwQAVdS8BuSNnR1epqdbUlx2rYoyMZYgcqiAdnYFfEgqlYDdeo8HRrBb9QgdWQgmNx7Iar6QsxVtz51qJjNeyudleHq8PUHqIj7HKY9Rgdq2FyNZFhDo7Y3gdgN0SPBashr10RZ4GOw8BCdFOQmxPZ1R0jtJB3L4qkOIIN4Qg2hCNGR1dTcCTHoYOFJVixGeKEsBDtxWiO1nRYxvL6QnIchiM76sDOA0ySAZhYDWN0dDW5mlzNrmZXV5wNYDWk6OhqDY7kOGSwUsCZTLAZoscLMS/4jDYRQbCOYkMxIrgWxmSIAcBxCwvrXA6BzRDtFSTHYViLIzsVp7CIgBFsht3V7upwdZiaQnJEKPNgpdX0hdUQESXIzcEpLyGiFiKiUgHiEdzehBHiE1hap86F6LGgq9XV6irSr2BxHIY4OQt2w9VjtBeZAJiRCQTZ1Xw6SziaCuJALehqcjW5ih4LNkP0WLAaoseCeDABhyHGWNDV5mpzFT0WbIbosWBVLOixoD248C5XEY/IwG6IMoJgM8QsFKyGJTi6sTIMyY2RG6vJsKFlPCw42UY+IiecbSOfTmedIhmupi8kQ1Q7+NyacJSd+xlGrDiCxbEbog2CzRArTilAMkRWFnR1uDpMxWKv6CoSXkFRBU0XHIbwuiCawyNUc3JE39g7FV4XJENylVytriLOBLvhqkctbIbIJYL+YKyxwLYKUigO8WYl8mlzIlvgo19qaDrhdzFFiAdrbQ/qqik1Q3IVSYEPa6lhhCoP7Fr9McZtjcXC4mhB0DAZKgdXjxYEfXkdmFzF7K4FOAyzq1jnKw8AjtvysWIB0yk5uop8Jmgx2ZurzZuD2b2w+yO6GxtmYaBDfLKaSIbJ1dWhDuyGGAvBaogw4sPZRDLEjBXshhiLxiM0MAANlT5MhoWYvIIoPyYu/GHyCjbD6CqWmYVY/QVdxfaLT1QTybC4il3xQjRdsBliLATdAlzNJ8QckSdbBZLjMIzZsRki7AXR3s642ruQDIurxVVylVytriJ2+HA4z5/BkQy7q5gMgsPQhiWv1R+YVo8XkiGWAy5dZKkgs3cSYkewGq4OLeSP9YBirrkkVXNUaq5iHnc8DbsrQVeRU3sC2ligpLwQRWVFV32EMlayhcnVZM3BYV2RHN1YcQvoEG/gMk7nghgLweLIH+scXGsR5l1bXouwoKuYx3xyn0iGyVXM407AYR/L2bEbFldtazmL5snR1erNqeToj2hurLuFdaIi1OCDY3HshpjdHWX6rMe+iWRYXF2x04DDkFxFCuLSRSY7Iua1YC9sydFVO6xMrIbD1eHNGXqEyTVkRzNWo1mo2Tpfc3G0ztd1LFlY1Q9r5V0Wqj+tubpiZ11kZEdXsajBD3VYy1qIjtbIFl2N1s2WguONas1pOTv6I4obI7fAHeLS3KSuxCMhVJWQnzquY4bU8HJnLwuZhqDhwlRGxVswuYoUO3CNg2obPoVqG6gEI9eGEhUj06q1gqNpUTPLzax0+yzWtcG5aSBQBF1dnSjAagjHCxZHfIztrgP5QnhbsBrC8YMdP7BxGxwSAzN1IcJdEB/jQBnIpYIkWFD5ViyOwzC6ilzKlbkSkEsFXcWKsHA1fSE5DkNyC+znuQgxdtwxJty4ZcemiNVZkQxjcMTlZAF2w5QdXc2uZleLq8XVdTFKwG6IG0dBV3HrKNgMbVgmkuMwHDqEZR3IR2bk2FnewdFbsTh2w4wHV0YylyQyR6Xq6rrXxdPWzS6wudpgl0ceJ2v5WLexwMla0dTsI5RDNYyuRnK04c4pO7qx7Ba4Q3z1NakYdSVemoXwEQ6sjBssXMT2oTRM4wmcuKAzz63Z0VWewInLcwWFclo3udGoKmXT9Fqu4Cws5Jq2AgdhIbNczUqzz3ZcmifgMByurk6sq+XkWA0xNQTxMQIOQ3h7IcJHEBY4krD+Jt7UTByGtRki3CMus1s1XC8HLHR1vSCwkBRxSlbE03APjhcFFkZX8bKAYDPECwOC5OgW2M+JC1SlcjafFSvgMESMCzZD3iQoVsWG9nKJq+DkqzgMo6vR1eRqcjW7ipccEgGL4zAkV5GFFiILCdqwoFyuSI42hDglp8iTpiN24J2O2FmI2BEsjngwh0bP5pJeoqOryEL8JkZBCVywuoosxBXCgqto+VjLjt3QR6j7CHVkIUFTR4iO5GiPGNGMjWQWxuoQ3qdAh3IAVkNyFR0SHIbo0ELMC8G2XqYoWJyFqtIwjecEXrrAwizkGr+6EL99e/Okbyf98uXz+/f8ctLN60o//f3017vP7z99eXr76evHj2+e/u/dx6/4pf/+9e4Tvn5593n+dLbs/aff59dp8I8PH98zfXvjnw7XH531xiGfnoe/YQbmgfeZiXhtYh4SufAAG3wd08xIp2c20rWNPNc2EhuZy3VXNnZd6VGbMVe0eNmVsjFRUPsSd8zDuTejP7NBL+CO+rrumPv1qCZ6r5fu6JuuDN65LG+EmN1Eys9MjBfwRgwv4I5NX/iWyfrSxmVfYtqFR7MIm4dgt/GP6OBUfO2QGMwfdWPjuB350sapO26j45/u2ERpqxod82hoFko6bgNuqlYb5rXydRv6LjS4sLIiY1Y5rt05du3wHDi329c2TtuxsXHqjh4v3ZHSKw7JvJVyV1zP+LRLooECWWxRKpfrwSaLcvFKA5SrV9eLyr4l9aYlPdxp5GaqUL9MPmkXHqQRlm+y1zyOnQ8M+cC0fjkweZNGCRcwsEHxJhPPEvGxjcRvqVmUxnzp0py2E+4mytrl0pTzCwTItiHJ1sh5O0zXDaFdMg6WjOdm3myM8tzELpEO80efVyc+MPR84vLcvBxcCuoOonRj4wcsNAuP2zD/AQs1afqZWO6ykIdZmL2/sLDx5SxDBvNlbZe+LLss2mzP0vpNWPzLxi4+SZ1ZbkZ03vc+t7BLPKiLyiy52Zr/y8YmOCmZO2+m6g9ZGBqa9cYTP9SPlL0fJd1no0XLwW3Xk/G6NubVne3e6k0a/iEbreksmbd51/6gXYQWja5W6l0WRtGVcd4H32UhhqSNmNcH17FBm+iaRQhtxiwsuC/iOHfnCBrjs15/7c79qhZ8rs1V7a4DRgq+i9xs32hsk4aGxrxouj6k1PD4YlLjo2l414rTNFzz42m4lkfTcKXH03Ctj6bhrYWjNLztx2Ea3to4TKEtvK6N0zS8tXGYhlt+NA3vLJyl4Z2F0zTc6sNpeOvOwzS8zaDDjhb5trySzk3kkbyceX1M6i9wTNo1oyQ74Myboetm7JbXgdse82i6XJN2u9BULTomX5+SvtMSqwpM7uPSyPZAbxEWb44ndJdL6bpY1NsrVkeKTZPZhuuiWR+v6Ifsy1G5PTv/ow27cmrwyvC8h/c2PHfE2ITEDGpbV8tNQMw63nMbu9gMxZtRNzbK49uMQY9vM0Z9dJsx2uPbjNEf3WZsLRxtM7b9SF5MzeF6HYhhd6VEVgrlP/K610i1FYn6uNNI9mVt1ng3Rsqj24StibN9wtbE6UYhhvbwTuE7Pi22sGW6d3SzherEfp+RF+lNtBTEf11736Q53BPH3c3Sixg53VnvjRxureP2duls0uxMHE6anYnjSbO7YDoNs61PD/fX21Wbgq4xc/3ulytu3F0xzZs6uw/hPwa9rJXEtFv8+b1TuzBr/XJ3u++PXQHMdtRNfzbL/7BDRwzB95Vp7u+e29hFybyQtdHht2l8E1H/6ZRNGuC/alcradwYGf0H2kLBbmgm34TKv9uye40heJIOtV77ZVdXO91axRwf3VvF/YXT2eYq7m6cznZXexNH26t9Vw7LOHsjp0tFbq9s5Hi92Ro5XW9KeHi92Zk4XG92Jo7Xm93d0+l6s/Xpi6w3luP5jdLr/Fy270Llahe9sxBRL9ebsulO7vYmQO5tk+a/0xTLAZn/Avi6KbsKQKwx+cH35r2qH3i5a0Q7O4+xeW2PNom1ktqo7fpVj7i9Azp+vYu2VarD97v23ek2gcPmZaLdddT53obqC+xtvhMmLZtTZmPoXit2lH7ISmluheq9VuwdBbZyHSx1ux1oxS7JqPVy3ZZdqg7an5HuzfZWJh6NHl4w2r37gRzsHc0c472bisOiTX2B0sDOxulh+jtGbGRi7HSnkdP6wtbIaR1rb+SwjrXvzmEdqz1ex2qP17HaS9Sx2msH62kda+uQs0S0NXGWiA6HZWdiW2w568jWxFlHDks+OxPh8REJj49IeHhEtlfLR/3YWjjqxuH1drvztYXD9W3/6sPh8jZe4FC1s3G8vO2NHC5vWyOny9vWyOnytjdyuLztu3O2vKXwcAVga+JseduaOF3eUnjtYD1c3vYOOUpCexNHWeh0WDYmtq9LHvVja+GoG4evbLY7X8U9TKb713nPkmmKj8fn1sZpMv2OkbNkujdymEz3Rg6T6XeMnCXT73TnMJmmx5NpejyZppdIpum1g/U0mabHk2l6PJmmh5Pp/q88iv2tSqX7/tLECoZU67O/NPl5fvPutw+fn/3HD9/Y1OcP7379+F6+/ePrp99ufvrl///Sn+h/HPHX5z9/e//718/v2ZL/7xHzn59mLIU3MbTx85unuITSp0CZhQhhXuXNf+jnb9yk/wE=",
      is_unconstrained: true,
      name: "constructor"
    },
    {
      abi: {
        error_types: {
          "11238168246423926608": {
            error_kind: "string",
            string: "Order fill expired"
          },
          "12469291177396340830": {
            error_kind: "string",
            string: "call to assert_max_bit_size"
          },
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14942831874215426972": {
            error_kind: "string",
            string: "Invalid destination domain"
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "16070420376462343922": {
            error_kind: "string",
            string: "Not a public order"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "16464709583191233416": {
            error_kind: "string",
            string: "Invalid id"
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          },
          "7335179940076463214": {
            error_kind: "string",
            string: "Invalid status"
          }
        },
        parameters: [
          {
            name: "order_id_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "origin_data_bytes",
            type: {
              kind: "array",
              length: 301,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "filler_data_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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uicAVQJKJwBWAuonAFcCLycAWALsJwBZAkYnAFoCiycAWwILJwBcAkwnAF0CHScAXgKIJwBfAg0nAGACQCcAYQIlJwBiApInAGMCnicAZALrJwBlAmEnAGYCXS0AAWcnAGgEIQAAAWgBJwFnBAEAAGcCaC0AaGktBElpAABpAmktBEppAABpAmktBEtpAABpAmktBExpAABpAmktBE1pAABpAmktBE5pAABpAmktBE9pAABpAmktBFBpAABpAmktBFFpAABpAmktBFJpAABpAmktBFNpAABpAmktBFRpAABpAmktBFVpAABpAmktBFZpAABpAmktBFdpAABpAmktBFhpAABpAmktBFlpAABpAmktBFppAABpAmktBFVpAABpAmktBFtpAABpAmktBFxpAABpAmktBF1pAABpAmktBF5pAABpAmktBF9pAABpAmktBGBpAABpAmktBGFpAABpAmktBGJpAABpAmktBGNpAABpAmktBGRpAABpAmktBGVpAABpAmktBGZpAABpAmktBF9pKAAAaAQBLSkAAGkE/////ykAAGoEagnmZykAAGsEu2euhSkAAGwEPG7zcikAAG0EpU/1OikAAG4EUQ5SfykAAG8EmwVojCkAAHAEH4PZqykAAHEEW+DNGS0AAXInAHMECQAAAXMBJwFyBAEAAHICcy0Ac3QtBGp0AAB0AnQtBGt0AAB0AnQtBGx0AAB0AnQtBG10AAB0AnQtBG50AAB0AnQtBG90AAB0AnQtBHB0AAB0AnQtBHF0JwBzBAMnAHQEQCcAdQQEKAAAdgQBACkAAHcEgAAAACcAeASAJwB5BA4mJQAARt8eAgAFAB4CAAYALQgBBwAAAQIBLQ4GBy0IAQYAAAECAScCCAAGLQ4IBh4CAAgAHgIACQAzKgAIAAkACicCCAEBJAIACgAADVElAABHBS0LAQkAIgkCCS0OCQEtCAEJAAABAgEnAgoAAS0OCgktCAELAAABAgEtDEULJwIMBAAnAg0EICcCDgQfKAIADwABACcCEAQBLQoMBCMAAA2hDCoEDQUkAgAFAABGdiMAAA2zLQsLBS0LAgkAIgkCCS0OCQItCwIJACIJAgktDgkCLQgBCScCCwQhAAgBCwEnAwkEAQAiCQILJwIRBCAAKhELES0KCxIOKhESEyQCABMAAA4SLQxDEgAiEgISIwAA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",
      custom_attributes: [
        "abi_public"
      ],
      debug_symbols: "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",
      is_unconstrained: true,
      name: "fill"
    },
    {
      abi: {
        error_types: {
          "10522114655416116165": {
            error_kind: "string",
            string: "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            error_kind: "string",
            string: "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            error_kind: "string",
            string: "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            error_kind: "string",
            string: "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            error_kind: "string",
            string: "push out of bounds"
          },
          "13060541637244024094": {
            error_kind: "fmtstring",
            item_types: [],
            length: 98
          },
          "13450089406971132036": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 144
          },
          "14942831874215426972": {
            error_kind: "string",
            string: "Invalid destination domain"
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "16464709583191233416": {
            error_kind: "string",
            string: "Invalid id"
          },
          "16792019527863081935": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 77
          },
          "17154023812102399658": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 128
          },
          "17803644318014042523": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              }
            ],
            length: 58
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 132
          },
          "344423948968719440": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              },
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              },
              {
                kind: "field"
              }
            ],
            length: 98
          },
          "361444214588792908": {
            error_kind: "string",
            string: "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            error_kind: "string",
            string: "Value does not fit in field"
          },
          "4440399188109668273": {
            error_kind: "string",
            string: "Input length must be a multiple of 32"
          },
          "7555607922535724711": {
            error_kind: "string",
            string: "Preimage mismatch"
          },
          "755921036432567449": {
            error_kind: "string",
            string: "Not a private order"
          },
          "7564993426627941149": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              },
              {
                kind: "field"
              }
            ],
            length: 48
          },
          "7995966536718645961": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              },
              {
                kind: "field"
              }
            ],
            length: 61
          },
          "8171600539936659379": {
            error_kind: "fmtstring",
            item_types: [],
            length: 92
          },
          "8556029555939094797": {
            error_kind: "fmtstring",
            item_types: [],
            length: 75
          },
          "8992688621799713766": {
            error_kind: "string",
            string: "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            error_kind: "string",
            string: "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            error_kind: "string",
            string: "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            error_kind: "string",
            string: "Attempted to read past end of BoundedVec"
          }
        },
        parameters: [
          {
            name: "inputs",
            type: {
              fields: [
                {
                  name: "call_context",
                  type: {
                    fields: [
                      {
                        name: "msg_sender",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        name: "contract_address",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        name: "function_selector",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        name: "is_static_call",
                        type: {
                          kind: "boolean"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  name: "anchor_block_header",
                  type: {
                    fields: [
                      {
                        name: "last_archive",
                        type: {
                          fields: [
                            {
                              name: "root",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "next_available_leaf_index",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        name: "state",
                        type: {
                          fields: [
                            {
                              name: "l1_to_l2_message_tree",
                              type: {
                                fields: [
                                  {
                                    name: "root",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "next_available_leaf_index",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              name: "partial",
                              type: {
                                fields: [
                                  {
                                    name: "note_hash_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    name: "nullifier_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    name: "public_data_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        name: "sponge_blob_hash",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "global_variables",
                        type: {
                          fields: [
                            {
                              name: "chain_id",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "version",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "block_number",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            },
                            {
                              name: "slot_number",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "timestamp",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 64
                              }
                            },
                            {
                              name: "coinbase",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              name: "fee_recipient",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              name: "gas_fees",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        name: "total_fees",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "total_mana_used",
                        type: {
                          kind: "field"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  name: "tx_context",
                  type: {
                    fields: [
                      {
                        name: "chain_id",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "version",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "gas_settings",
                        type: {
                          fields: [
                            {
                              name: "gas_limits",
                              type: {
                                fields: [
                                  {
                                    name: "da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  },
                                  {
                                    name: "l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              name: "teardown_gas_limits",
                              type: {
                                fields: [
                                  {
                                    name: "da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  },
                                  {
                                    name: "l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              name: "max_fees_per_gas",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              name: "max_priority_fees_per_gas",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  name: "start_side_effect_counter",
                  type: {
                    kind: "integer",
                    sign: "unsigned",
                    width: 32
                  }
                }
              ],
              kind: "struct",
              path: "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            visibility: "private"
          },
          {
            name: "order_id_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "origin_data_bytes",
            type: {
              kind: "array",
              length: 301,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "filler_data_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          }
        ],
        return_type: {
          abi_type: {
            fields: [
              {
                name: "call_context",
                type: {
                  fields: [
                    {
                      name: "msg_sender",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "contract_address",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "function_selector",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 32
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      name: "is_static_call",
                      type: {
                        kind: "boolean"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                name: "args_hash",
                type: {
                  kind: "field"
                }
              },
              {
                name: "returns_hash",
                type: {
                  kind: "field"
                }
              },
              {
                name: "min_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "is_fee_payer",
                type: {
                  kind: "boolean"
                }
              },
              {
                name: "include_by_timestamp",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 64
                }
              },
              {
                name: "note_hash_read_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              name: "contract_address",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "nullifier_read_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              name: "contract_address",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "key_validation_requests_and_generators",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "request",
                              type: {
                                fields: [
                                  {
                                    name: "pk_m",
                                    type: {
                                      fields: [
                                        {
                                          name: "x",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "y",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "is_infinite",
                                          type: {
                                            kind: "boolean"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    name: "sk_app",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              name: "sk_app_generator",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "note_hashes",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "nullifiers",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "value",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "note_hash",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "private_call_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 8,
                        type: {
                          fields: [
                            {
                              name: "call_context",
                              type: {
                                fields: [
                                  {
                                    name: "msg_sender",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "contract_address",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "function_selector",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "integer",
                                            sign: "unsigned",
                                            width: 32
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    name: "is_static_call",
                                    type: {
                                      kind: "boolean"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              name: "args_hash",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "returns_hash",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "start_side_effect_counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            },
                            {
                              name: "end_side_effect_counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "public_call_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 32,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "msg_sender",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "contract_address",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "is_static_call",
                                    type: {
                                      kind: "boolean"
                                    }
                                  },
                                  {
                                    name: "calldata_hash",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "public_teardown_call_request",
                type: {
                  fields: [
                    {
                      name: "msg_sender",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "contract_address",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "is_static_call",
                      type: {
                        kind: "boolean"
                      }
                    },
                    {
                      name: "calldata_hash",
                      type: {
                        kind: "field"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                name: "l2_to_l1_msgs",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 8,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "recipient",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    name: "content",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "private_logs",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "log",
                                    type: {
                                      fields: [
                                        {
                                          name: "fields",
                                          type: {
                                            kind: "array",
                                            length: 18,
                                            type: {
                                              kind: "field"
                                            }
                                          }
                                        },
                                        {
                                          name: "length",
                                          type: {
                                            kind: "integer",
                                            sign: "unsigned",
                                            width: 32
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    name: "note_hash_counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "contract_class_logs_hashes",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 1,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "value",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "length",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "start_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "end_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "expected_non_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "expected_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "anchor_block_header",
                type: {
                  fields: [
                    {
                      name: "last_archive",
                      type: {
                        fields: [
                          {
                            name: "root",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "next_available_leaf_index",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      name: "state",
                      type: {
                        fields: [
                          {
                            name: "l1_to_l2_message_tree",
                            type: {
                              fields: [
                                {
                                  name: "root",
                                  type: {
                                    kind: "field"
                                  }
                                },
                                {
                                  name: "next_available_leaf_index",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            name: "partial",
                            type: {
                              fields: [
                                {
                                  name: "note_hash_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  name: "nullifier_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  name: "public_data_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      name: "sponge_blob_hash",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "global_variables",
                      type: {
                        fields: [
                          {
                            name: "chain_id",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "version",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "block_number",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 32
                            }
                          },
                          {
                            name: "slot_number",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "timestamp",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 64
                            }
                          },
                          {
                            name: "coinbase",
                            type: {
                              fields: [
                                {
                                  name: "inner",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            name: "fee_recipient",
                            type: {
                              fields: [
                                {
                                  name: "inner",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            name: "gas_fees",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      name: "total_fees",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "total_mana_used",
                      type: {
                        kind: "field"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                name: "tx_context",
                type: {
                  fields: [
                    {
                      name: "chain_id",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "version",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "gas_settings",
                      type: {
                        fields: [
                          {
                            name: "gas_limits",
                            type: {
                              fields: [
                                {
                                  name: "da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                },
                                {
                                  name: "l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            name: "teardown_gas_limits",
                            type: {
                              fields: [
                                {
                                  name: "da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                },
                                {
                                  name: "l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            name: "max_fees_per_gas",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            name: "max_priority_fees_per_gas",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            kind: "struct",
            path: "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          visibility: "databus"
        }
      },
      bytecode: "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",
      custom_attributes: [
        "abi_private"
      ],
      debug_symbols: "TJ3LjjW7bqTf5Yx7sHQhKflVetDoOwwYNtCXkdHv3pUMkRET/18c71IopQyuXJmsrH//x3/77//l//7P//TP//o//u1//+Of/uO//+O//K9//pd/+ef/+Z/+5d/+63/+P//8b//697/++z9+3/8Z+x//NC3u//sP/xipPfX50/PT6/7jn8Z/+Mf+4Z+Bfyb+Wfhn4x/DP45/Av8c/INRDKMYRjGMYhjFMIphFMMohlEMoxhGcYziGMUximMUxyiOURyjOEZxjOIYJTBKYJTAKIFRAqMERgmMEhglMEpglINRDkY5GOVglINRDkY5GOVglINRDka5GOVilItRLka5GOVilItRLka5GOVilPH7vX/H+3e+f9f7d79/7f3r7994/5737xtvvPHGG2+88cYbb7zxxhvvO3fW92+8f8/79+Lf+Teef/+O9+98//6Nd79/v/HyP7QCL4iCU3AfrG+W8cEomAWr4Bv5fGAFXvCN/M1+nYL74Dvp5/5gFMyCVbALrMALouAU3AdWI1uNbDXyF4f5rcoXCIAVeEEUnIL74AsHYBTMghrZa2Svkb1G9hrZa2SvkaNGjho5auSokaNGjho5auSokaNG/iI0vy34QgQYBbNgFewCK/CCKDgFNfKtkW+NfGvkWyPfGvnWyLdGvjXyrZHvG3n+fgWjYBasgl1gBV4QBaegRh418qiRR408auRRI48aedTIo0YeNfKokWeNPGvkWSPPGnnWyLNGnjXyrJFnjTxr5FUjrxp51cirRl418qqRV428auRVI68aedfIu0beNfKukXeN/GVwjQ+8IApOwX3wZRAwCmbBKtgFNbLVyFYjfxlc+4P74Msg4Bv5fjALVsEusAIviIJTcB98GQTUyFEjR40cryLNsAIviIJT8CrSPL+CUTALVkGNfGrkUyN/Gdzzg1NwH3wZBIyCWbAKdoEVeEGNfGvk+0Zev1/BN/L6YBasgl1gBV4QBafgPvgyCKiRR408auQvg/b7wAq8IApOwX3wZRAwCmbBKqiRZ408a+RZI88aedbIq0ZeNfKqkVeNvGrkVSOvGnnVyKtGXjXyrpF3jbxr5F0j7xp518i7Rt418q6Rd41sNbLVyFYjW41sNbLVyFYjW41sNbLVyF4je43sNbLXyF4je43sNbLXyF4je40cNXLUyFEjR40cNXLUyFEjR40cNXLUyKdG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dcI4PmjitqKJZX4J+UYjw7i3vQsd2WYzc5V33cYzUsasESNZt7G3ova2G5fI9m8h6zZur3I6J77LTZEh2NKIq+QRpP+y34JKwmnZJze4zMdh/4LzmFf/0UIP7t1+tW9oarWrPy3FuzRt3JF9uOdO5Mbp5UtfDbYQ5QlDlKccP8nMAl9hEQv8Lu362gzz3IgjZntN2wvFP+3wT//yl7//81//9V/+9B9/+de//fvjL1PdHqeoj/XWvkV4fD4OXlON9pnsM9un2KfaZ7HPap9tfLbNPi21Zqk1S61Zas1Sa5Zas9SapdZGannb7DPYZ7TPZJ/ZPsU+1T6LfVb7tNSCpRYstWCpBUstWGrBUguWWrDUgqUWLLVoqUVLLVpq0VKLllq01KKlFi21aKlFSy1ZaslSS5ZastSSpZYstWSpJUstWWrJUsuWWrbUsqWWLbVsqWVLLVtq2VLLllq21MRSE0tNLDWx1MRSE0tNLDWx1MRSE0tNLTW11NRSU0tNLTW11NRSU0tNLTW11IqlViy1YqkVS61YasVSK5ZasdSKpVYstWqpmZZk05JsWpJNS7JpSTYtyaYl2bQkm5Zk05JsWpJNS7JpSTYtyaYl2bQkm5Zk05JsWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYloipiViWiKmJWJaIqYlYlqipiVqWqKmJWpaoqYlalqipiVqWqKmJWpaoqYlalqipiVqWqKmJWpaoqYlalqipiVqWqKmJWpaoqYlalqipiVqWqKmJWpaoqYlalqipiVqWqKmJWpaoqYlalqipiVqWqKmJWpaoqYlalqipiVqWqKmJWpaoqYlalqipiVqWqKmJWpaoqYlalqipiVqWqKmJWpaoqYlalqipiVqWqKmJWpaoqYlalqipiVqWqKmJWpaoqYlalqi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",
      is_unconstrained: false,
      name: "fill_private",
      verification_key: "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"
    },
    {
      abi: {
        error_types: {
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          },
          "6938571148302402705": {
            error_kind: "string",
            string: "Function get_order_refund_block_number can only be called statically"
          }
        },
        parameters: [
          {
            name: "order_id",
            type: {
              kind: "field"
            },
            visibility: "private"
          }
        ],
        return_type: {
          abi_type: {
            kind: "field"
          },
          visibility: "public"
        }
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public",
        "abi_view"
      ],
      debug_symbols: "tZldbhs7DIX34mc/SBRFSdlKURRu6hYGDCdwkwtcFNl7yRkejR1ghNRJXuLPdOYM/0Rp7D+bH/vvz7++HU4/H35v7r782Xw/H47Hw69vx4f73dPh4aTWP5tgf6r+TdtNzZu7st00fRejvurbyNtNDGYoBlWhKsTkQBEgmzvSi2JSC5FBc2BWaAbNISdAdRBYBJYCSykONQLEwTydIQP0FilsN0QBwAB8lGBJsDAsXB0yAYqDRIA4FNyiZIAFqNmgmgDVoRFAZkghAjLAL0+RAbBQAhSHRABYxKIgg+pgOZwBlgpLhcUcm0FmYHNshuwQA8BukQyqAxFAHKZkZgWxj8RAHKaMTcCA6jA5NoElXMPhFgEyQw4RAEuEJcJCsFiikrZEtoacQRwYFs4OOQDUMQ4G1cGimEEcrNwcDZqDOT+D3pQ1UdmyaiC2dmbIDuQJl8lDgxQBXgJhWNhLIDkAvASSvQQiBPASSPUSlOAlKMFLUGIAMMBLUCgBvAQlRYCntzAsDEuGJcMisIiXoJQI8BKUCkv1EpQWAF6C0rwENRDAS1CjJZMNrAQaabVlPoGtixmKg6WOdXxVWxesjtVCAHGwCTgDA5pD07Rku2krMzTzZwZYIiwRFoKFYEnWJGJQHCyZM2SA3jRPo5cB6nPWmjabkDPAYs5PYMnM6mqbus4muC0ZniZ2CJ24kynYtAzk8cdgpXbqNtZrJUyUQbnbzEWJEzVcYU46VVDpNpvkM1Xq1G2te2DT3AnK6hYo4tppz7E21+0odOJOFcR6hdhOFMW7XymDSrfZVJI0UQPVbrOJKbYdxpZwhbXERISVptRt03SaSUDUbZQ7NVBKnboK92sFUZJwJ0RJ1tRO4vFSY1zbcI8UuFP12JLt507dZh08xTvtOfMVKXaCV4m7jRFRyqHTYuseSOrUlUtXmQ4j8vKy3eCg8u3pvN/bOeXi5KLnmcfdeX962tydno/H7ea/3fF5+qffj7vT9Pq0O+un2qv70w99VcGfh+Pe6GW7XB3WL6VUm19NHFoX0MxdScR1iagzq7qGcildpOYrDVrXSJRzdg3lEtc0RqHUCDf0KBJXQ+GBBMccejp02Sxu1CuN/AHpkM9Nh55WiktwymU1HXUQClm7zpFQlkWC0pVE+4BsxPAB6RjFogMAfqSUVmOJ9BHBpE8ORidhL0xbL0wc9GmpPZbSiFdDGbWpnsehodzeG4pqrIYyag9NIrzIra7PsEGfkp5d+spviWV1iI0c0SeW7klKzDcs28tg9GS9GkwYpZQK9/ZIcWnTTNexDNpUnzLgR9YHwy6he/+1xmCcxozxoWeHrqC737XCqEnL0qR6Il40Xkcy6tKMBuO4lJXkur+oDJojNuRCH7rbukYd5RP7bE7hNoWGeS4XmfinOGjZ7NNFRV5rpNFunwnrJGYuN2pI6xq13aahXyX0uUF1XWPQn4XRGYXlJoXGGOX6FHOTgj6g9PkXZL2uaVBXrhFucM1LXWP7h3RyHxmXp4V/K0nvUMV6k8ZHhBL7JNfnonrbSimxj64yWK+cPlcjivRYpNTbNErpJx/d6dc15L0rZaTwtpUyUnjrSuH27vYaprMtg0e/Allvr9Hmqs/mfXMttLq5Zhq2Ri+r1Iv2ehXL2w8KidYOCnn0zES0bI6XzfHKjzzY5nWWJziinPPawSmP9vlAy2k0UF09necyOizI4ol+H7oqMuz1gDnY6MbVImj1VvJ719tAYbi3vSmKocKbonjj/vpa4au+3d0fzle/9byY1Pmw+37c+9ufz6f7i0+f/n/EJ/it6PH8cL//8Xzem9Lyg5H++aJfJG31d4mv9j2dvtWvFbbUir2N9inZp/L1xZz5Cw==",
      is_unconstrained: true,
      name: "get_order_refund_block_number"
    },
    {
      abi: {
        error_types: {
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          },
          "90719278298450020": {
            error_kind: "string",
            string: "Function get_order_settlement_block_number can only be called statically"
          }
        },
        parameters: [
          {
            name: "order_id",
            type: {
              kind: "field"
            },
            visibility: "private"
          }
        ],
        return_type: {
          abi_type: {
            kind: "field"
          },
          visibility: "public"
        }
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public",
        "abi_view"
      ],
      debug_symbols: "tZldbhs7DIX34mc/SJRISdlKURRu6hYGDCdwkwtcFNl7yRkejR1ghNRJXuLPdOYM/0Rp7D+bH/vvz7++HU4/H35v7r782Xw/H47Hw69vx4f73dPh4aTWP5tgf6r+TdtN5c1d2W6avotRX/VtzNtNDGYoBlWhKsTkQBEgmzvSi2JSC5FBc8hZoRk0B06A6iCwCCwFllIcagSIg3k6AwP0FilsN0QBkAH4KMGSYMmw5OrABCgOEgHiUHCLwgALULNBNQGqQyOAzJBCBDDAL08xA2ChBCgOiQCwiEVBBtXBcjgDLBWWCos5NoPMkM2xGdghBoDdIhlUByKAOEzJZAWxj8RAHKaMTZAB1WFybAJLuIaTWwTIDBwiAJYIS4SFYLFEJW0JtoacQRwyLJkdOADUsRwMqoNFMYM4WLlzNGgO5vwMetOsiWLLqoHY2pmBHcgTLpOHBikCvASSYcleAuEA8BIIewlECOAlkOolKMFLUIKXoMQAyAAvQaEE8BKUFAGe3pJhybAwLAyLwCJeglIiwEtQKizVS1BaAHgJSvMS1EAAL0GNlsxsYCXQSKst8wlsXcxQHCx1WcdXtXWR1bFaCCAONgFnyIDm0DQtbDdtZYZm/swAS4QlwkKwECzJmkQMioMlcwYG6E15Gr0ZoD6z1rTZhJwBFnN+Aksmq6tt6jqb4LZk8jSxQ+iUO5mCTctAHn8MVmqnbst6rYSJGMTdZi5KnKjhCnPSqYJKt9kkn6lSp25r3QOb5k5QVrdAEddOe461uW5HoVPuVEFZrxDbiaJ49ysxqHSbTSVJEzVQ7TabmGLbYWwJV1hLTERYaUrdNk2nmQRE3UbcqYFS6tRVcr9WECVJ7oQoyZraSTxeahnXNtwjhdypemzJ9nOnbrMOnuKd9pz5ihQ7wauUuy0josSh02LrHkjq1JVLV5kOI/Lyst3goPLt6bzf2znl4uSi55nH3Xl/etrcnZ6Px+3mv93xefqn34+70/T6tDvrp9qr+9MPfVXBn4fj3uhlu1wd1i+lVJtfTTm0LqCZu5KI6xJRZ1Z1DeVSukjlKw1a10jEzK6hXOKaxiiUGuGGHkXiaih5IJEjh54OXTaLG/VKgz8gHfK56dDTSnGJnLispqMOQiFr1zkSYlkkKF1JtA/IRgwfkI5RLDoA4EdKaTWWSB8RTPrkYHQS9sK09cLEQZ+W2mMpjfJqKKM21fM4NJTbe0NRjdVQRu2hSYQX3Or6DBv0KenZpa/8lrKsDrGRI/rE0j1JKecblu1lMHqyXg0mjFKauSzrNixuMF3HMmhTfcqAH6wPhl1C9/5rjcE4jYzxoWeHrqC737XCqEnL0qR6Il40Xkcy6lJGg+W4lJXkur+oDJojNuRCH7rbukYd5RP7LKdwm0JDUeUiE/8UBy2bfbqoyGuNNNrtmbBOIudyo4a0rlHbbRr6VUKfG1TXNQb9WTI6o2S5SaFljHJ9irlJQR9Q+vwLsl7XNKhrrhFu5MpLXWP7h3Tas6ank28sa+odqlhv0viIUGKf5PpcVG9bKSX20VUG6zWnz9WIIj0WKfU2jVL6yUd3+nUNee9KGSm8baWMFN66UnJ7d3sN09mWwaNfgay312hz1WfzvrkWWt1cmYat0csq9aK9XsXy9oNCbGsHBR49MxEtm+Nlc7zygwfbvM7yhPGjzLx2cOLRPh9oOY0Gqquncy6jw4Isnuj3oasiw14PyGqjG1eLoNVb4feut4HCcG97UxRDhTdF8cb99bXCV327uz+cr37reTGp82H3/bj3tz+fT/cXnz79/4hP8FvR4/nhfv/j+bw3peUHI/3zRb9I2urvEl/tezp9q18rbKkVexvtU7JP5euLOfMX",
      is_unconstrained: true,
      name: "get_order_settlement_block_number"
    },
    {
      abi: {
        error_types: {
          "10701657982931684311": {
            error_kind: "string",
            string: "Function get_order_status can only be called statically"
          },
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          }
        },
        parameters: [
          {
            name: "order_id",
            type: {
              kind: "field"
            },
            visibility: "private"
          }
        ],
        return_type: {
          abi_type: {
            kind: "field"
          },
          visibility: "public"
        }
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public",
        "abi_view"
      ],
      debug_symbols: "tZldbhs7DIX34mc/SJRISdlKURRu6hYGDCdwkwtcFNl7yRkejR1ghNRJXuLPdOYM/0Rp7D+bH/vvz7++HU4/H35v7r782Xw/H47Hw69vx4f73dPh4aTWP5tgf6r+TdtN5c1d2W6avotRX/VtzNtNDGYoBlWhKsTkQBEgmzvSi2JSC5FBc8hZoRk0B06A6iCwCCwFllIcagSIg3k6AwP0FilsN0QBkAH4KMGSYMmw5OrABCgOEgHiUHCLwgALULNBNQGqQyOAzJBCBDDAL08xA2ChBCgOiQCwiEVBBtXBcjgDLBWWCos5NoPMkM2xGdghBoDdIhlUByKAOEzJZAWxj8RAHKaMTZAB1WFybAJLuIaTWwTIDBwiAJYIS4SFYLFEJW0JtoacQRwyLJkdOADUsRwMqoNFMYM4WLlzNGgO5vwMetOsiWLLqoHY2pmBHcgTLpOHBikCvASSYcleAuEA8BIIewlECOAlkOolKMFLUIKXoMQAyAAvQaEE8BKUFAGe3pJhybAwLAyLwCJeglIiwEtQKizVS1BaAHgJSvMS1EAAL0GNlsxsYCXQSKst8wlsXcxQHCx1WcdXtXWR1bFaCCAONgFnyIDm0DQtbDdtZYZm/swAS4QlwkKwECzJmkQMioMlcwYG6E15Gr0ZoD6z1rTZhJwBFnN+Aksmq6tt6jqb4LZk8jSxQ+iUO5mCTctAHn8MVmqnbst6rYSJGMTdZi5KnKjhCnPSqYJKt9kkn6lSp25r3QOb5k5QVrdAEddOe461uW5HoVPuVEFZrxDbiaJ49ysxqHSbTSVJEzVQ7TabmGLbYWwJV1hLTERYaUrdNk2nmQRE3UbcqYFS6tRVcr9WECVJ7oQoyZraSTxeahnXNtwjhdypemzJ9nOnbrMOnuKd9pz5ihQ7wauUuy0josSh02LrHkjq1JVLV5kOI/Lyst3goPLt6bzf2znl4uSi55nH3Xl/etrcnZ6Px+3mv93xefqn34+70/T6tDvrp9qr+9MPfVXBn4fj3uhlu1wd1i+lVJtfTTm0LqCZu5KI6xJRZ1Z1DeVSukjlKw1a10jEzK6hXOKaxiiUGuGGHkXiaih5IJEjh54OXTaLG/VKgz8gHfK56dDTSnGJnLispqMOQiFr1zkSYlkkKF1JtA/IRgwfkI5RLDoA4EdKaTWWSB8RTPrkYHQS9sK09cLEQZ+W2mMpjfJqKKM21fM4NJTbe0NRjdVQRu2hSYQX3Or6DBv0KenZpa/8lrKsDrGRI/rE0j1JKecblu1lMHqyXg0mjFIaY+jtobtNF2G6jmXQpvqUAT9YHwy7hO791xqDcRoZ40PPDl1Bd79rhVGTlqVJ9US8aLyOZNSljAbLcSkryXV/URk0R2zIhT50t3WNOson9llO4TaFhnkuF5n4pzho2ezTRUVea6TRbs/Ue4tzuVFDWteo7TYN/Sqhzw2q6xqD/iwZnVGy3KTQMka5PsXcpKAPKH3+BVmvaxrUNdcIN3Llpa6x/UM67VnT08k3ljX1DlWsN2l8RCixT3J9Lqq3rZQS++gqg/Wa0+dqRJEei5R6m0Yp/eSjO/26hrx3pYwU3rZSRgpvXSm5vbu9hulsy+DRr0DW22u0ueqzed9cC61urkzD1uhllXrRXq9ieftBgdPaQYFHz0xEy+Z42Ryv/ODBNq+zPGH8KDOvHZx4tM8HWk6jgerq6ZzL6LAgiyf6feiqyLDXA+ZgoxtXi6DVW+H3rreBwnBve1MUQ4U3RfHG/fW1wld9u7s/nK9+63kxqfNh9/2497c/n0/3F58+/f+IT/Bb0eP54X7/4/m8N6XlByP980W/SNrq7xJf7Xs6fatfK2ypFXsb7VOyT+XriznzFw==",
      is_unconstrained: true,
      name: "get_order_status"
    },
    {
      abi: {
        error_types: {
          "10342230159609614507": {
            error_kind: "string",
            string: "Invalid fill deadline"
          },
          "10886555653199409003": {
            error_kind: "string",
            string: "Invalid nonce"
          },
          "12469291177396340830": {
            error_kind: "string",
            string: "call to assert_max_bit_size"
          },
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14658772241615233463": {
            error_kind: "string",
            string: "Invalid sender"
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "16070420376462343922": {
            error_kind: "string",
            string: "Not a public order"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "17366381410802578161": {
            error_kind: "string",
            string: "Invalid origin domain"
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "3154441984421085216": {
            error_kind: "string",
            string: "Invalid data type"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          }
        },
        parameters: [
          {
            name: "order",
            type: {
              fields: [
                {
                  name: "fill_deadline",
                  type: {
                    kind: "integer",
                    sign: "unsigned",
                    width: 32
                  }
                },
                {
                  name: "order_data_type",
                  type: {
                    kind: "array",
                    length: 32,
                    type: {
                      kind: "integer",
                      sign: "unsigned",
                      width: 8
                    }
                  }
                },
                {
                  name: "order_data",
                  type: {
                    kind: "array",
                    length: 301,
                    type: {
                      kind: "integer",
                      sign: "unsigned",
                      width: 8
                    }
                  }
                }
              ],
              kind: "struct",
              path: "types::onchain_cross_chain_order::OnchainCrossChainOrder"
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public"
      ],
      debug_symbols: "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",
      is_unconstrained: true,
      name: "open"
    },
    {
      abi: {
        error_types: {
          "10342230159609614507": {
            error_kind: "string",
            string: "Invalid fill deadline"
          },
          "10522114655416116165": {
            error_kind: "string",
            string: "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            error_kind: "string",
            string: "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            error_kind: "string",
            string: "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            error_kind: "string",
            string: "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            error_kind: "string",
            string: "push out of bounds"
          },
          "13060541637244024094": {
            error_kind: "fmtstring",
            item_types: [],
            length: 98
          },
          "13450089406971132036": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 144
          },
          "14658772241615233463": {
            error_kind: "string",
            string: "Invalid sender"
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "15835548349546956319": {
            error_kind: "string",
            string: "Field failed to decompose into specified 32 limbs"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "16792019527863081935": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 77
          },
          "17154023812102399658": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 128
          },
          "17366381410802578161": {
            error_kind: "string",
            string: "Invalid origin domain"
          },
          "17803644318014042523": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              }
            ],
            length: 58
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 132
          },
          "3154441984421085216": {
            error_kind: "string",
            string: "Invalid data type"
          },
          "344423948968719440": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              },
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              },
              {
                kind: "field"
              }
            ],
            length: 98
          },
          "361444214588792908": {
            error_kind: "string",
            string: "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            error_kind: "string",
            string: "Value does not fit in field"
          },
          "4440399188109668273": {
            error_kind: "string",
            string: "Input length must be a multiple of 32"
          },
          "7555607922535724711": {
            error_kind: "string",
            string: "Preimage mismatch"
          },
          "755921036432567449": {
            error_kind: "string",
            string: "Not a private order"
          },
          "7564993426627941149": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              },
              {
                kind: "field"
              }
            ],
            length: 48
          },
          "7995966536718645961": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              },
              {
                kind: "field"
              }
            ],
            length: 61
          },
          "8171600539936659379": {
            error_kind: "fmtstring",
            item_types: [],
            length: 92
          },
          "8556029555939094797": {
            error_kind: "fmtstring",
            item_types: [],
            length: 75
          },
          "8992688621799713766": {
            error_kind: "string",
            string: "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            error_kind: "string",
            string: "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            error_kind: "string",
            string: "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            error_kind: "string",
            string: "Attempted to read past end of BoundedVec"
          }
        },
        parameters: [
          {
            name: "inputs",
            type: {
              fields: [
                {
                  name: "call_context",
                  type: {
                    fields: [
                      {
                        name: "msg_sender",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        name: "contract_address",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        name: "function_selector",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        name: "is_static_call",
                        type: {
                          kind: "boolean"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  name: "anchor_block_header",
                  type: {
                    fields: [
                      {
                        name: "last_archive",
                        type: {
                          fields: [
                            {
                              name: "root",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "next_available_leaf_index",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        name: "state",
                        type: {
                          fields: [
                            {
                              name: "l1_to_l2_message_tree",
                              type: {
                                fields: [
                                  {
                                    name: "root",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "next_available_leaf_index",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              name: "partial",
                              type: {
                                fields: [
                                  {
                                    name: "note_hash_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    name: "nullifier_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    name: "public_data_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        name: "sponge_blob_hash",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "global_variables",
                        type: {
                          fields: [
                            {
                              name: "chain_id",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "version",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "block_number",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            },
                            {
                              name: "slot_number",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "timestamp",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 64
                              }
                            },
                            {
                              name: "coinbase",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              name: "fee_recipient",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              name: "gas_fees",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        name: "total_fees",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "total_mana_used",
                        type: {
                          kind: "field"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  name: "tx_context",
                  type: {
                    fields: [
                      {
                        name: "chain_id",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "version",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "gas_settings",
                        type: {
                          fields: [
                            {
                              name: "gas_limits",
                              type: {
                                fields: [
                                  {
                                    name: "da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  },
                                  {
                                    name: "l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              name: "teardown_gas_limits",
                              type: {
                                fields: [
                                  {
                                    name: "da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  },
                                  {
                                    name: "l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              name: "max_fees_per_gas",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              name: "max_priority_fees_per_gas",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  name: "start_side_effect_counter",
                  type: {
                    kind: "integer",
                    sign: "unsigned",
                    width: 32
                  }
                }
              ],
              kind: "struct",
              path: "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            visibility: "private"
          },
          {
            name: "order",
            type: {
              fields: [
                {
                  name: "fill_deadline",
                  type: {
                    kind: "integer",
                    sign: "unsigned",
                    width: 32
                  }
                },
                {
                  name: "order_data_type",
                  type: {
                    kind: "array",
                    length: 32,
                    type: {
                      kind: "integer",
                      sign: "unsigned",
                      width: 8
                    }
                  }
                },
                {
                  name: "order_data",
                  type: {
                    kind: "array",
                    length: 301,
                    type: {
                      kind: "integer",
                      sign: "unsigned",
                      width: 8
                    }
                  }
                }
              ],
              kind: "struct",
              path: "types::onchain_cross_chain_order::OnchainCrossChainOrder"
            },
            visibility: "private"
          }
        ],
        return_type: {
          abi_type: {
            fields: [
              {
                name: "call_context",
                type: {
                  fields: [
                    {
                      name: "msg_sender",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "contract_address",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "function_selector",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 32
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      name: "is_static_call",
                      type: {
                        kind: "boolean"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                name: "args_hash",
                type: {
                  kind: "field"
                }
              },
              {
                name: "returns_hash",
                type: {
                  kind: "field"
                }
              },
              {
                name: "min_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "is_fee_payer",
                type: {
                  kind: "boolean"
                }
              },
              {
                name: "include_by_timestamp",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 64
                }
              },
              {
                name: "note_hash_read_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              name: "contract_address",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "nullifier_read_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              name: "contract_address",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "key_validation_requests_and_generators",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "request",
                              type: {
                                fields: [
                                  {
                                    name: "pk_m",
                                    type: {
                                      fields: [
                                        {
                                          name: "x",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "y",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "is_infinite",
                                          type: {
                                            kind: "boolean"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    name: "sk_app",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              name: "sk_app_generator",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "note_hashes",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "nullifiers",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "value",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "note_hash",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "private_call_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 8,
                        type: {
                          fields: [
                            {
                              name: "call_context",
                              type: {
                                fields: [
                                  {
                                    name: "msg_sender",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "contract_address",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "function_selector",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "integer",
                                            sign: "unsigned",
                                            width: 32
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    name: "is_static_call",
                                    type: {
                                      kind: "boolean"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              name: "args_hash",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "returns_hash",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "start_side_effect_counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            },
                            {
                              name: "end_side_effect_counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "public_call_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 32,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "msg_sender",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "contract_address",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "is_static_call",
                                    type: {
                                      kind: "boolean"
                                    }
                                  },
                                  {
                                    name: "calldata_hash",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "public_teardown_call_request",
                type: {
                  fields: [
                    {
                      name: "msg_sender",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "contract_address",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "is_static_call",
                      type: {
                        kind: "boolean"
                      }
                    },
                    {
                      name: "calldata_hash",
                      type: {
                        kind: "field"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                name: "l2_to_l1_msgs",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 8,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "recipient",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    name: "content",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "private_logs",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "log",
                                    type: {
                                      fields: [
                                        {
                                          name: "fields",
                                          type: {
                                            kind: "array",
                                            length: 18,
                                            type: {
                                              kind: "field"
                                            }
                                          }
                                        },
                                        {
                                          name: "length",
                                          type: {
                                            kind: "integer",
                                            sign: "unsigned",
                                            width: 32
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    name: "note_hash_counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "contract_class_logs_hashes",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 1,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "value",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "length",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "start_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "end_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "expected_non_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "expected_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "anchor_block_header",
                type: {
                  fields: [
                    {
                      name: "last_archive",
                      type: {
                        fields: [
                          {
                            name: "root",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "next_available_leaf_index",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      name: "state",
                      type: {
                        fields: [
                          {
                            name: "l1_to_l2_message_tree",
                            type: {
                              fields: [
                                {
                                  name: "root",
                                  type: {
                                    kind: "field"
                                  }
                                },
                                {
                                  name: "next_available_leaf_index",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            name: "partial",
                            type: {
                              fields: [
                                {
                                  name: "note_hash_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  name: "nullifier_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  name: "public_data_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      name: "sponge_blob_hash",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "global_variables",
                      type: {
                        fields: [
                          {
                            name: "chain_id",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "version",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "block_number",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 32
                            }
                          },
                          {
                            name: "slot_number",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "timestamp",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 64
                            }
                          },
                          {
                            name: "coinbase",
                            type: {
                              fields: [
                                {
                                  name: "inner",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            name: "fee_recipient",
                            type: {
                              fields: [
                                {
                                  name: "inner",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            name: "gas_fees",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      name: "total_fees",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "total_mana_used",
                      type: {
                        kind: "field"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                name: "tx_context",
                type: {
                  fields: [
                    {
                      name: "chain_id",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "version",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "gas_settings",
                      type: {
                        fields: [
                          {
                            name: "gas_limits",
                            type: {
                              fields: [
                                {
                                  name: "da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                },
                                {
                                  name: "l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            name: "teardown_gas_limits",
                            type: {
                              fields: [
                                {
                                  name: "da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                },
                                {
                                  name: "l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            name: "max_fees_per_gas",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            name: "max_priority_fees_per_gas",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            kind: "struct",
            path: "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          visibility: "databus"
        }
      },
      bytecode: "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",
      custom_attributes: [
        "abi_private"
      ],
      debug_symbols: "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",
      is_unconstrained: false,
      name: "open_private",
      verification_key: "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"
    },
    {
      abi: {
        error_types: {
          "12469291177396340830": {
            error_kind: "string",
            string: "call to assert_max_bit_size"
          },
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "16464709583191233416": {
            error_kind: "string",
            string: "Invalid id"
          },
          "1660820086751817080": {
            error_kind: "string",
            string: "Order not expired"
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          },
          "7335179940076463214": {
            error_kind: "string",
            string: "Invalid status"
          },
          "8228371833434187583": {
            error_kind: "string",
            string: "Trying to read from uninitialized PublicImmutable"
          }
        },
        parameters: [
          {
            name: "order_id_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "origin_data_bytes",
            type: {
              kind: "array",
              length: 301,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public"
      ],
      debug_symbols: "tZ3bjh630a7vRcc+aG6L9K0EgeE4TiBAsAPFXsBC4Hv/WW8VqygJH9XT3XOSPH41U81icb+b/33456//+PPfP3387V+///fDj3/734d/fP746dPHf//06fdffv7j4++/DfV/Hw7+n9hb+PBj+oGhfviRGPpQMqAA0nEcE0zpCiFNaApxKpEUUphQFfJU8jAYAlMZ3wjQCmvEVIep0EBtEtVJnHKBotCPCfnDj/EANaVwJKORsMgfDSEY1UmFKTIRW0kgtlKYWjSiSZxhkUBVKXKWKZVJwbRgWjQtmpZMS9moT8o0qQQj+241rZo9MnuN84BzaMRrUAfxz1VQnxSy0fA8cb6MBBrRpGRaMi2blk0rpnFKhTilSn0SJSP7bjOtmb0+7eXAxNHKnGspgUbq0wFqk3IyYisct8z5p1QnVdOqaWQamdZM49InxMVPqSmVIxrN75ZgWpj2Spz2ClLPeV+QawTin+PKUephVIw4/ziWBfkn1CY105pp3bQ+tXokI5qElIK4nCplo/ndmkxLZi+bPc7TzHlfiZsNjltFqhqIJiGqQtxQcCwJTY9QmRRMC6ZF06JpyTROn1KfxOVAiMuBkn23mlbNHpk9Tn3mvG9cj3IB8c9FUJ/E9UiJm0eOZeN6pESTkmnJtGxaNq2YhpSCkFKhPonLgZJ9t5nWzF6f9jrylPO+R/4NjltHqiqoTkLLLTT8LQHUJ5VsZFo1rZpGppFpnD6lNonLAVNGF6RUJgXTQjbqkzgnS2TiDqUkEP/rwcRdi1KbRMPfUkB1EtdzJdO6aX1qAekTykZ9EveSSm1SjEY0KQWjMimb5cK/W5mQPmJq41/rAcpGfRLX8xpApBS5RRLi2lM5h2Lin0sg/jn+WuTyJ8T1Q6lO4qgqsZeNiUudUpvE/WUlUJ3E+ac0NfRHSqZxfJWyUZ/E4wylNilFI5qUzTKXWKFiljn6lVOakL7OxO04RVA26kqZ20lKIJrE7aQQtz6Umbj9owLin+OvZa6/QlxrleokrhVK/DWOYOZaodQmca2lDqpKhfNPybRgWjAtmhZN43ZSqUxC6oVoUolGplWzV80el8TGKa1c1loA8b9yPleOqlIxGv42zr/KUVVqk5JpybRsGqdPiMupUp3E/aVSMbKvcY4rmWUusUrTMnGkG0cVvUsrILbCqSekT6hN4trTOqhOQvpAXHs65xDx13oAjZ/r+BrXD1DjVkWpTOK2RGl8rXOqGnKtgmgS1wUltgziXFNqkziqvYHqJI6qkmlkGpnWTGumce1RKkqd64wSTQrRyLQYjKa9zj1251zrXOpGQ8uIYW4GlUkY5gplozYJQ18hmtTNCgbugwo6GqVs1CeFZESTuCFXMivJrKRiZFayWcltUjErxaxMLweZlWpWyNLHXoYjMnJ5mkiG3dVuajiio6vBVW42FDkyE7shl/yJloaQXc1ut7jd4na5fk4sjvgE+xYoOTZDcbMAq2EPEyMHLxyVMeJnCYifTYwJH27A7NgNs6u5GZbkSIY1OBZD8k9wrEI4gM2Qy+RENsYz4YLucWKdiMnZiA1jxM+yFynhwx2IqTTnTuIhw8Ts2A2Lq6UZYrqtSIYUHP0TzT/RYKwCm2FPjjDGAchHcKyGASnjjMoJP8sO5YyfLUD+ME/eB3ZDeKHoKrxQbIY8tptYDeGFon+iwRhndYYXim0iJnWBVwYKeltF7m4VI1LGuVMyfrYA8bMczYLVDp5hD8yO3bC6Kl4AURkUybAFx2LY/RMdxhqwTcSEbyKMca5X8UKwGqLO8/y5oL8NPPku6HADrywM5A/zRLygy52YHbshuYrKIIjKoEiGqAyK9gnMCifCWAY2w5AcYYwDQGjEFKsh6jzPuAuhSvOUu2ACGHg9oWAGGHhiOrAbiheCrooXgs0Q7a9indjEC8HiyMZ4ulzQ1U9shmjPeBY9sBqiJRBEnedpZ2kVP5uA+DBHs6Fh4vnrwOLYDVGlFV1FZVBsEzsqA0+BCzp3RRQjxWoYXY3FEE2xIj5cgd0QHYpiMyyuIm6C4rFgNRSPBf0T5J9A3HgCXDA+UETcFGFsZF/FEGFiMUSEeCJZsc4ZeBZaDzTFPMUeyB/mGenAbggvFJthdRVNsSAaMUV8IjGi+isWQ1R/xUXtEzFPnYgPZ0YUOZ5u1iAOAVHkFMkwuSoeA9FsKxZHfJjzIYjHgs0QceM548BqiM5HEGWycFZjCht4hjsQP1sZeWIReGZbMbOd2A3RKiu6ijGMYjNEs63In6j4BJptxWJYXa2ukqsocorNEEVOkQxR5BTxYc6dhEZMEHVI0X8guZpcza4iFordEJ2PYjNE6VP0D6P0KeITHFgZCCgWx26IVkOxTcwSQkEzltFqKBZHM5YlhIKuSrC4lGTEgqfJA/lnKQC7IfpNQQwiBVFFeAY/+jROL0/hB5Ihcl2xOHZDtFyK7CZxCKX3VyTD4mpxtbpaXSVXUXZ4EaIWSbpgNUSdV0RyCNgnSpfPU+6BzRANtKC4Kchu8lS3Su8vCDcVXc2uZldR0RXJEG4qVkNUdEV8mD3GOrCgdPmK9gNYCp7oanQVBUaxGaLOK5IhgqXoH8YgRxGfyMBuiHKm2AwRN0UyRFut6MYQN0U31s1YQ9wExbcGzI7dMLmaXM2uogsVREFUJEMMfRSrIdozXr4YmB2bIcoksCNYvKwxxm/8A53LZEcvolgN0fsrZsduiN6f1zkGkiGSruhqdbW6Sq6Sq2h/ewGSIdpfxamOwhccqyFKH6+iEFagJzZD8RiIBroTsDh2Q3GzAZshpsqCCIsgzRCSTPgVybC72mcIR2UJjkWDRVimVkTbp0iGkt7AiCrNYRlIhpIyweLYDSk7Ng0AySRekQy7q91U6fIVXQ2uSq5zWGTCr2ghjMnVZCGMOTiWGayIRkxQPBYkQ64XkZeiSHZXjwAshlhuUmwTZdeV1x8IC9mRFzMIK9kTyTAFx2KYD0dscldgMyzJ0dXqanWVXCVXG+xGYDPksEysEzNWy3htZWBxhG9cdjJ2khVdFTeBHJbICwmE3drIE37C4rkidrkVsUnP5Rfr5zHAAmIhSK4StvE5QtirndgNcUZAkT/M81jC1H4iGQZXg6vRVaz8CWLpT7E4dkPETREfZocwJphIhtXV6iq5Km4C2+FYHLuheCxoH8aYYCI+wYUAywATqyFOKyhmx26YkqMby9HRjRU3VoohfOOVhoHVECFUdLW72k3FSGFiduyGWMRVbIaIJq9rEBYHFBFNxWyIYPHiAGFTOPJKA5GcFxFshjgxolgNJemC7DyvPwzsE5skXdDV4GpwNboaXUXp48UMwkBAEaVP0VW0GorNEKWPVyUIAwFF8VgwG6LB4+UFwv6yorgpiCVszuoua+yCzVDW1oHJQthTdrQQ9uxqthD2khxpBkv2ChSLYzeU9I5oNsznEZYmi/6CUmAEyTAGx2ooSa/A7NgNs6vZ1eJqcbW6KrlOwOzYDZurrRn25EgarIaBwMTi2A1RL3gJqQXZ3khAMpRtDSC6JEEEgFdyGmbukddWBhbHbigbMoJkiG5GEfsgnBw5TaVYDIOrwdXoanQ1uZpgl4MVJemC2bEZyq5MB5IhShSv7zQZCAiSq3BTEGEpMIammJdDRi3FAatRUluCb7yCMRBqBzZDlD5FV6Or0VX0porVkAc5E4sh2l9FnDNDclD9BTFoUHSVXCVX0copVkM5GSdYJsqgQTE7dkPxuAHJEAVRsRoisIrFsRtmN4bAChY3VtwYAisovnENyOKbIBl2V7upMn5QrIZy8k+wOHZDtOCK+DBXp4JoKlZDFFpBCRaXKBkI8DpBk4GAYnZshpJ0QZpY0Sjw3H9gMZSkC7oaXY2uJleTqyh9fDJgYDFE6VNc1G6Itk+Rk84nCpoMDxSrITxWZAt85qBVtH2KNJHgZovAaoiOVbEbJgsh5cPRQkjF1ZIdLbAkdSgByRBNhWIxRHoRzYbhF8LSJNcFuyGqv6KFsKXoWGcAWj4cLSytuFpcra5WV8lVKWccltYORwsh9v8nZkcLLA4DSLCwYaAIjxWLIeoFL3w0nEuLvEI09iGSIQqXYjVEABr3epjwR57zNhx1nlgcu6EUGMGmOAYrnKl8WqNj7q+I9Cq6Gl2NriZXk6sYFfPC0sBqiLAoZkdODk/BO7YGJrJvPP3t2BqIvJAwRlRsoSPpqPOCOPLJk7aOgYAgjgBMdDW4GlzFEVXFYohjt4rZsRvm5OjGin8CB1l5UtwxJkg8u+0YEySekHaMCSbyQVjeUu8YE0wshsHV4Gp0NbqaXJWkC3ZDSS8QZ4UVPQ3V1ep2ye2KQ6PYd8z9E2/2dxy5Tjzn7djWV+QmaCJOP7PHeuxakAwTjMFuKoZc0Se6WlwtrlZX66J2Q8qGLTpWw+5pQFh4Lt3RuU8sjmyXt747OveJzTDaJ9C5K7qb2d1E566YLZG54iQ4lyhs6yfeiR+IHyBgM5Tz44I0EWfoEu/aDyyGKFGKrkZXo6vJ1eQqaoAivlYYUaIUqyHCwjPhjiMAE7shjnjzdL0XcVMwO3bD7mo3tR7ZsRnKQXpBMkSdV6yG6XAsjv6J7J/I/omSHP0T1T9c/RPkHyb/hHtc3ePqHqPLn2gfpiM62ocpBEf7MMXDsTjaJ7AMMNE/kZMjf4JnoR17BxOrIWKsWBz5EzwhHV1WcmyGzdXmane1m4oNA0W4qYivRWA3xIF+RVeTq8nV7Gp2FYFVbIaIpiBaREVPQ3O1ud1mdnG0IPHEfKzK42czED9bgc0wJUcEgKs0hgcTqyFaRJ7odpxYn9gN0eDxskU4sNufeFmCmX+aD1kwd2e0aTxdZm7OaNV4aszMqeJZ5WDcm5lcndGA8/yZGfc7KhgJzpIeVB1Nm9xWkbTJfRVhWnSei05GNhdJM/JZuS+63F1B+nFnyhj3V+CLDBBKFiZnucVShKszGozJ+FYV7s550TE6mEzOddFRpibjDg6BUaomrzq+1cDibxfuFt8o8VVuznEWRGb2q4qO/mnyoiOONQhzGiryB+cHjPPC3bkuel10WnRadPRlFXmLs/OpIk+SVBP8TEJDVZEPCS3V5EVHA6WMclWbcHWmRUeeT+7OKGPKkjZlsvTgGKBxdQ6LLo2VsNV+5lXvztIACKMJroiv3PKaXJ3RChPihZP3iRAvGRtQFK7G5ZiDCua8cHcOiy6DG+GYFl50tAOTqzPKCSkX57roPCmejA6D4HtFOqkIN2e0UVSFm3NcdKSBUAYqyjA1YaQB+VYlbVG4ONdFl7QJS9qUyRnDx3YIV2PMz43LwpzPDTHCCr5xc46LjvZWGfk8edHRPbQojDQgP6Xfnrzo8HFycYaPkzHMlDTLwFmZnPuiw3fhZnME5kXHGHRydkZZaoh7Q/lvRRg64ihddqvCuA8pPy8zMGVyrouOuq+Muj950dHeTs7OMoNGGtCRG1dnLC5NRjpR3nDzLE4m57zoEi+UyS7xUl50xKsfwsV/t3ZnrKZPXvSWFm7OfdG7pS0cR1i4LNydQ3OWtZoiXJ1ltUY5L4yblQFc52JfCAeFhRcdceE9d+bi3Bcd/SBfJmHu9rtyV3pycw6LHsg5xoUXPYWFy8LLt/Jisyx2qudJoGPhvHBzRl2T/NHb11XYv6s3sJWz5QMOCU6Oi476JfmDc4Lzd5P7iJOCxotewsIeF72hrbykrXqeRFq+RYvN5nZk3wBjxSAbB5ObM/atJ3O94MWiwdiZymIndee86FLe5HcxwJ+86Ggruvx8Jf9d2/xhrs5t0Vtxxprh5FX3tOHenbF/C2OGydHtZNl9S8LNOceFqzP6NV5BG1zn9u1gSgsvupS3JkzOfdHRtvPlpVG0j2C/W2ybcXA4Fl717hzzwoue0sLknJdv5cVmWexUzxM5UDDZ80R2EiZnyx/c61M7cmhAOSy6lDfkgywjTF50zAskf2THQH83uY8154UXvaSFPS61Lnpd0kZh4eVbtNhsbgeLBjirw1ydEa/JeeHGt9wPMNrzQ+zksPCic3nLRxAuznXReS6Qjyjc/XcpLdyc26I3cpbDO8qutyMsXBb2b+ESwuTodpocokI6scNgnBduzri7LnklZwmljZUbCMpt0Rt8l2/x3G1yX/SOPEdbhG0F/V25iKAc4sKLHsPC1TkteioLd+e8fCsvNstihzxP5M7BZM+TLifglOvMn4h1BrETMX6YHBZdylsG482VyYuOG/zIn4j78PN3c1i4OpdFL8W5Hguv+pI2Sgsv32qLze525P4B5i9RLiAoI16TqzNeeOBdgMFywho+ym3DyYsu5Y2EybkuekWeNzAF/10qziiTk1e9O8tpa2XX45EWJucQFnabckNBOSGOHZzTwosOH/l+IHN1RhsyOS/MvxuQ/xhjTOYYGVfnDjvIf4wrckDacCRhcgwL43dR3hJe35hcnPOi57xwdy6LXvBdxB0nEowXnaqz+KJcFu7O3e1g/JADygDWE3JA3mI9wZic8QLG5OKM9nwypz8G4eaM9E9edFp0WvS26G3R0QbGKNyMy5EWXnSuU8bkvMQO2xjG3Tl5rHGdIWPuGYuUN+RbkfKmnBduzoQ0oCyV7nlVuuch1i6M4WMW7s5h0dEGRpQTrGPM340er4o2cPKiL3HEqcTJZdHLkrbiZaPW5Vt1sUmLHbmApYw0V+FuTIfrJDFSJue46KhTkzltEe0YDicYrzq+hfwnKZPKyDekDScUcjqEm7Nc91EmZ7TnynKzTJm/lVA+cXjReNHhlzL8mrzo8EsZfqUoXJzLosMvjFEHd2fxKwvDL5QTeRtnMi6zybfQF0+uxnKXAev5g/GtKtydw6KLX8rknBZd/FKGX4hXF7+UVx3fQuzwno4x/EIcO/zCenXEGGMy/MIeRNSrjcK4WQuWd91wBTbo027Y10gYbxgvOvxShl+TFx1+KcMv5KE87za5Ljr80vTgJSNl8SsLw68CljeYlOe93cFy11a5Ggdc1kDZHoxvVeHuHBdd/FIm57zo4pcy/JJviV/Kq45vNTDlheFXB8OvIulEm68sfgVhMo641KGMsQTaxoQ1jVxEh1+TFx1+KcOvyYsOv5ThF/aD5H25ybTo8Av7RAn7FJPFL0mb+IXYRfTFk9kvtOdj+BAXrs64AIU+JSXxqwp357To4pcyOZdFF7+U4RfilcQv5VXHtyQNmKdMhl+Io4wx0E4mXHxUlpuP6CMS1jEmY0yojLt3GIMlGZNgL0letjNedPilDL8mLzr8UoZfVezDL+W26PCrJuHuLH5lYfiFuMjYYzL8ws9j7GFcneUBjiqMbyl357zo4pcyOddFF7+U4RfiVcQv5VXHtxA7HJYwhl+IBe5HZOwTJeynTJZ3UkiYnOWlFGH0ZdhXSthPMV70khaGfeS/jDEmLzrGUZM5Pw9JD+Ypk4tzX3TMUyZ3Y3lEYXJzFh+F8SKPIIYhmJYlGYYo50XHNEVZXFRedEy/lHn6lTH1GVyd26IjdFjuTbgzacyhw7JokmEItrCSDEMmN3loiRchkyMZ4pVS7HclrG1MzouO8ZQyxh3YE0sy7lCuiy5xE+a4YXsmYftEEY+YKrqKh0wVy0SMRCZmx2aIoQe2y5IMPZTToiNGkzk/sRWWZOgxedW7MxfJiWQIxxRdhWOK1bC7CscUu2LGSQpEO+OqRcbmXD7EM+VFR+lTFs+UFx2lbzIHBBt18gSg8aKjgjVJA5EzSiJyWh4DzNhUk+cAjYs8+hbkRcCJ2RAzFux4jTl2WnjRUfqUUfqwYzS4OpdFl3Apd3nFbiD7N7EZkqvsnCKe6VN0FQ/1KZaJkQeI6CPGbBQeiCyeCcdFR72aXJ3zoqNeKaNeoaHJOBcxuS46woV6K68OGnO4uqSNXcrYu8l4X2EynFKsE7GboojBITZK5LnByXHRUaMmwzjCK4ONyYuOcE0u8ngjYzfEM5mKruJJRcVm2FxlzxTxLCUQJy8z9mXGCPxYeNERo8nIT/ldzPcnL7q4plzlRc2B3G5MLIbVVTim2A3JVTgmyDFTxBOw2CaQxw2NF10ipYxIoQgViZTyootryogOECVRsRoWV1HBBDFSVFzUbijFEYjYoPfMuHJh7DpuWkzGe6ZY+Ze3ESfHRWfXjDHaBKI8KpJhdhWOCcIxRVdlCCyYDREbbEBkPNBkvOh4BFUYhzcKFrEzNk0mh0UX15SxqAKU9RvBZphclcUboKxDCboqKzeCxRCFDuvhGTc0jRddIiUskSrCZNyOuHB1xtkMEsyO3TC6iv1kQRzXUHQVj2crVkPUJgyVM25lTKZFl0gJS6TkdyVSwn3RxTVwl+NYgsUQjikuajeUE2aCrso5LEEyLCgATbg610UX15R5BwrVCAsbE5thcxU7XYLY6FKcajnmY+eMxRAbrBEYkTEix+acFj2HhatzWXR5X1hY3j0+hLszLTqChrX5csj7x8ocnCBpQ3nEnEkeb1TWO5yC1VB2k//664cP87H/n/74/Ouv/Nb/8vr/3/734T8/f/71tz8+/Pjbn58+/fDh//386U/80H//8/Nv+P8/fv48/nUk89ff/jn+fxj818dPvzL99YP/9vH6VyMO4eC34xgYmYGxBvOFifDaxNh74QkZbAwmMiOtfGEjvrbBCxhFbQym8MrGzpUWZjLGml546UremMhYJ9XsGDvKnoz2hY3yQHbU982OMf4iNTGGMPQyO9rGFdxqFk/GNoGbQNl1E/2B3AjHA9mx8yVxjZR0jKWnl76E+IQz6Z2dwb1FDUx/HZiwKafUzJfRm+aXruyK6RgPTxv8ByLuujJsvHRlUzzGdKpbbOsRvRUr8UtfNgW1YcUANgYuDWE7bwI9u5gYvcY1E+kwEylcMlGPWbzaWP56ZWKXn8NC9fzs8VV+xl1TSmHa4B0xMzG2907b4DPHMx3haGbjaxPbImrVnv9gyjUTicxE6tdMWLcy8LWJXV7goVTNC3rpSDpu58XexKm82Ju4nxd410ibvxxfpiLfz4t8Py/yO+cFr0pr+xnCy1S0+3nR7udFe9+88FTwOvQrEznezou9iVN5sTdxPy+ydQO8pvMyFffbzny/7czv3HZiC0LyYuxuvTJR7red5X7bWd657SzFhrBjB+1lKnatFibAkooS4jUT1psNLNdM5GomSrmWF2aCx5AvU7FrtTwR5JOKWr80cH/cWe6PO8v9cWe5P+7cZibN4d7YG3qVmXUT0EKzko5l2lcp2JaI6iWitpctRa23a8fexKnasTdxv3ZUH3HWRq9M0HGzdlC4XTu2Js7Vjr2JU7Vja+Jc7dhm5pnaQfU9awdFm2dTfdkJ0v2xJt0fa9I7jzWbFavQXo+vWrzdUuxNnGop9ibutxTUs+fFy5ai1ZstBe+232wptibOtRR7E6daiq2Jcy3FNjPPtBQ93mwpdinIthSfl7Wfr1Kwr15kRaq/rht9s8CZapurBHym6lLB7skavP560aXT7QZvb+JUg7c3carB2y4K4i9Y6XAgxJeLguEI2w2W5vsrL9PxHRvWVsS1pn9jI91f7d3aOLncu7dxbr13a+Ncg/GdPLV+ZGRvuhYXnHgQGyXRaxsPrMIfDyzDHw+swx/9veOybM++nq1/Jy7FbJT+Oi67zaKzcdnaOBmXvY1zcdnaeCIuJZPlaanX4lKDxaWW17GN9+dHexsn4xLvz5D2Np6ISz0sLjVcjUuzMwC0sRHpgbjQA3GhB+JC7x0X22yOlehaXCiZDaKXExX8OcC7cUkP9PvpgX4/vXe/T3HZpS0X49KtzrX0ur6kB/r99EC/nx7o99N79/vUisXl9dxlb6P5OLmVi7Ft3dLRj4vp6NWWOY7jdd3PD7Sn+YH2ND/Qnub3bk97trFDL9fGhekINq08Il20YX1lChfLRzqqp+Ni35DQg2k6NvlR6v0ytrVxsoztbZwrY1sbD5SxhL8crXkaL8Y2WL+fQj9e2qibxSgiP6jWgrdj6euFh7o7dVfmWlBehnTxm3TsTjThDRipc3E5Kvutkc3ko8RZb8vmUNTehHW3dcmNt7mCv6mjriwHaN5m5OQJr1D7OxsJtR62NLWc+3ibESLf3OibPKFdWc2zmFGu10z0PGvu2rC/yQS/fztdOeqmjNCmmOUWZkJyK0sT0t+Qp93XDHt8nafn1x2X8eVX1X9vw8/tjln3SxuB+q7q2nZNGZNLd2a0818YaduzqlbcD8+P1L46bd/CA+3hftfnVHvY0gPtYcu328OtiXPt4daV6Mts6djU/d3GTSjRWqGy7IK90YgfeS2tXzSSvMqkuGlE+nG7KduZONmU7Uycbsp6ut+U7fM024bUep3ijYHpfkCxt2tGHvEm2BiTH8a8WGvO9t29v7OR0wOA/sAAAIeP79WarYlztWZr4myticcDA4D+wABg3/FiOKwdL8WXHW882raI+B2RtpSzr9w5PYyIy2Hrr+9F7C4zxRiXsXd9mRCMNl7Pmbsf/Dj6srrz9Z273X2m0dX5/Z0jttc397YXmkpdDqHU+tLK+axdZptvGeXFpRWI7fW1ld2dprFF1m35vx5HeJ0nu/32sSpjhw9iXy8Slov+9HA7T1Jol2z44QF+9De9zNfd7s7Z0XOM8e7oOcZ0f/QcY747eo6x3B89x929onOj572JU6PnvSsnR88x9vuj5+8YOTd63hs5OXqO6f44IN0fB6QnxgHp/jjgO3l6bvT8HSPnRs9bI494c3L0vK81py9Ihnc2cnb0vDdydvSc8+1aszNxstbk/ECtyfdnafs8PTl63ne8Z0fP5Xjn0XP20+M155dDkVg2LdoYsBbrN/mdlZfDs7K9g99a9eHZcW3I+oU/pd8eWq3vb3yTJ3W7AZ9so3c5VPnNjKJsR6zJBhODy+tx7/YGD/8VBtvwofJ6RrG7SjR6iGyHZgu1fCk8xeZZg3N5mbV1V3nwFrNUnryOSsJXlWe3gVXxx7pkjJWXI8DfGtkV2SPbLvpYc98Y2bRs7fCtxWOZqH0z+N3tP50eQe/vJ50aQVd6YARd2+0R9NbEuRH01pWzI+jdFaPTI+i9kZMj6K2RsyNouj8WoPtjAXpiLEAPjAX2eXpyBL03cnIEvTPyiDdnR9DbWnN28PvEIvbWyOkR9NbI2RH07uLNyVqzM3Gy1uxMnK417YGZ2jZPz46gt/13rt5/r4H5uuvtT7wdFfsTj0d9xyE79TkGrmXj0P33o2J/4gGpNwzSdkOjnZFi97RKoV2e7BYGvB/nPtCNlC9vvqXjeGBtP33ndF/wtf2wTAveaMVaA+Z60Uq05p55Y2WfL3HJl9dr6mm3q8V/hs6vtdd1Gbm+ZXLhr+7U+nonKB27/isvNw0GX7VCh9+po+W+5hut2BspfKsuXbTS7MIkz85fpyVsBwc+Shlr1y8nGGm3t+U98toh5686j7Tb2KJuZzlDumaiWXfcetmY2BXYSD5mW4rr24wUfxmpLPt83xrZRLf6nhYdy2Hfb43sZku4yyjtbNga2bmTberH77Zec4f/INwsq2EbnZ07zU5SjnbluGakYrFKCmusV8uJH/kdy0p0rbx2e1itl01R261r8x/89Vf71h3uN5qJtm7Jfxd3UwH3l5dsPttqv5yW5FNr/sMpGzP93c20bnfcWs/pmpF+BIv0ES4bsYHxwHbRSLBpTw/LisO35XbXZcRinXpc7st802XsNrqq3XX5oqSMRuq0CbIrFbTcqHibCbtZui6fvs0EzY6L1r7vLSa6V75j7XTeYmM0791ngccTRvplIzb3OpZ3HN5qJD5gpFlHfKydzhuNhDNG9rsXzZcs1qsqX9eYvD1G2H1fKB7H6yF53r6hdnSbqowF8vjSyi5Tmo3IW7tYYJs501q6baJfToWPGS82AM3OyVw20e24Tg9X2xArpb1dTYX3Da3dNnE5L/yJ6m1juO/mDu/mlgnjG/vKxUg8Lhuxrj+kTde/W0Iq0ZqP8sUL5O0rG5vBZiVbJay0LAJ/beM7o4fu5TRfzZFi45j19uBbxzFLSi4b6RabuJ3sbeckNpUfWC/OSXwJtx7p6mSv2zxtYL86OzpsKh935fW8O+2qEbKUHO3ijLEGW66pIYbLRrIbiVeN+BpJqOFydIJFJ+SrRmytch/i7yxhZT8aQvXyclpcFsJSu2qlrY9UxatWultZF6G+sbJffbX5AJ/yvryGu1zjv2Hl3InztH3f7uyJ8/0+l02je7y6VWZDtU7l9m7bzsR2m/ucI1sT5xw5udm+M5HvO5LvO5LvO7I9unvOka2Jc46cPEC8M3Hcd+S478hx25H9VcRTjuxNnHLk7IXInQm6HZG9iXOO0P2IbJ8PSDaXiesfrnjjQwbnDk7l3Y2skwcNtjbOHmj5jhGLzNi8LReNnDzjszdy8izZd4ycO0v2HXfOnSXLu62ec6ditibOnYrZmjh7KibH9y6sJ8+S7TPkVEO0N3GqITobll1DtH9vx9fsCr1+K2dvw1YQho1030a7nA5/f6hdfX8on7KxfyfrXJ7ubZzL09M22uV0PJAf5/J0/zbduTzd2ziXp6dttMvpeCA/TuZpeiBP0wN5mh7I0/RAnqb7eRofqPvxgbofH6j78YG6Hx+o+/v3dU/maXggT8MDeRoeyNNwP0/3b0mfy9O9jXN5etpGu5yOB/LjXJ4eD/RRxwN91PFAH3U80EcdD/RRxwN91PFAH3U80EcdD/RRx/0+av/nMPxZyvT6ydHvmIhu4uWLo+1+R9nu95PtfjfZ7veS7X4nuX/SrvqmAL38GxZ7E/bHEfkO6isT+z8tdapofcfEmaJF98cLdH+4QPdHC3R/sED3xwr726qnitbexKmiVe53ruV+31rud63lfs9a7nes+z8geiqoexPngnrcbi++Y+JMe7H/I7unUvEdE6dSEe+nIt5ORbrfgqf7Lfj+T4OfS0W+n4r7pTPdL53xftEKD0xMHpiXPDAteWBWcrHt/Pv4r59/+fj5p0+///LzHx9//+2/4xf/YlufP/78j0+/6n/+68/ffln+9Y///5/5L//4/PHTp4///uk/n3//5dd//vn5V7bE//bh0P/5WzpGdz22dY6///Ah8X+PMjbCOv4ryD+Phj8dNbMQIPAPHHT8/S9O4P8B",
      is_unconstrained: true,
      name: "refund"
    },
    {
      abi: {
        error_types: {
          "12469291177396340830": {
            error_kind: "string",
            string: "call to assert_max_bit_size"
          },
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14942831874215426972": {
            error_kind: "string",
            string: "Invalid destination domain"
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15130664124905246775": {
            error_kind: "string",
            string: "L1-to-L2 message is already nullified"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "16070420376462343922": {
            error_kind: "string",
            string: "Not a public order"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "16464709583191233416": {
            error_kind: "string",
            string: "Invalid id"
          },
          "16882345102269044371": {
            error_kind: "string",
            string: "Tried to consume nonexistent L1-to-L2 message"
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "361444214588792908": {
            error_kind: "string",
            string: "attempt to multiply with overflow"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          },
          "5167727358818866312": {
            error_kind: "string",
            string: "Invalid destination settler"
          },
          "7335179940076463214": {
            error_kind: "string",
            string: "Invalid status"
          },
          "8228371833434187583": {
            error_kind: "string",
            string: "Trying to read from uninitialized PublicImmutable"
          }
        },
        parameters: [
          {
            name: "order_id_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "origin_data_bytes",
            type: {
              kind: "array",
              length: 301,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "filler_data_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "message_leaf_index",
            type: {
              kind: "field"
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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HxktCAEfAAABAgEtDhkfDCocHiAkAgAgAABGzCMAAEZxACIeeSMOKh4jJCQCACQAAEaIJQAAY4UMKhwjJCQCACQAAEajIwAARpotCHkgIwAARsMCKhweIw4qHhwkJAIAJAAARrolAABjuy0KIyAjAABGwy0KIBsjAABG1S0KDxsjAABG1QAiG3ojDiobIyQkAgAkAABG7CUAAGOFAiojEyQOKhMjJSQCACUAAEcDJQAAY7sGIiR6Iy0KDyAjAABHEQwqICMkJAIAJAAAR3QjAABHIy0LHxstCxYeLQseHwAiHwIfLQ4fHi0IAR8nAiAECQAIASABJwMfBAEAIhsCIAAiHgIjACIfAiRAPwAkACMAIC0OHxYAKgcTGy0KGwcjAAAvzC0IASUAAAECAS0ODyUEIiB6JgYiJnooCiooICckAgAnAABHnSUAAGPfLQoPJCMAAEemDCIkeickAgAnAABIBCMAAEe4LQslJC0LHyUMKiAdJiQCACYAAEfSJQAAY80tAiUDJwAEBBElAABiqC0IBSYAIiYCJwAqJyAoLQ4kKC0OJh8AKiATJC0KJCAjAABHEQAqJiQoDiomKCkkAgApAABIGyUAAGOFDCooGykkAgApAABINiMAAEgtLQhEJyMAAEh2ACoeKCkOKh4pKiQCACoAAEhNJQAAY4UMKikcKCQCACgAAEhfJQAAY80AIgoCKgAqKikrLQsrKC0KKCcjAABIdi0LJSgYKigMKRwKJygEACopKCcOKiknKiQCACoAAEibJQAAY4UtDiclACokEyctCickIwAAR6YAIiQCJwAqJxsoLQsoJi0LJSctAicDJwAEBOElAABiqC0IBSgAIigCKQAqKRsqLQ4mKgAqGxAmACIKAikAKikbKi0LKicMKiYcKSQCACkAAEkEJQAAY80tAigDJwAEBOElAABiqC0IBSkAIikCKgAqKiYrLQ4nKwAiG3kmACIfAigAKigbKi0LKicMKiYcKCQCACgAAElJJQAAY80tAikDJwAEBOElAABiqC0IBSgAIigCKgAqKiYrLQ4nKwAqGxYmACIgAikAKikbKi0LKicMKiYcKSQCACkAAEmOJQAAY80tAigDJwAEBOElAABiqC0IBSkAIikCKgAqKiYrLQ4nKwAiG30mACIjAigAKigbKi0LKicMKiYcKCQCACgAAEnTJQAAY80tAikDJwAEBOElAABiqC0IBSgAIigCKgAqKiYrLQ4nKwAqGxkmACIeAikAKikbKi0LKicMKiYcKSQCACkAAEoYJQAAY80tAigDJwAEBOElAABiqC0IBSkAIikCKgAqKiYrLQ4nKwAqGxomACIHAigAKigbKi0LKicMKiYcKCQCACgAAEpdJQAAY80tAikDJwAEBOElAABiqC0IBSgAIigCKgAqKiYrLQ4nKy0OKCUAKhsTJi0KJhsjAAAvUi0LHyQtCwclLQsgJi0LIycMKhsmKCQCACgAAEqxIwAASwcAIiUCKQAqKRsqLQsqKAAiJAIqACoqGystCyspACooKSotAiUDJwAEBAUlAABiqC0IBSgAIigCKQAqKRsrLQ4qKy0OJB8tDigHLQ4mIC0OJyMjAABLBwAqGxMkLQokGyMAAC03LQsfJC0LByUtCyAmLQsjJwwqGyYoJAIAKAAASzcjAABLjQAiJQIpACopGyotCyooACIkAioAKiobKy0LKykAKigpKi0CJQMnAAQEBSUAAGKoLQgFKAAiKAIpACopGystDiorLQ4kHy0OKActDiYgLQ4nIyMAAEuNACobEyQtCiQbIwAALJEtCx8lLQsHJi0LICctCyMoDCobJykkAgApAABLvSMAAEwTACImAioAKiobKy0LKykAIiUCKwAqKxssLQssKgAqKSorLQImAycABAQFJQAAYqgtCAUpACIpAioAKiobLC0OKywtDiUfLQ4pBy0OJyAtDigjIwAATBMAKhsTJS0KJRsjAAArphwKCgcAACobByAvCgAgAActCx8gLQIgAycABAQEJQAAYqgtCAUjACIjAiQAKiQKJS0OByUtDiMfACoKEwctCgcKIwAAKoQtCyAfLQsHJS0LIyYtCyQnDCoKJigkAgAoAABMiSMAAEzfACIlAikAKikKKi0LKigAIh8CKgAqKgorLQsrKQAqKCkqLQIlAycABAQFJQAAYqgtCAUoACIoAikAKikKKy0OKistDh8gLQ4oBy0OJiMtDickIwAATN8AKgoTHy0KHwojAAApti0LIB8tCwclLQsjJi0LJCcMKgomKCQCACgAAE0PIwAATWUAIiUCKQAqKQoqLQsqKAAiHwIqACoqCistCyspACooKSotAiUDJwAEBAUlAABiqC0IBSgAIigCKQAqKQorLQ4qKy0OHyAtDigH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",
      custom_attributes: [
        "abi_public"
      ],
      debug_symbols: "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",
      is_unconstrained: true,
      name: "settle"
    },
    {
      abi: {
        error_types: {
          "10522114655416116165": {
            error_kind: "string",
            string: "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            error_kind: "string",
            string: "extend_from_bounded_vec out of bounds"
          },
          "11019205087382408538": {
            error_kind: "string",
            string: "Field failed to decompose into specified 4 limbs"
          },
          "11021520179822076911": {
            error_kind: "string",
            string: "Attempted to delete past the length of a CapsuleArray"
          },
          "12370419938245003393": {
            error_kind: "string",
            string: "Field failed to decompose into specified 36 limbs"
          },
          "12469291177396340830": {
            error_kind: "string",
            string: "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            error_kind: "string",
            string: "push out of bounds"
          },
          "13060541637244024094": {
            error_kind: "fmtstring",
            item_types: [],
            length: 98
          },
          "13450089406971132036": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 144
          },
          "14942831874215426972": {
            error_kind: "string",
            string: "Invalid destination domain"
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15711892660910782274": {
            error_kind: "string",
            string: "Hint values do not match hash"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "15835548349546956319": {
            error_kind: "string",
            string: "Field failed to decompose into specified 32 limbs"
          },
          "16216212843441549037": {
            error_kind: "string",
            string: "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "16464709583191233416": {
            error_kind: "string",
            string: "Invalid id"
          },
          "16792019527863081935": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 77
          },
          "17154023812102399658": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 128
          },
          "17803644318014042523": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              }
            ],
            length: 58
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            error_kind: "string",
            string: "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 132
          },
          "344423948968719440": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              },
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              },
              {
                kind: "field"
              }
            ],
            length: 98
          },
          "361444214588792908": {
            error_kind: "string",
            string: "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            error_kind: "string",
            string: "Value does not fit in field"
          },
          "4440399188109668273": {
            error_kind: "string",
            string: "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            error_kind: "string",
            string: "Public data tree index doesn't match witness"
          },
          "5167727358818866312": {
            error_kind: "string",
            string: "Invalid destination settler"
          },
          "6609888949476313245": {
            error_kind: "string",
            string: "Message not in state"
          },
          "7555607922535724711": {
            error_kind: "string",
            string: "Preimage mismatch"
          },
          "755921036432567449": {
            error_kind: "string",
            string: "Not a private order"
          },
          "7564993426627941149": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              },
              {
                kind: "field"
              }
            ],
            length: 48
          },
          "7995966536718645961": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              },
              {
                kind: "field"
              }
            ],
            length: 61
          },
          "8171600539936659379": {
            error_kind: "fmtstring",
            item_types: [],
            length: 92
          },
          "8556029555939094797": {
            error_kind: "fmtstring",
            item_types: [],
            length: 75
          },
          "8992688621799713766": {
            error_kind: "string",
            string: "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            error_kind: "string",
            string: "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            error_kind: "string",
            string: "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            error_kind: "string",
            string: "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            error_kind: "string",
            string: "Attempted to read past end of BoundedVec"
          }
        },
        parameters: [
          {
            name: "inputs",
            type: {
              fields: [
                {
                  name: "call_context",
                  type: {
                    fields: [
                      {
                        name: "msg_sender",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        name: "contract_address",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        name: "function_selector",
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        name: "is_static_call",
                        type: {
                          kind: "boolean"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  name: "anchor_block_header",
                  type: {
                    fields: [
                      {
                        name: "last_archive",
                        type: {
                          fields: [
                            {
                              name: "root",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "next_available_leaf_index",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        name: "state",
                        type: {
                          fields: [
                            {
                              name: "l1_to_l2_message_tree",
                              type: {
                                fields: [
                                  {
                                    name: "root",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "next_available_leaf_index",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              name: "partial",
                              type: {
                                fields: [
                                  {
                                    name: "note_hash_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    name: "nullifier_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    name: "public_data_tree",
                                    type: {
                                      fields: [
                                        {
                                          name: "root",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "next_available_leaf_index",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        name: "sponge_blob_hash",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "global_variables",
                        type: {
                          fields: [
                            {
                              name: "chain_id",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "version",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "block_number",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            },
                            {
                              name: "slot_number",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "timestamp",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 64
                              }
                            },
                            {
                              name: "coinbase",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              name: "fee_recipient",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              name: "gas_fees",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        name: "total_fees",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "total_mana_used",
                        type: {
                          kind: "field"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  name: "tx_context",
                  type: {
                    fields: [
                      {
                        name: "chain_id",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "version",
                        type: {
                          kind: "field"
                        }
                      },
                      {
                        name: "gas_settings",
                        type: {
                          fields: [
                            {
                              name: "gas_limits",
                              type: {
                                fields: [
                                  {
                                    name: "da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  },
                                  {
                                    name: "l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              name: "teardown_gas_limits",
                              type: {
                                fields: [
                                  {
                                    name: "da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  },
                                  {
                                    name: "l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              name: "max_fees_per_gas",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              name: "max_priority_fees_per_gas",
                              type: {
                                fields: [
                                  {
                                    name: "fee_per_da_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  },
                                  {
                                    name: "fee_per_l2_gas",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 128
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  name: "start_side_effect_counter",
                  type: {
                    kind: "integer",
                    sign: "unsigned",
                    width: 32
                  }
                }
              ],
              kind: "struct",
              path: "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            visibility: "private"
          },
          {
            name: "order_id_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "origin_data_bytes",
            type: {
              kind: "array",
              length: 301,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "filler_data_bytes",
            type: {
              kind: "array",
              length: 32,
              type: {
                kind: "integer",
                sign: "unsigned",
                width: 8
              }
            },
            visibility: "private"
          },
          {
            name: "message_leaf_index",
            type: {
              kind: "field"
            },
            visibility: "private"
          }
        ],
        return_type: {
          abi_type: {
            fields: [
              {
                name: "call_context",
                type: {
                  fields: [
                    {
                      name: "msg_sender",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "contract_address",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "function_selector",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 32
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      name: "is_static_call",
                      type: {
                        kind: "boolean"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                name: "args_hash",
                type: {
                  kind: "field"
                }
              },
              {
                name: "returns_hash",
                type: {
                  kind: "field"
                }
              },
              {
                name: "min_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "is_fee_payer",
                type: {
                  kind: "boolean"
                }
              },
              {
                name: "include_by_timestamp",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 64
                }
              },
              {
                name: "note_hash_read_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              name: "contract_address",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "nullifier_read_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::side_effect::counted::Counted"
                              }
                            },
                            {
                              name: "contract_address",
                              type: {
                                fields: [
                                  {
                                    name: "inner",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::scoped::Scoped"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "key_validation_requests_and_generators",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "request",
                              type: {
                                fields: [
                                  {
                                    name: "pk_m",
                                    type: {
                                      fields: [
                                        {
                                          name: "x",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "y",
                                          type: {
                                            kind: "field"
                                          }
                                        },
                                        {
                                          name: "is_infinite",
                                          type: {
                                            kind: "boolean"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    name: "sk_app",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              name: "sk_app_generator",
                              type: {
                                kind: "field"
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "note_hashes",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "nullifiers",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "value",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "note_hash",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "private_call_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 8,
                        type: {
                          fields: [
                            {
                              name: "call_context",
                              type: {
                                fields: [
                                  {
                                    name: "msg_sender",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "contract_address",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "function_selector",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "integer",
                                            sign: "unsigned",
                                            width: 32
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    name: "is_static_call",
                                    type: {
                                      kind: "boolean"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              name: "args_hash",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "returns_hash",
                              type: {
                                kind: "field"
                              }
                            },
                            {
                              name: "start_side_effect_counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            },
                            {
                              name: "end_side_effect_counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "public_call_requests",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 32,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "msg_sender",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "contract_address",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    name: "is_static_call",
                                    type: {
                                      kind: "boolean"
                                    }
                                  },
                                  {
                                    name: "calldata_hash",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "public_teardown_call_request",
                type: {
                  fields: [
                    {
                      name: "msg_sender",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "contract_address",
                      type: {
                        fields: [
                          {
                            name: "inner",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      name: "is_static_call",
                      type: {
                        kind: "boolean"
                      }
                    },
                    {
                      name: "calldata_hash",
                      type: {
                        kind: "field"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                name: "l2_to_l1_msgs",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 8,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "recipient",
                                    type: {
                                      fields: [
                                        {
                                          name: "inner",
                                          type: {
                                            kind: "field"
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    name: "content",
                                    type: {
                                      kind: "field"
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "private_logs",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 16,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "log",
                                    type: {
                                      fields: [
                                        {
                                          name: "fields",
                                          type: {
                                            kind: "array",
                                            length: 18,
                                            type: {
                                              kind: "field"
                                            }
                                          }
                                        },
                                        {
                                          name: "length",
                                          type: {
                                            kind: "integer",
                                            sign: "unsigned",
                                            width: 32
                                          }
                                        }
                                      ],
                                      kind: "struct",
                                      path: "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    name: "note_hash_counter",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "contract_class_logs_hashes",
                type: {
                  fields: [
                    {
                      name: "array",
                      type: {
                        kind: "array",
                        length: 1,
                        type: {
                          fields: [
                            {
                              name: "inner",
                              type: {
                                fields: [
                                  {
                                    name: "value",
                                    type: {
                                      kind: "field"
                                    }
                                  },
                                  {
                                    name: "length",
                                    type: {
                                      kind: "integer",
                                      sign: "unsigned",
                                      width: 32
                                    }
                                  }
                                ],
                                kind: "struct",
                                path: "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              name: "counter",
                              type: {
                                kind: "integer",
                                sign: "unsigned",
                                width: 32
                              }
                            }
                          ],
                          kind: "struct",
                          path: "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      name: "length",
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 32
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                name: "start_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "end_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "expected_non_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "expected_revertible_side_effect_counter",
                type: {
                  kind: "integer",
                  sign: "unsigned",
                  width: 32
                }
              },
              {
                name: "anchor_block_header",
                type: {
                  fields: [
                    {
                      name: "last_archive",
                      type: {
                        fields: [
                          {
                            name: "root",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "next_available_leaf_index",
                            type: {
                              kind: "field"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      name: "state",
                      type: {
                        fields: [
                          {
                            name: "l1_to_l2_message_tree",
                            type: {
                              fields: [
                                {
                                  name: "root",
                                  type: {
                                    kind: "field"
                                  }
                                },
                                {
                                  name: "next_available_leaf_index",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            name: "partial",
                            type: {
                              fields: [
                                {
                                  name: "note_hash_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  name: "nullifier_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  name: "public_data_tree",
                                  type: {
                                    fields: [
                                      {
                                        name: "root",
                                        type: {
                                          kind: "field"
                                        }
                                      },
                                      {
                                        name: "next_available_leaf_index",
                                        type: {
                                          kind: "field"
                                        }
                                      }
                                    ],
                                    kind: "struct",
                                    path: "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      name: "sponge_blob_hash",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "global_variables",
                      type: {
                        fields: [
                          {
                            name: "chain_id",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "version",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "block_number",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 32
                            }
                          },
                          {
                            name: "slot_number",
                            type: {
                              kind: "field"
                            }
                          },
                          {
                            name: "timestamp",
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 64
                            }
                          },
                          {
                            name: "coinbase",
                            type: {
                              fields: [
                                {
                                  name: "inner",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            name: "fee_recipient",
                            type: {
                              fields: [
                                {
                                  name: "inner",
                                  type: {
                                    kind: "field"
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            name: "gas_fees",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      name: "total_fees",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "total_mana_used",
                      type: {
                        kind: "field"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                name: "tx_context",
                type: {
                  fields: [
                    {
                      name: "chain_id",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "version",
                      type: {
                        kind: "field"
                      }
                    },
                    {
                      name: "gas_settings",
                      type: {
                        fields: [
                          {
                            name: "gas_limits",
                            type: {
                              fields: [
                                {
                                  name: "da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                },
                                {
                                  name: "l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            name: "teardown_gas_limits",
                            type: {
                              fields: [
                                {
                                  name: "da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                },
                                {
                                  name: "l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 32
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            name: "max_fees_per_gas",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            name: "max_priority_fees_per_gas",
                            type: {
                              fields: [
                                {
                                  name: "fee_per_da_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                },
                                {
                                  name: "fee_per_l2_gas",
                                  type: {
                                    kind: "integer",
                                    sign: "unsigned",
                                    width: 128
                                  }
                                }
                              ],
                              kind: "struct",
                              path: "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        kind: "struct",
                        path: "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  kind: "struct",
                  path: "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            kind: "struct",
            path: "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          visibility: "databus"
        }
      },
      bytecode: "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",
      custom_attributes: [
        "abi_private"
      ],
      debug_symbols: "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6BZ0C7oF3YJuQbeg26Xbpdul26Xbpdul26Xbpdul2223/fsRB3ES080TN9GI6XYTDzGItxG1BDiIk7iIm2hEug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6fboduh26Hboduh26Hboduh26HboVvQLegWdAu6Bd2CbkG3oFvQLeh26Xbpdul26Xbpdul26Xbpdul2281+P+IgTuIibqIRnXiIQaQba4mxlhhribGWGGuJsZYYa4mxlhhribGWGGuJsZYYa4mxlhhribGWGGuJsZYYa4mxlhhribGWGGuJsZYYa4mxlhhribGWGGuJsZYYa4mxlhhribGWGGuJsZYYa4mxlhhribGWGGuJsZYYa4mxlhhribGWGGuJsZYYa4mxlhhribGWGGuJsZYYa4mxlhhribGWGGuJsZYYa4mxlhhribGWGGuJsZYYa4mxlhhribGWGGuJsZYYa4mxlhhribGWGGuJsZYYa4mxlhhribGWGGuJsZYYa4mxlhhribGWGGuJsZY4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhribOWOGuJs5Y4a4mzljhrSbYn/j2B+JfvDe0/4iBO4iJuohGdeIhBpNug26DboNug26DboNug26DboNug26TbpFvWku9vV8xsWyzcxHS7iU48xM9trsTbmLXk4SBO4iJuohGdeIh0W3TbdNt023TbdNt023TbdMtaMnN1spY8vI1ZSx4O4iQu4iYa0Yl0M7oZ3ZxuTjenm9PN6eZ0c7o53ZxuTrdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt6Bb0C3oFnQLugXdgm5Bt6Bb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C+oKg3gbsz48HMRJ/Nbha4ez7BDEOmSHIA4zOwQLB3ESv/XN22PZIVhoRCf2bmaHYGHv5lk/4iBO4iLungMyD3TiIUbPITMPzMw/pBszf5j5w8wfZv4w84eZP7vPnbO5ksaVNK5kZh5zMK6kcSWZ+cPMH2b+MPOHmT/M/GHmj3PfkHkgV9K5ks59y8w/5Eoy84eZP8z8YeYPM3+Y+cPMH2b+HO7b4UoermRwJYMrmZn/fhPZsoWwMFfSEo3oxEPMY8s5ZOaBmfmHgziJi7iJRky3nOQ9xMz8t5L5ejmkMF8vd/Jecb5ernATjdg7FL9DDGKf6zF+xEGcxN6hbFgsNKITDzGIfT7E/BEHMY9iJBrRid+4eTsvWxNP3rjL1sSHWR8eDuIkLuImGtGJfTcpcPcAOIiTuIibaEQnHmIQ6WZ0M7oZ3YxuRjejm9HN6GZ0M7o53ZxuTjenm9PN6eZ0c7o53Zxuh26Hboduh26Hboduh26Hboduh25Bt6Bb0C3oFnQLugXdgm5BN95zjEu3S7dLt0u3S7dLt0u3S7dLt9tu9/cjDuIkLuImGtGJhxhEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbqxllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLLmvJZS25rCWXteSyllzWkstacllLbtcS/3Ut8V/XEv91LfFf1xL/dS3xX9cS/3Ut8V/XEv91LfHfj26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbvkN5fvbYZ69loWLuIlGdOIhBvE25jeUh3QzuhndjG5GN6Ob0c3oZnRzuvVTT89ey8JF3EQjOjHdPDGItzG/oez8b/MbysNJzGOLxE00ohMPMYi3Mb+hPBzESaRb0C3oFnQLugXdgm6Xbpdul26Xbpdul26Xbpdul2633bLX8ny/GObZa3m+NxF49loWLuImGtGJhxjE25jf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pCyWlMWSslhSFkvKYklZLCmLJWWxpCyWlMWSslhSFkvKYklZLCmLJWWxpCyWlMWSslhSFkvKYklZLCmLJWWxpCyWlMWSslhSFkvKYklZLCmLJWWxpCyWlMWSslhSFkvKYklZLCmLJWWxpCyWlMWSslhSFkvKYklZLCmLJWWxpCyWlMWSslhSFkvKYklZLCmLJWWxpCyWlMWSslhSFkvKYklZLCmLJWWxpCyWlMWSslhSFkvKYklZLCmLJWWxpCyWlMWSslhSFkvKYklZLCmLJWWxpCyWlMWSslhSFkvKYklZLCmLJWWxpCyWlMWSslhSFkvKYklZLCmLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyWyWCKLJbJYIoslslgiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosluliiiyW6WKKLJbpYoosldbGkLpbUxZK6WFIXS+piSV0sqYsldbGkLpbUxZK6WFIXS+piSV0sqYsldbGkLpbUxZK6WFIXS+piSV0sqYsldbGkLpbUxZK6WFIXS+piSV0sqYsldbGkLpbUxZK6WFIXS+piSV0sqYsldbGkLpbUxZK6WFIXS+piSV0sqYsldbGkLpbUxZK6WFIXS+piSV0sqYsldbGk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",
      is_unconstrained: false,
      name: "settle_private",
      verification_key: "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"
    },
    {
      abi: {
        error_types: {
          "10522114655416116165": {
            error_kind: "string",
            string: "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            error_kind: "string",
            string: "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            error_kind: "string",
            string: "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            error_kind: "string",
            string: "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            error_kind: "string",
            string: "push out of bounds"
          },
          "13060541637244024094": {
            error_kind: "fmtstring",
            item_types: [],
            length: 98
          },
          "13450089406971132036": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 144
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "16792019527863081935": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 77
          },
          "17154023812102399658": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 128
          },
          "17803644318014042523": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              }
            ],
            length: 58
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 132
          },
          "344423948968719440": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              },
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              },
              {
                kind: "field"
              }
            ],
            length: 98
          },
          "361444214588792908": {
            error_kind: "string",
            string: "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            error_kind: "string",
            string: "Value does not fit in field"
          },
          "4440399188109668273": {
            error_kind: "string",
            string: "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              },
              {
                kind: "field"
              }
            ],
            length: 48
          },
          "7995966536718645961": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              },
              {
                kind: "field"
              }
            ],
            length: 61
          },
          "8556029555939094797": {
            error_kind: "fmtstring",
            item_types: [],
            length: 75
          },
          "8992688621799713766": {
            error_kind: "string",
            string: "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            error_kind: "string",
            string: "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            error_kind: "string",
            string: "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            error_kind: "string",
            string: "Attempted to read past end of BoundedVec"
          }
        },
        parameters: [
          {
            name: "message_ciphertext",
            type: {
              fields: [
                {
                  name: "storage",
                  type: {
                    kind: "array",
                    length: 17,
                    type: {
                      kind: "field"
                    }
                  }
                },
                {
                  name: "len",
                  type: {
                    kind: "integer",
                    sign: "unsigned",
                    width: 32
                  }
                }
              ],
              kind: "struct",
              path: "std::collections::bounded_vec::BoundedVec"
            },
            visibility: "private"
          },
          {
            name: "message_context",
            type: {
              fields: [
                {
                  name: "tx_hash",
                  type: {
                    kind: "field"
                  }
                },
                {
                  name: "unique_note_hashes_in_tx",
                  type: {
                    fields: [
                      {
                        name: "storage",
                        type: {
                          kind: "array",
                          length: 64,
                          type: {
                            kind: "field"
                          }
                        }
                      },
                      {
                        name: "len",
                        type: {
                          kind: "integer",
                          sign: "unsigned",
                          width: 32
                        }
                      }
                    ],
                    kind: "struct",
                    path: "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  name: "first_nullifier_in_tx",
                  type: {
                    kind: "field"
                  }
                },
                {
                  name: "recipient",
                  type: {
                    fields: [
                      {
                        name: "inner",
                        type: {
                          kind: "field"
                        }
                      }
                    ],
                    kind: "struct",
                    path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              kind: "struct",
              path: "aztec::messages::processing::message_context::MessageContext"
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_utility"
      ],
      debug_symbols: "TJ3LsjS7bpzf5Yw9aIIECfpVPHBYvigUoZAifBnp5b0KSSBz4vOltX8milXIrq5G9/qPf/yP//lP/++f/+u//Nv/+vf/84///F/+4x//9L//5V//9V/++b/+67//9//2f//l3//t7//3P/7x+/6f+Pt/53/6R4x//Gf/+x/D/0z8z8L/OP5n438O/ifwPzf/5/7wP1jlYpWLVS5WuVjlYpWLVS5WuVhl/H7vf8f7X3v/O9//rve//v53v/8973/j/e9bb7z1xltvvPXGW2+89cZbb7z1xltvvPXGW8/eevbWs7eevfXsrWdvPXvr2VvP3nr21ptvvfnWm2+9+dabb7351ptvvfnWm2+9+dZbb7311ltvvfXWW2+99dZbb7311ltvvfXW87eev/X8redvPX/r+VvP33r+1vO/9c73vxf/u3/vf8f737/1xu+DWbAK/pYc84O/NUf+x6cgCu6D8ysYBX8r2/hgFqwCL/hb2eyDUxAF38rfEXztARgF38rxwSxYBV6wC05BFNwHX8sARkGtfGvlWyt/zTO/bfnaB3AKouAC7OsiwCiwglmwCrxgF5yCKKiVR608auVRK49aedTKo1YetfKolUetPGplq5W/1pr2gRXMglXgBbvgFETBffD1GKBWnrXyrJVnrTxr5Vkrz1p51sqzVl618qqVV628auVVK69aedXKq1ZetfKqlb1W9lrZa2Wvlb1W9lrZa2Wvlb1W9lp518q7Vt618q6Vd628a+VdK+9aedfKu1Y+tfKplU+tfGrlUyufWvnUyqdWPrXyqZWjVo5aOWrlqJWjVo5aOWrlrwenfxAF98HXg4BRYAWzYBV4wS6olW+tfN/KM3swPhgFVvC38pofrAIv2AWnIArug68HAaPACmrlUSuPWnm8RJrjFETBS6Rpv4JRYAWzYBV4Qa1stbLVyl8Prv0HXw8CRoEVzIJV4AW74BREQa28auVVK69a+evBdT5YBV6wC05BFNwHXw8CRoEV1MpeK3utnK+A64NTEAX3wdeDgFFgBbNgFXhBrbxr5V0r71r51MqnVj618qmVT618auVTK59a+dTKp1aOWjlq5aiVo1aOWjlq5aiVo1aOWjlq5Vsr31r51sq3Vr618q2Vb618a+VbK9+38vr9CkaBFcyCVeAFu+AUREGtPGrlUSuPWnnUyqNWHrXyqJVHrTxq5VErW61stbLVylYrW61stbLVylYrW61stfKslWetPGvlWSvPWnnWyrNWnrXyrJVnrbxq5VUrr1p51cqrVl618qqVV628auVVK3ut7LWy18peK3ut7LVy9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t6cFUPrurBVT24qgdX9eCqHlzVg6t60KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9etCrB7160KsHvXrQqwe9enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHd/Xgrh7c1YO7enBXD+7qwV09uKsHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnevBUD57qwVM9eKoHT/XgqR481YOnejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgejejCqB6N6MKoHo3owqgcje/B8YAWz4G/lPT7wgl1wCqLgPvh6EDAKrGAW1MpRK0etHLVy1MpRK99a+dbKt1a+tfKtlW+tfGvlWyvfWvm+le/vVzAKrGAWrAIv2AWnIApq5VErj1p51MqjVh618qiVR608auVRK49a2Wplq5WtVrZa2Wplq5WtVrZa2Wplq5VnrTxr5Vkrz1p51sqzVp618qyVZ608a+VVK69aedXKq1ZetfKqlVetvGrlVSuvWtlrZa+VvVb2WtlrZa+VvVb2WtlrZa+Vd628a+VdK+9aedfKu1betfKulXetvGvlUyufWvnUyqdWrh681YO3evBWD97qwVs9eKsHb/XgrR681YO3evBWD97qwVs9eKsHb/XgrR681YO3evBWD97qwVs9eKsHb/XgrR681YN/n7L/mkaTNc2m1eRNu+k0RVN7jPYY7THaY7THaI/RHqM9RnuM9hjtYe1h7WHtYe1h7WHtYe1h7WHtYe0x22O2x2yP2R6zPWZ7zPaY7THbY7bHao/VHqs9Vnus9ljtsdpjtcdqj9Ue3h7eHt4e3h7eHt4e3h7eHt4e3h67PXZ77PbY7bHbY7fHbo/dHrs9dnuc9jjtcdrjtMdpj9Mepz1Oe5z2OO0R7RHtEe0R7RHtEe0R7RHtEe0R7XHb47bHbY/bHrc9bnvc9rjtcduj+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPR/f56D4f3eej+3x0n4/u89F9PrrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z6373LrPrfvcus+t+9y6z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfT67z2f3+ew+n93ns/t8dp/P7vPZfZ6zShvT1dF0i7LPT9JosqbZtJq8aTedpmi6j3Jw6dFosqbZtJq8aTedpmhqj9Eeoz1Ge4z2GO0x2mO0x2iP0R6jPaw9rD2sPaw9rD2sPaw9rD2sPaw9ZnvM9pjtMdtjtsdsj9kesz1me8z2WO2x2mO1x2qP1R6rPVZ7rPZY7bHaw9vD28Pbw9vD28Pbw9vD28Pbw9tjt8duj90euz12e+z22O2x22O3x26P0x6nPU57nPY47XHa47THaY/THqc9oj2iPaI9oj2iPaI9oj2iPaI9oj26z1f3+eo+X93nq/s856L2TdpNpyma7qMcjno0mqxpNq0mb9pNpyma2mO0x2iP0R6jPUZ7jPYY7THaY7THaA9rD2sPaw9rD2sPaw9rD2sPaw9rj9kesz1me8z2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TLdInMRFdOImHmIQbyOyBDiIdDt0O3Q7dDt0O3Q7dDt0C7oF3YJuQbegW9At6BZ0C7oF3S7dLt0u3S7dLt0u3S7dLt0u3W67rd+POIhGnMRFdOImHmIQ6TboNug26DboNug26DboNug26DboZnQzuhndjG5GN6Ob0c3oZnQzuk26TbpNuk26TbpNuk26ZZZ8v3trOYBYeBszS77fw7WcQSw04iQuohM38RCDeBudbk43p5vTzenmdHO6Od2cbk63TbdNt023TbdNt023TbdNt023TbdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt6Bb0C3oFnQLugXdgm5Bt6Bb0O3S7dLt0u3S7dLt0u3S7dLt0u22W44vFg6iESdxEZ24iYcYRLoNug26DboNug26DboNug26DboNuhndjG5GN6Ob0c3oZnQzuhndjG6TbpNuk26TbpNuk26TbpNuk26TbswSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklm1mymSWbWbKZJZtZspklh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKQJTtxEZ24iYcYxNuILAEOohHptui26Lbotui26Lbo5nRzujndnG5ON6dbZonhzxkcYhA/N8uNyix5OIifm53ESVxEJ27iIQbxNmaWPBxEuh26Hboduh26Hboduh26Bd0ySyx3J7Pk4SQuohM38RCDeBszSx7S7dLt0u3S7dLt0u3S7dLttluOehYOohEncRGduImHGES6DboNug26DboNug26DboNug26DboZ3YxuRjejm9HN6GZ0M7oZ3Yxuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbk43p5vTzenmdHO6Od2cbk43p9um26bbptum26bbptum26bbptum26Hboduh26Hboduh26Hboduh26Fb0I1ZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJgllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxmyWWWXGbJZZZcZsllllxkSSQOohEncRGduImHGMTbeOh26Hboduh26Hboduh26HbodugWdAu6Bd2CbkG3oFvQLegWdAu6Xbpdul26Xbpdul26Xbpdul263XKbv9+POIhGnMRFdOImHmIQ6TboNug26DboNug26DboNug26DboZnTLLPn+LtzMQdbCSfzcvj/zNXOWtXATDzGItzGz5OEgGnES6TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26OZ0c7o53ZxuTjenm9PN6eZ0c7ptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbpdul26Xbpdul26Xbpdul26XbrfdMPf6cBCNOImL6MRNPMQg0m3QbdBt0G3QbdBt0G3QbdBt0G3QzehmdDO6Gd2YJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1lizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLMHca/4BXMy9PnRiup3EQwziLcTc68NBNOIkLqITN/EQ020k3kZkCXAQjTiJi+jETTxEug26Gd2MbkY3o5vRzehmdDO6Gd2MbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui25ON6eb083p5nRzujndnG5ON6fbphuy5CYacRIX0YmbeIhBvI3IEiDdDt0O3TJLViQ6cRM/t4X/Noi3MbNk/RIH0YiTuIhO3MRDDOJtvHS7dLt0u3S7dLt0u3S7dLt0u+2GudeHg2jESVxEJ27iIQaRboNug26DboNug26DboNug26DboNuRjejm9HN6GZ0M7oZ3YxuRjej26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbopvTzenmdHO6Od2cbk43p5vTzem26bbptum26bbptum26bbptum26XbohmevnmjESVxEJ27iIQbxNuLZK5BuQbegW9At6BZ0C7oF3YJul26Xbpdul26Xbpdul26Xbpdut90w9/pwEI04iYvoxE08xCDSbdBt0G3QbdBt0G3QbdBt0G3QbdDN6GZ0M7oZ3YxuRjejm9HN6GZ0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdHO6Od2cbk43p5vTzenmdHO6Od023TbdMkv8lziJi/i5+UzcxEP83L4/Xzcx9wrMLHk4iEacxEV04iYeIt0O3YJuQbegW9At6BZ0C7oF3YJuQbdLt0u3S7dLt0u3S7dLt0u3S7fbbph7fTiIRpzERXTiJh5iEOk26DboNug26DboNug26DboNug26GZ0M7oZ3YxuRjejm9HN6GZ0M7pNuk26TbpNuk26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",
      is_unconstrained: true,
      name: "process_message"
    },
    {
      abi: {
        error_types: {
          "10117862570525238354": {
            error_kind: "string",
            string: "Function _fill_private can only be called by the same contract"
          },
          "10342230159609614507": {
            error_kind: "string",
            string: "Invalid fill deadline"
          },
          "10452171673112122008": {
            error_kind: "string",
            string: "Function _assert_nonce_and_set_order_status_private can only be called by the same contract"
          },
          "10701657982931684311": {
            error_kind: "string",
            string: "Function get_order_status can only be called statically"
          },
          "10886555653199409003": {
            error_kind: "string",
            string: "Invalid nonce"
          },
          "11238168246423926608": {
            error_kind: "string",
            string: "Order fill expired"
          },
          "12142166718796425542": {
            error_kind: "string",
            string: "Order not opened"
          },
          "12469291177396340830": {
            error_kind: "string",
            string: "call to assert_max_bit_size"
          },
          "13455385521185560676": {
            error_kind: "string",
            string: "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14332229579798040722": {
            error_kind: "string",
            string: "Function _emit_open_private can only be called by the same contract"
          },
          "14415304921900233953": {
            error_kind: "string",
            string: "Initializer address is not the contract deployer"
          },
          "14658772241615233463": {
            error_kind: "string",
            string: "Invalid sender"
          },
          "14731960565267904813": {
            error_kind: "string",
            string: "Invalid order"
          },
          "14942831874215426972": {
            error_kind: "string",
            string: "Invalid destination domain"
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "1511320103103073895": {
            error_kind: "string",
            string: "Function _trigger_settlement can only be called by the same contract"
          },
          "15130664124905246775": {
            error_kind: "string",
            string: "L1-to-L2 message is already nullified"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "16070420376462343922": {
            error_kind: "string",
            string: "Not a public order"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "16464709583191233416": {
            error_kind: "string",
            string: "Invalid id"
          },
          "1660820086751817080": {
            error_kind: "string",
            string: "Order not expired"
          },
          "16810041750452690220": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              }
            ],
            length: 27
          },
          "16882345102269044371": {
            error_kind: "string",
            string: "Tried to consume nonexistent L1-to-L2 message"
          },
          "17366381410802578161": {
            error_kind: "string",
            string: "Invalid origin domain"
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "2265285467782432990": {
            error_kind: "string",
            string: "Function _assert_order_status_private can only be called by the same contract"
          },
          "2417591072343638585": {
            error_kind: "string",
            string: "Order is expired"
          },
          "3154441984421085216": {
            error_kind: "string",
            string: "Invalid data type"
          },
          "3396427393764509880": {
            error_kind: "string",
            string: "Function _check_if_order_is_claimable_private can only be called by the same contract"
          },
          "361444214588792908": {
            error_kind: "string",
            string: "attempt to multiply with overflow"
          },
          "459713770342432051": {
            error_kind: "string",
            string: "Not initialized"
          },
          "5167727358818866312": {
            error_kind: "string",
            string: "Invalid destination settler"
          },
          "5182439867169668514": {
            error_kind: "string",
            string: "Function _emit_settled_private can only be called by the same contract"
          },
          "6710068896262816422": {
            error_kind: "string",
            string: "Function _check_refund_private can only be called by the same contract"
          },
          "6938571148302402705": {
            error_kind: "string",
            string: "Function get_order_refund_block_number can only be called statically"
          },
          "7335179940076463214": {
            error_kind: "string",
            string: "Invalid status"
          },
          "7826545090857484415": {
            error_kind: "string",
            string: "Function _update_order_status_private can only be called by the same contract"
          },
          "8228371833434187583": {
            error_kind: "string",
            string: "Trying to read from uninitialized PublicImmutable"
          },
          "90719278298450020": {
            error_kind: "string",
            string: "Function get_order_settlement_block_number can only be called statically"
          },
          "9967937311635654895": {
            error_kind: "string",
            string: "Initialization hash does not match"
          }
        },
        parameters: [
          {
            name: "selector",
            type: {
              kind: "field"
            },
            visibility: "private"
          }
        ],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_public"
      ],
      debug_symbols: "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",
      is_unconstrained: true,
      name: "public_dispatch"
    },
    {
      abi: {
        error_types: {
          "10522114655416116165": {
            error_kind: "string",
            string: "Can't read a transient note with a zero contract address"
          },
          "10791800398362570014": {
            error_kind: "string",
            string: "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            error_kind: "string",
            string: "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            error_kind: "string",
            string: "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            error_kind: "string",
            string: "push out of bounds"
          },
          "13060541637244024094": {
            error_kind: "fmtstring",
            item_types: [],
            length: 98
          },
          "13450089406971132036": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 144
          },
          "14990209321349310352": {
            error_kind: "string",
            string: "attempt to add with overflow"
          },
          "15764276373176857197": {
            error_kind: "string",
            string: "Stack too deep"
          },
          "16431471497789672479": {
            error_kind: "string",
            string: "Index out of bounds"
          },
          "16792019527863081935": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 77
          },
          "17154023812102399658": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 128
          },
          "17803644318014042523": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              }
            ],
            length: 58
          },
          "1998584279744703196": {
            error_kind: "string",
            string: "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              }
            ],
            length: 132
          },
          "344423948968719440": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              },
              {
                kind: "integer",
                sign: "unsigned",
                width: 32
              },
              {
                kind: "field"
              }
            ],
            length: 98
          },
          "361444214588792908": {
            error_kind: "string",
            string: "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            error_kind: "string",
            string: "Value does not fit in field"
          },
          "4440399188109668273": {
            error_kind: "string",
            string: "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              },
              {
                kind: "field"
              }
            ],
            length: 48
          },
          "7995966536718645961": {
            error_kind: "fmtstring",
            item_types: [
              {
                kind: "field"
              },
              {
                kind: "field"
              }
            ],
            length: 61
          },
          "8556029555939094797": {
            error_kind: "fmtstring",
            item_types: [],
            length: 75
          },
          "8992688621799713766": {
            error_kind: "string",
            string: "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            error_kind: "string",
            string: "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            error_kind: "string",
            string: "Attempted to read past the length of a CapsuleArray"
          },
          "992401946138144806": {
            error_kind: "string",
            string: "Attempted to read past end of BoundedVec"
          }
        },
        parameters: [],
        return_type: null
      },
      bytecode: "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",
      custom_attributes: [
        "abi_utility"
      ],
      debug_symbols: "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i26LbpklM1cns+ThIE7iIm7iIRrRiUGk26Hboduh26Hboduh26Hboduh26Gb0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzugXdgm5Bt6Bb0C3oFnQLugXdgm6Xbpdul26Xbpdul26Xbpdul2633bIptHAQJ3ERN/EQjejEINJt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RjVkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJZdZcpkll1lymSWXWXKZJZdZcpkll1lymSWXWXKZJZdZcpkll1lymSWXWXKZJRdZEom3EVkCHMRJXMRNPEQjOpFuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hboduh25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb0y2z5PtrbzMbWQsH8XPLP96VvayFm3iIRnRiEG9jZsnDQaTbpdul26Xbpdul26XbLbeVza2FgziJi7iJh2hEJwaRboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hboduh25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pFnQLugXdgm5Bt6Bb0C3oFnQLul26Xbpdul26Xbpdul26XbpdujFLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsG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",
      is_unconstrained: true,
      name: "sync_private_state"
    }
  ],
  name: "AztecGateway7683",
  noir_version: "1.0.0-beta.15+1a930357477fc0c210dc5a8960680282d4cfa24e",
  outputs: {
    globals: {
      storage: [
        {
          fields: [
            {
              name: "contract_name",
              value: {
                kind: "string",
                value: "ContractInstanceRegistry"
              }
            },
            {
              name: "fields",
              value: {
                fields: [
                  {
                    name: "updated_class_ids",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  }
                ],
                kind: "struct"
              }
            }
          ],
          kind: "struct"
        },
        {
          fields: [
            {
              name: "contract_name",
              value: {
                kind: "string",
                value: "Token"
              }
            },
            {
              name: "fields",
              value: {
                fields: [
                  {
                    name: "name",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  },
                  {
                    name: "symbol",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  },
                  {
                    name: "decimals",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  },
                  {
                    name: "private_balances",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  },
                  {
                    name: "total_supply",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  },
                  {
                    name: "public_balances",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  },
                  {
                    name: "minter",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  },
                  {
                    name: "upgrade_authority",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "000000000000000000000000000000000000000000000000000000000000000c"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  },
                  {
                    name: "asset",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "000000000000000000000000000000000000000000000000000000000000000e"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  }
                ],
                kind: "struct"
              }
            }
          ],
          kind: "struct"
        },
        {
          fields: [
            {
              name: "contract_name",
              value: {
                kind: "string",
                value: "AztecGateway7683"
              }
            },
            {
              name: "fields",
              value: {
                fields: [
                  {
                    name: "config",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  },
                  {
                    name: "claimable_orders",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  },
                  {
                    name: "order_status",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  },
                  {
                    name: "used_nonces",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  },
                  {
                    name: "orders_settlement_block_numbers",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  },
                  {
                    name: "orders_refund_block_numbers",
                    value: {
                      fields: [
                        {
                          name: "slot",
                          value: {
                            kind: "integer",
                            sign: false,
                            value: "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      kind: "struct"
                    }
                  }
                ],
                kind: "struct"
              }
            }
          ],
          kind: "struct"
        }
      ]
    },
    structs: {
      functions: [
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id",
                    type: {
                      kind: "field"
                    }
                  },
                  {
                    name: "_nonce",
                    type: {
                      kind: "field"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::_assert_nonce_and_set_order_status_private_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::_assert_nonce_and_set_order_status_private_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id",
                    type: {
                      kind: "field"
                    }
                  },
                  {
                    name: "_status",
                    type: {
                      kind: "field"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::_assert_order_status_private_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::_assert_order_status_private_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id",
                    type: {
                      kind: "field"
                    }
                  },
                  {
                    name: "_claimable_order_commitment",
                    type: {
                      kind: "field"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::_check_if_order_is_claimable_private_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::_check_if_order_is_claimable_private_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id",
                    type: {
                      kind: "field"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::_check_refund_private_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::_check_refund_private_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_resolved_order_bytes",
                    type: {
                      kind: "array",
                      length: 613,
                      type: {
                        kind: "field"
                      }
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::_emit_open_private_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::_emit_open_private_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_receiver",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::_emit_settled_private_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::_emit_settled_private_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id",
                    type: {
                      kind: "field"
                    }
                  },
                  {
                    name: "_order_id_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_origin_data_bytes",
                    type: {
                      kind: "array",
                      length: 301,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_filler_data_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_fill_deadline",
                    type: {
                      kind: "integer",
                      sign: "unsigned",
                      width: 32
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::_fill_private_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::_fill_private_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id",
                    type: {
                      kind: "field"
                    }
                  },
                  {
                    name: "_content_hash",
                    type: {
                      kind: "field"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::_trigger_settlement_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::_trigger_settlement_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id",
                    type: {
                      kind: "field"
                    }
                  },
                  {
                    name: "_status",
                    type: {
                      kind: "field"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::_update_order_status_private_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::_update_order_status_private_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_secret",
                    type: {
                      kind: "field"
                    }
                  },
                  {
                    name: "_order_id_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_origin_data_bytes",
                    type: {
                      kind: "array",
                      length: 301,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_filler_data_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::claim_private_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::claim_private_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_order_data_bytes",
                    type: {
                      kind: "array",
                      length: 301,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_message_leaf_index",
                    type: {
                      kind: "field"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::claim_refund_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::claim_refund_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_secret",
                    type: {
                      kind: "field"
                    }
                  },
                  {
                    name: "_order_id_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_origin_data_bytes",
                    type: {
                      kind: "array",
                      length: 301,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_message_leaf_index",
                    type: {
                      kind: "field"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::claim_refund_private_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::claim_refund_private_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_l2Gateway",
                    type: {
                      fields: [
                        {
                          name: "inner",
                          type: {
                            kind: "field"
                          }
                        }
                      ],
                      kind: "struct",
                      path: "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    name: "_l2GatewayDomain",
                    type: {
                      kind: "integer",
                      sign: "unsigned",
                      width: 32
                    }
                  },
                  {
                    name: "_forwarder",
                    type: {
                      fields: [
                        {
                          name: "inner",
                          type: {
                            kind: "field"
                          }
                        }
                      ],
                      kind: "struct",
                      path: "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::constructor_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::constructor_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_origin_data_bytes",
                    type: {
                      kind: "array",
                      length: 301,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_filler_data_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::fill_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::fill_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_origin_data_bytes",
                    type: {
                      kind: "array",
                      length: 301,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_filler_data_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::fill_private_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::fill_private_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id",
                    type: {
                      kind: "field"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::get_order_refund_block_number_parameters"
              }
            },
            {
              name: "return_type",
              type: {
                kind: "field"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::get_order_refund_block_number_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id",
                    type: {
                      kind: "field"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::get_order_settlement_block_number_parameters"
              }
            },
            {
              name: "return_type",
              type: {
                kind: "field"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::get_order_settlement_block_number_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id",
                    type: {
                      kind: "field"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::get_order_status_parameters"
              }
            },
            {
              name: "return_type",
              type: {
                kind: "field"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::get_order_status_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order",
                    type: {
                      fields: [
                        {
                          name: "fill_deadline",
                          type: {
                            kind: "integer",
                            sign: "unsigned",
                            width: 32
                          }
                        },
                        {
                          name: "order_data_type",
                          type: {
                            kind: "array",
                            length: 32,
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 8
                            }
                          }
                        },
                        {
                          name: "order_data",
                          type: {
                            kind: "array",
                            length: 301,
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 8
                            }
                          }
                        }
                      ],
                      kind: "struct",
                      path: "types::onchain_cross_chain_order::OnchainCrossChainOrder"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::open_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::open_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order",
                    type: {
                      fields: [
                        {
                          name: "fill_deadline",
                          type: {
                            kind: "integer",
                            sign: "unsigned",
                            width: 32
                          }
                        },
                        {
                          name: "order_data_type",
                          type: {
                            kind: "array",
                            length: 32,
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 8
                            }
                          }
                        },
                        {
                          name: "order_data",
                          type: {
                            kind: "array",
                            length: 301,
                            type: {
                              kind: "integer",
                              sign: "unsigned",
                              width: 8
                            }
                          }
                        }
                      ],
                      kind: "struct",
                      path: "types::onchain_cross_chain_order::OnchainCrossChainOrder"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::open_private_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::open_private_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "message_ciphertext",
                    type: {
                      fields: [
                        {
                          name: "storage",
                          type: {
                            kind: "array",
                            length: 17,
                            type: {
                              kind: "field"
                            }
                          }
                        },
                        {
                          name: "len",
                          type: {
                            kind: "integer",
                            sign: "unsigned",
                            width: 32
                          }
                        }
                      ],
                      kind: "struct",
                      path: "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    name: "message_context",
                    type: {
                      fields: [
                        {
                          name: "tx_hash",
                          type: {
                            kind: "field"
                          }
                        },
                        {
                          name: "unique_note_hashes_in_tx",
                          type: {
                            fields: [
                              {
                                name: "storage",
                                type: {
                                  kind: "array",
                                  length: 64,
                                  type: {
                                    kind: "field"
                                  }
                                }
                              },
                              {
                                name: "len",
                                type: {
                                  kind: "integer",
                                  sign: "unsigned",
                                  width: 32
                                }
                              }
                            ],
                            kind: "struct",
                            path: "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          name: "first_nullifier_in_tx",
                          type: {
                            kind: "field"
                          }
                        },
                        {
                          name: "recipient",
                          type: {
                            fields: [
                              {
                                name: "inner",
                                type: {
                                  kind: "field"
                                }
                              }
                            ],
                            kind: "struct",
                            path: "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      kind: "struct",
                      path: "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::process_message_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::process_message_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_origin_data_bytes",
                    type: {
                      kind: "array",
                      length: 301,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::refund_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::refund_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_origin_data_bytes",
                    type: {
                      kind: "array",
                      length: 301,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_filler_data_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_message_leaf_index",
                    type: {
                      kind: "field"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::settle_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::settle_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [
                  {
                    name: "_order_id_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_origin_data_bytes",
                    type: {
                      kind: "array",
                      length: 301,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_filler_data_bytes",
                    type: {
                      kind: "array",
                      length: 32,
                      type: {
                        kind: "integer",
                        sign: "unsigned",
                        width: 8
                      }
                    }
                  },
                  {
                    name: "_message_leaf_index",
                    type: {
                      kind: "field"
                    }
                  }
                ],
                kind: "struct",
                path: "AztecGateway7683::settle_private_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::settle_private_abi"
        },
        {
          fields: [
            {
              name: "parameters",
              type: {
                fields: [],
                kind: "struct",
                path: "AztecGateway7683::sync_private_state_parameters"
              }
            }
          ],
          kind: "struct",
          path: "AztecGateway7683::sync_private_state_abi"
        }
      ]
    }
  },
  transpiled: true
};

// src/utils/artifacts/AztecGateway7683/AztecGateway7683.ts
var AztecGateway7683ContractArtifact = loadContractArtifact(aztec_gateway_7683_AztecGateway7683_default);
var AztecGateway7683Contract = class _AztecGateway7683Contract extends ContractBase {
  constructor(address, wallet) {
    super(address, AztecGateway7683ContractArtifact, wallet);
  }
  /**
   * Creates a contract instance.
   * @param address - The deployed contract's address.
   * @param wallet - The wallet to use when interacting with the contract.
   * @returns A new Contract instance.
   */
  static at(address, wallet) {
    return Contract.at(address, _AztecGateway7683Contract.artifact, wallet);
  }
  /**
   * Creates a tx to deploy a new instance of this contract.
   */
  static deploy(wallet, l2Gateway, l2GatewayDomain, forwarder) {
    return new DeployMethod(PublicKeys.default(), wallet, AztecGateway7683ContractArtifact, (instance, wallet2) => _AztecGateway7683Contract.at(instance.address, wallet2), Array.from(arguments).slice(1));
  }
  /**
   * Creates a tx to deploy a new instance of this contract using the specified public keys hash to derive the address.
   */
  static deployWithPublicKeys(publicKeys, wallet, l2Gateway, l2GatewayDomain, forwarder) {
    return new DeployMethod(publicKeys, wallet, AztecGateway7683ContractArtifact, (instance, wallet2) => _AztecGateway7683Contract.at(instance.address, wallet2), Array.from(arguments).slice(2));
  }
  /**
   * Creates a tx to deploy a new instance of this contract using the specified constructor method.
   */
  static deployWithOpts(opts, ...args) {
    return new DeployMethod(
      opts.publicKeys ?? PublicKeys.default(),
      opts.wallet,
      AztecGateway7683ContractArtifact,
      (instance, wallet) => _AztecGateway7683Contract.at(instance.address, wallet),
      Array.from(arguments).slice(1),
      opts.method ?? "constructor"
    );
  }
  /**
   * Returns this contract's artifact.
   */
  static get artifact() {
    return AztecGateway7683ContractArtifact;
  }
  /**
   * Returns this contract's artifact with public bytecode.
   */
  static get artifactForPublic() {
    return loadContractArtifactForPublic(aztec_gateway_7683_AztecGateway7683_default);
  }
  static get storage() {
    return {
      config: {
        slot: new Fr(1n)
      },
      claimable_orders: {
        slot: new Fr(5n)
      },
      order_status: {
        slot: new Fr(6n)
      },
      used_nonces: {
        slot: new Fr(7n)
      },
      orders_settlement_block_numbers: {
        slot: new Fr(8n)
      },
      orders_refund_block_numbers: {
        slot: new Fr(9n)
      }
    };
  }
};

// src/context/BridgeContext.ts
import { SponsoredFPCContractArtifact as SponsoredFPCContractArtifact2 } from "@aztec/noir-contracts.js/SponsoredFPC";

// src/utils/index.ts
import { hexToBytes as hexToBytes2 } from "viem";
import {
  SetPublicAuthwitContractInteraction
} from "@aztec/aztec.js/authorization";

// src/utils/fpc.ts
import { SponsoredFeePaymentMethod } from "@aztec/aztec.js/fee";
import { SponsoredFPCContractArtifact } from "@aztec/noir-contracts.js/SponsoredFPC";
import { AztecAddress } from "@aztec/aztec.js/addresses";
import { createAztecNodeClient } from "@aztec/aztec.js/node";

// src/constants/index.ts
import { base, baseSepolia, sepolia } from "viem/chains";
import { padHex } from "viem";
var ORDER_DATA_TYPE = "0xf00c3bf60c73eb97097f1c9835537da014e0b755fe94b25d7ac8401df66716a0";
var REFUND_ORDER_TYPE = "0x66ad36d8ca106da96563556152aba4b916ec696ecdd08a3e5ed368f4e473a538";
var SETTLE_ORDER_TYPE = "0x191ea776bd6e0cd56a6d44ba4aea2fec468b4a0b4c1d880d4025929eeb615d0d";
var PUBLIC_ORDER = 0;
var PRIVATE_ORDER = 1;
var PUBLIC_ORDER_WITH_HOOK = 2;
var PRIVATE_ORDER_WITH_HOOK = 3;
var PRIVATE_SENDER = padHex("0x");
var OPENED = 1;
var FILLED = 2;
var FILLED_PRIVATELY = 3;
var AZTEC_VERSION = 1647720761;
var FORWARDER_SETTLE_ORDER_SLOT = 2n;
var FORWARDER_REFUNDED_ORDERS_SLOT = 3n;
var L2_GATEWAY_FILLED_ORDERS_SLOT = 51n;
var L2_GATEWAY_REFUNDED_ORDERS_SLOT = 52n;
var DEFAULT_AZTEC_ROLLUP_L1_ADDRESS = "0x5d84b64b0b2f468df065d8cf01fff88a73238a13";
var DEFAULT_FORWARDER_ADDRESS = "0xBA52853D129eAdDE133be8ba13df90e6DE414dD0";
var DEFAULT_OP_STACK_ANCHOR_REGISTRY = "0x0729957c92A1F50590A84cb2D65D761093f3f8eB";
var aztecRollupContractL1Addresses = {
  [sepolia.id]: DEFAULT_AZTEC_ROLLUP_L1_ADDRESS
};
var forwarderAddresses = {
  [sepolia.id]: DEFAULT_FORWARDER_ADDRESS
};
var opStackAnchorRegistryAddresses = {
  [sepolia.id]: DEFAULT_OP_STACK_ANCHOR_REGISTRY
};
var FORWARDER_CHAIN = baseSepolia;
var DEFAULT_FORWARDER_CHAIN_ID = sepolia.id;
var AZGUARD_CHAIN_ID = 1654394782;
var aztecSepolia = {
  id: 999999,
  name: "Aztec Sepolia",
  rpcUrls: {
    "aztec-devnet": {
      http: [process.env.AZTEC_RPC_URL || "https://devnet-6.aztec-labs.com"]
    },
    default: {
      http: [process.env.AZTEC_RPC_URL || "https://devnet-6.aztec-labs.com"]
    }
  }
};
var defaultChainsConfig = {
  baseSepolia: {
    type: "EVM" /* EVM */,
    chain: baseSepolia,
    gatewayAddress: "0xaD687d773D3980FBf792BD64deD00FCc538506f9"
    // Updated from deploy_2026-01-27_15-17-55.json
  },
  baseMainnet: {
    type: "EVM" /* EVM */,
    chain: base,
    gatewayAddress: "0x9a2e16BF70EA94b2302e06276040Ab1144dc5432"
    // Base mainnet L2Gateway with trustedSettle (deployed 2026-02-05)
  },
  aztecDevnet: {
    type: "AZTEC" /* AZTEC */,
    chain: aztecSepolia,
    gatewayAddress: "0x0ff58cdb50e47fe891cac7f3a111ef54021bd584f556a3db17be518d49057894"
    // Updated from deploy_2026-01-27_15-17-55.json
  }
};
var chainsConfig = defaultChainsConfig;

// src/utils/fpc.ts
var CANONICAL_SPONSORED_FPC_ADDRESS = AztecAddress.fromString(
  "0x1586f476995be97f07ebd415340a14be48dc28c6c661cc6bdddb80ae790caa4e"
);
async function getSponsoredFPCInstance(rpcUrl) {
  const nodeUrl = rpcUrl ?? defaultChainsConfig.aztecDevnet.chain.rpcUrls.default.http[0];
  const node = createAztecNodeClient(nodeUrl);
  const instance = await node.getContract(CANONICAL_SPONSORED_FPC_ADDRESS);
  if (!instance) {
    throw new Error(`Sponsored FPC not found at ${CANONICAL_SPONSORED_FPC_ADDRESS.toString()}`);
  }
  return instance;
}
async function getSponsoredFPCAddress() {
  return CANONICAL_SPONSORED_FPC_ADDRESS;
}
async function getSponsporedFeePaymentMethod() {
  return new SponsoredFeePaymentMethod(CANONICAL_SPONSORED_FPC_ADDRESS);
}

// src/utils/gateway.ts
import { decodeAbiParameters } from "viem";
import { Fr as Fr2 } from "@aztec/aztec.js/fields";

// src/utils/abi/l2Gateway7683.ts
var l2Gateway7683_default = [
  {
    type: "constructor",
    inputs: [
      {
        name: "permit2",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "AZTEC_CHAIN_ID",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint32",
        internalType: "uint32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "FILLED",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "OPENED",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "PERMIT2",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract IPermit2"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "REFUNDED",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "RESOLVED_CROSS_CHAIN_ORDER_TYPEHASH",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "SETTLED",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "UNKNOWN",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "aztecGateway7683",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "fill",
    inputs: [
      {
        name: "_orderId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "_originData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "_fillerData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "filledOrders",
    inputs: [
      {
        name: "orderId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "originData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "fillerData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "filledOrdersCommitments",
    inputs: [
      {
        name: "orderId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "commitment",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "forwarder",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "invalidateNonces",
    inputs: [
      {
        name: "_nonce",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "isValidNonce",
    inputs: [
      {
        name: "_from",
        type: "address",
        internalType: "address"
      },
      {
        name: "_nonce",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "open",
    inputs: [
      {
        name: "_order",
        type: "tuple",
        internalType: "struct OnchainCrossChainOrder",
        components: [
          {
            name: "fillDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "orderDataType",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "orderData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "openFor",
    inputs: [
      {
        name: "_order",
        type: "tuple",
        internalType: "struct GaslessCrossChainOrder",
        components: [
          {
            name: "originSettler",
            type: "address",
            internalType: "address"
          },
          {
            name: "user",
            type: "address",
            internalType: "address"
          },
          {
            name: "nonce",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "originChainId",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "openDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "fillDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "orderDataType",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "orderData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "_signature",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "_originFillerData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "openOrders",
    inputs: [
      {
        name: "orderId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "orderData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "orderStatus",
    inputs: [
      {
        name: "orderId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "status",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "owner",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "refund",
    inputs: [
      {
        name: "_orders",
        type: "tuple[]",
        internalType: "struct OnchainCrossChainOrder[]",
        components: [
          {
            name: "fillDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "orderDataType",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "orderData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "refund",
    inputs: [
      {
        name: "message",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "stateProofParams",
        type: "tuple",
        internalType: "struct StateValidator.StateProofParameters",
        components: [
          {
            name: "beaconRoot",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "beaconOracleTimestamp",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "executionStateRoot",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "stateRootProof",
            type: "bytes32[]",
            internalType: "bytes32[]"
          }
        ]
      },
      {
        name: "accountProofParams",
        type: "tuple",
        internalType: "struct StateValidator.AccountProofParameters",
        components: [
          {
            name: "storageKey",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "storageValue",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "accountProof",
            type: "bytes[]",
            internalType: "bytes[]"
          },
          {
            name: "storageProof",
            type: "bytes[]",
            internalType: "bytes[]"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "refund",
    inputs: [
      {
        name: "_orders",
        type: "tuple[]",
        internalType: "struct GaslessCrossChainOrder[]",
        components: [
          {
            name: "originSettler",
            type: "address",
            internalType: "address"
          },
          {
            name: "user",
            type: "address",
            internalType: "address"
          },
          {
            name: "nonce",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "originChainId",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "openDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "fillDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "orderDataType",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "orderData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "refundedOrdersCommitments",
    inputs: [
      {
        name: "orderId",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "commitment",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "renounceOwnership",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "resolve",
    inputs: [
      {
        name: "_order",
        type: "tuple",
        internalType: "struct OnchainCrossChainOrder",
        components: [
          {
            name: "fillDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "orderDataType",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "orderData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [
      {
        name: "_resolvedOrder",
        type: "tuple",
        internalType: "struct ResolvedCrossChainOrder",
        components: [
          {
            name: "user",
            type: "address",
            internalType: "address"
          },
          {
            name: "originChainId",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "openDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "fillDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "orderId",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "maxSpent",
            type: "tuple[]",
            internalType: "struct Output[]",
            components: [
              {
                name: "token",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "amount",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "recipient",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "chainId",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          },
          {
            name: "minReceived",
            type: "tuple[]",
            internalType: "struct Output[]",
            components: [
              {
                name: "token",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "amount",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "recipient",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "chainId",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          },
          {
            name: "fillInstructions",
            type: "tuple[]",
            internalType: "struct FillInstruction[]",
            components: [
              {
                name: "destinationChainId",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "destinationSettler",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "originData",
                type: "bytes",
                internalType: "bytes"
              }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "resolveFor",
    inputs: [
      {
        name: "_order",
        type: "tuple",
        internalType: "struct GaslessCrossChainOrder",
        components: [
          {
            name: "originSettler",
            type: "address",
            internalType: "address"
          },
          {
            name: "user",
            type: "address",
            internalType: "address"
          },
          {
            name: "nonce",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "originChainId",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "openDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "fillDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "orderDataType",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "orderData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "_originFillerData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "_resolvedOrder",
        type: "tuple",
        internalType: "struct ResolvedCrossChainOrder",
        components: [
          {
            name: "user",
            type: "address",
            internalType: "address"
          },
          {
            name: "originChainId",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "openDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "fillDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "orderId",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "maxSpent",
            type: "tuple[]",
            internalType: "struct Output[]",
            components: [
              {
                name: "token",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "amount",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "recipient",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "chainId",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          },
          {
            name: "minReceived",
            type: "tuple[]",
            internalType: "struct Output[]",
            components: [
              {
                name: "token",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "amount",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "recipient",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "chainId",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          },
          {
            name: "fillInstructions",
            type: "tuple[]",
            internalType: "struct FillInstruction[]",
            components: [
              {
                name: "destinationChainId",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "destinationSettler",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "originData",
                type: "bytes",
                internalType: "bytes"
              }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "setAztecGateway7683",
    inputs: [
      {
        name: "aztecGateway7683_",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setForwarder",
    inputs: [
      {
        name: "forwarder_",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "settle",
    inputs: [
      {
        name: "message",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "stateProofParams",
        type: "tuple",
        internalType: "struct StateValidator.StateProofParameters",
        components: [
          {
            name: "beaconRoot",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "beaconOracleTimestamp",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "executionStateRoot",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "stateRootProof",
            type: "bytes32[]",
            internalType: "bytes32[]"
          }
        ]
      },
      {
        name: "accountProofParams",
        type: "tuple",
        internalType: "struct StateValidator.AccountProofParameters",
        components: [
          {
            name: "storageKey",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "storageValue",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "accountProof",
            type: "bytes[]",
            internalType: "bytes[]"
          },
          {
            name: "storageProof",
            type: "bytes[]",
            internalType: "bytes[]"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferOwnership",
    inputs: [
      {
        name: "newOwner",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "usedNonces",
    inputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "witnessHash",
    inputs: [
      {
        name: "_resolvedOrder",
        type: "tuple",
        internalType: "struct ResolvedCrossChainOrder",
        components: [
          {
            name: "user",
            type: "address",
            internalType: "address"
          },
          {
            name: "originChainId",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "openDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "fillDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "orderId",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "maxSpent",
            type: "tuple[]",
            internalType: "struct Output[]",
            components: [
              {
                name: "token",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "amount",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "recipient",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "chainId",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          },
          {
            name: "minReceived",
            type: "tuple[]",
            internalType: "struct Output[]",
            components: [
              {
                name: "token",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "amount",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "recipient",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "chainId",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          },
          {
            name: "fillInstructions",
            type: "tuple[]",
            internalType: "struct FillInstruction[]",
            components: [
              {
                name: "destinationChainId",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "destinationSettler",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "originData",
                type: "bytes",
                internalType: "bytes"
              }
            ]
          }
        ]
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "witnessTypeString",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "string",
        internalType: "string"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "AztecGateway7683Set",
    inputs: [
      {
        name: "aztecGateway7683",
        type: "bytes32",
        indexed: false,
        internalType: "bytes32"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "Filled",
    inputs: [
      {
        name: "orderId",
        type: "bytes32",
        indexed: false,
        internalType: "bytes32"
      },
      {
        name: "originData",
        type: "bytes",
        indexed: false,
        internalType: "bytes"
      },
      {
        name: "fillerData",
        type: "bytes",
        indexed: false,
        internalType: "bytes"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ForwarderSet",
    inputs: [
      {
        name: "forwarder",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "NonceInvalidation",
    inputs: [
      {
        name: "owner",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "nonce",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "Open",
    inputs: [
      {
        name: "orderId",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "resolvedOrder",
        type: "tuple",
        indexed: false,
        internalType: "struct ResolvedCrossChainOrder",
        components: [
          {
            name: "user",
            type: "address",
            internalType: "address"
          },
          {
            name: "originChainId",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "openDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "fillDeadline",
            type: "uint32",
            internalType: "uint32"
          },
          {
            name: "orderId",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "maxSpent",
            type: "tuple[]",
            internalType: "struct Output[]",
            components: [
              {
                name: "token",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "amount",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "recipient",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "chainId",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          },
          {
            name: "minReceived",
            type: "tuple[]",
            internalType: "struct Output[]",
            components: [
              {
                name: "token",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "amount",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "recipient",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "chainId",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          },
          {
            name: "fillInstructions",
            type: "tuple[]",
            internalType: "struct FillInstruction[]",
            components: [
              {
                name: "destinationChainId",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "destinationSettler",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "originData",
                type: "bytes",
                internalType: "bytes"
              }
            ]
          }
        ]
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "OwnershipTransferred",
    inputs: [
      {
        name: "previousOwner",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "newOwner",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "Refund",
    inputs: [
      {
        name: "orderIds",
        type: "bytes32[]",
        indexed: false,
        internalType: "bytes32[]"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "Refunded",
    inputs: [
      {
        name: "orderId",
        type: "bytes32",
        indexed: false,
        internalType: "bytes32"
      },
      {
        name: "receiver",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "Settle",
    inputs: [
      {
        name: "orderIds",
        type: "bytes32[]",
        indexed: false,
        internalType: "bytes32[]"
      },
      {
        name: "ordersFillerData",
        type: "bytes[]",
        indexed: false,
        internalType: "bytes[]"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "Settled",
    inputs: [
      {
        name: "orderId",
        type: "bytes32",
        indexed: false,
        internalType: "bytes32"
      },
      {
        name: "receiver",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "error",
    name: "BeaconRootDoesNotMatch",
    inputs: [
      {
        name: "expected",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "actual",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "BeaconRootsOracleCallFailed",
    inputs: [
      {
        name: "callData",
        type: "bytes",
        internalType: "bytes"
      }
    ]
  },
  {
    type: "error",
    name: "ContentLengthMismatch",
    inputs: []
  },
  {
    type: "error",
    name: "EmptyItem",
    inputs: []
  },
  {
    type: "error",
    name: "ExecutionStateRootMerkleProofFailed",
    inputs: []
  },
  {
    type: "error",
    name: "FailedCall",
    inputs: []
  },
  {
    type: "error",
    name: "InsufficientBalance",
    inputs: [
      {
        name: "balance",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "needed",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "InvalidAccountRLP",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidDataRemainder",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidGaslessOrderOrigin",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidGaslessOrderSettler",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidHeader",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidNativeAmount",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidNonce",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidOrderDomain",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidOrderId",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidOrderLength",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidOrderOrigin",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidOrderStatus",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidOrderType",
    inputs: [
      {
        name: "orderType",
        type: "bytes32",
        internalType: "bytes32"
      }
    ]
  },
  {
    type: "error",
    name: "InvalidOriginDomain",
    inputs: [
      {
        name: "originDomain",
        type: "uint32",
        internalType: "uint32"
      }
    ]
  },
  {
    type: "error",
    name: "InvalidState",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidStorageKey",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidStorageValue",
    inputs: []
  },
  {
    type: "error",
    name: "OrderFillExpired",
    inputs: []
  },
  {
    type: "error",
    name: "OrderFillNotExpired",
    inputs: []
  },
  {
    type: "error",
    name: "OrderOpenExpired",
    inputs: []
  },
  {
    type: "error",
    name: "OutOfRange",
    inputs: []
  },
  {
    type: "error",
    name: "OwnableInvalidOwner",
    inputs: [
      {
        name: "owner",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "OwnableUnauthorizedAccount",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "SafeERC20FailedOperation",
    inputs: [
      {
        name: "token",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "UnexpectedList",
    inputs: []
  },
  {
    type: "error",
    name: "UnexpectedString",
    inputs: []
  }
];

// src/utils/gateway.ts
var parseResolvedOrderFromOpen1AndOpen2Logs = (fields1, fields2) => {
  let orderId1 = fields1[0].toString();
  const residualBytes1 = fields1[12].toString();
  const resolvedOrder1 = "0x" + fields1[1].toString().slice(4) + residualBytes1.slice(6, 8) + fields1[2].toString().slice(4) + residualBytes1.slice(8, 10) + fields1[3].toString().slice(4) + residualBytes1.slice(10, 12) + fields1[4].toString().slice(4) + residualBytes1.slice(12, 14) + fields1[5].toString().slice(4) + residualBytes1.slice(14, 16) + fields1[6].toString().slice(4) + residualBytes1.slice(16, 18) + fields1[7].toString().slice(4) + residualBytes1.slice(18, 20) + fields1[8].toString().slice(4) + residualBytes1.slice(20, 22) + fields1[9].toString().slice(4) + residualBytes1.slice(22, 24) + fields1[10].toString().slice(4) + residualBytes1.slice(24, 26) + fields1[11].toString().slice(4, 44);
  let orderId2 = fields2[0].toString();
  const residualBytes2 = fields2[10].toString();
  const resolvedOrder2 = fields2[1].toString().slice(4) + residualBytes2.slice(6, 8) + fields2[2].toString().slice(4) + residualBytes2.slice(8, 10) + fields2[3].toString().slice(4) + residualBytes2.slice(10, 12) + fields2[4].toString().slice(4) + residualBytes2.slice(12, 14) + fields2[5].toString().slice(4) + residualBytes2.slice(14, 16) + fields2[6].toString().slice(4) + residualBytes2.slice(16, 18) + fields2[7].toString().slice(4) + residualBytes2.slice(18, 20) + fields2[8].toString().slice(4) + residualBytes2.slice(20, 22) + fields2[9].toString().slice(4, 38);
  orderId1 = `0x${orderId1.slice(4) + residualBytes1.slice(4, 6)}`;
  orderId2 = `0x${orderId2.slice(4) + residualBytes2.slice(4, 6)}`;
  if (orderId1 !== orderId2) throw new Error("logs don't belong to the same order");
  return parseResolvedAztecOrder(resolvedOrder1 + resolvedOrder2);
};
var parseFilledLog = (fields) => {
  let orderId = fields[0].toString();
  let fillerData = fields[11].toString();
  const residualBytes = fields[12].toString();
  const originData = "0x" + fields[1].toString().slice(4) + residualBytes.slice(6, 8) + fields[2].toString().slice(4) + residualBytes.slice(8, 10) + fields[3].toString().slice(4) + residualBytes.slice(10, 12) + fields[4].toString().slice(4) + residualBytes.slice(12, 14) + fields[5].toString().slice(4) + residualBytes.slice(14, 16) + fields[6].toString().slice(4) + residualBytes.slice(16, 18) + fields[7].toString().slice(4) + residualBytes.slice(18, 20) + fields[8].toString().slice(4) + residualBytes.slice(20, 22) + fields[9].toString().slice(4) + residualBytes.slice(22, 24) + fields[10].toString().slice(4, 30);
  orderId = `0x${orderId.slice(4) + residualBytes.slice(4, 6)}`;
  fillerData = `0x${fillerData.slice(4) + residualBytes.slice(24, 26)}`;
  return {
    orderId,
    fillerData,
    originData
  };
};
var parseResolvedAztecOrder = (resolvedOrder) => {
  return {
    fillInstructions: [
      {
        originData: `0x${resolvedOrder.slice(resolvedOrder.length - 602)}`,
        destinationSettler: `0x${resolvedOrder.slice(resolvedOrder.length - 666, resolvedOrder.length - 602)}`,
        destinationChainId: parseInt(resolvedOrder.slice(resolvedOrder.length - 674, resolvedOrder.length - 666), 16)
      }
    ],
    maxSpent: [
      {
        chainId: parseInt(resolvedOrder.slice(resolvedOrder.length - 682, resolvedOrder.length - 674), 16),
        recipient: `0x${resolvedOrder.slice(resolvedOrder.length - 746, resolvedOrder.length - 682)}`,
        amount: BigInt("0x" + resolvedOrder.slice(resolvedOrder.length - 810, resolvedOrder.length - 746)),
        token: `0x${resolvedOrder.slice(resolvedOrder.length - 874, resolvedOrder.length - 810)}`
      }
    ],
    minReceived: [
      {
        chainId: parseInt(resolvedOrder.slice(resolvedOrder.length - 882, resolvedOrder.length - 874), 16),
        recipient: `0x${resolvedOrder.slice(resolvedOrder.length - 946, resolvedOrder.length - 882)}`,
        amount: BigInt("0x" + resolvedOrder.slice(resolvedOrder.length - 1010, resolvedOrder.length - 946)),
        token: `0x${resolvedOrder.slice(resolvedOrder.length - 1074, resolvedOrder.length - 1010)}`
      }
    ],
    orderId: `0x${resolvedOrder.slice(resolvedOrder.length - 1138, resolvedOrder.length - 1074)}`,
    fillDeadline: parseInt(resolvedOrder.slice(resolvedOrder.length - 1146, resolvedOrder.length - 1138), 16),
    openDeadline: parseInt(resolvedOrder.slice(resolvedOrder.length - 1154, resolvedOrder.length - 1146), 16),
    originChainId: parseInt(resolvedOrder.slice(resolvedOrder.length - 1162, resolvedOrder.length - 1154), 16),
    user: `0x${resolvedOrder.slice(resolvedOrder.length - 1226, resolvedOrder.length - 1162)}`
  };
};
var getResolvedOrderAndOrderIdEvmByReceipt = (receipt) => {
  const log = receipt.logs.find(
    ({ topics }) => topics[0] === "0x3448bbc2203c608599ad448eeb1007cea04b788ac631f9f558e8dd01a3c27b3d"
    // Open
  );
  const orderId = Fr2.fromBufferReduce(Buffer.from(log.topics[1].slice(2), "hex")).toString();
  const resolvedOrder = parseResolvedOrderEvm(log);
  return {
    orderId,
    resolvedOrder
  };
};
var parseResolvedOrderEvm = (log) => {
  const openEvent = l2Gateway7683_default.find((el) => el.name === "Open");
  if (!openEvent || !openEvent.inputs[1]) {
    throw new Error("Invalid ABI: Could not find Open event or inputs[1]");
  }
  const [resolvedOrder] = decodeAbiParameters([openEvent.inputs[1]], log.data);
  return resolvedOrder;
};
var getResolvedOrderByAztecLogs = (logs) => {
  const groupedLogs = logs.reduce((acc, obj) => {
    const groupKey = obj.log.fields[0].toString();
    if (!acc[groupKey]) {
      acc[groupKey] = [];
    }
    acc[groupKey].push(obj);
    return acc;
  }, {});
  const joinedLogs = Object.keys(groupedLogs).filter((orderId) => {
    const logs2 = groupedLogs[orderId].filter(
      ({ log }) => log.getEmittedFields().length === 11 || log.getEmittedFields().length === 13
    );
    return logs2.length === 2;
  }).map((orderId) => {
    const [open1, open2] = groupedLogs[orderId];
    const open = parseResolvedOrderFromOpen1AndOpen2Logs(open1.log.fields, open2.log.fields);
    return open;
  });
  return joinedLogs;
};

// src/utils/order-data-encoder.ts
import { bytesToHex, encodePacked, hexToBytes } from "viem";
import { poseidon2Hash } from "@aztec/foundation/crypto/poseidon";
import { Fr as Fr3 } from "@aztec/aztec.js/fields";
var ORDER_DATA_LENGTH = 301;
var ORDER_DATA_PACKED_TYPES = [
  "bytes32",
  // sender
  "bytes32",
  // recipient
  "bytes32",
  // inputToken
  "bytes32",
  // outputToken
  "uint256",
  // amountIn
  "uint256",
  // amountOut
  "uint256",
  // senderNonce
  "uint32",
  // originDomain
  "uint32",
  // destinationDomain
  "bytes32",
  // destinationSettler
  "uint32",
  // fillDeadline
  "uint8",
  // orderType
  "bytes32"
  // data
];
var OFF = {
  sender: 0,
  // bytes32
  recipient: 32,
  // bytes32
  inputToken: 64,
  // bytes32
  outputToken: 96,
  // bytes32
  amountIn: 128,
  // uint256 -> 32 bytes
  amountOut: 160,
  // uint256 -> 32 bytes
  senderNonce: 192,
  // uint256 -> 32 bytes
  originDomain: 224,
  // uint32  -> 4 bytes
  destinationDomain: 228,
  // uint32  -> 4 bytes
  destinationSettler: 232,
  // bytes32
  fillDeadline: 264,
  // uint32  -> 4 bytes
  orderType: 268,
  // uint8   -> 1 byte
  data: 269
  // bytes32
};
var read = (b, off, len) => b.subarray(off, off + len);
var u32be = (b4) => new DataView(b4.buffer, b4.byteOffset, 4).getUint32(0, false);
var u256be = (b32) => b32.reduce((acc, x) => (acc << 8n) + BigInt(x), 0n);
var _sender, _recipient, _inputToken, _outputToken, _amountIn, _amountOut, _senderNonce, _originDomain, _destinationDomain, _destinationSettler, _fillDeadline, _orderType, _data;
var OrderDataEncoder = class {
  constructor(params) {
    __privateAdd(this, _sender);
    __privateAdd(this, _recipient);
    __privateAdd(this, _inputToken);
    __privateAdd(this, _outputToken);
    __privateAdd(this, _amountIn);
    __privateAdd(this, _amountOut);
    __privateAdd(this, _senderNonce);
    __privateAdd(this, _originDomain);
    __privateAdd(this, _destinationDomain);
    __privateAdd(this, _destinationSettler);
    __privateAdd(this, _fillDeadline);
    __privateAdd(this, _orderType);
    __privateAdd(this, _data);
    __privateSet(this, _sender, params.sender);
    __privateSet(this, _recipient, params.recipient);
    __privateSet(this, _inputToken, params.inputToken);
    __privateSet(this, _outputToken, params.outputToken);
    __privateSet(this, _amountIn, params.amountIn);
    __privateSet(this, _amountOut, params.amountOut);
    __privateSet(this, _senderNonce, params.senderNonce);
    __privateSet(this, _originDomain, params.originDomain);
    __privateSet(this, _destinationDomain, params.destinationDomain);
    __privateSet(this, _destinationSettler, params.destinationSettler);
    __privateSet(this, _fillDeadline, params.fillDeadline);
    __privateSet(this, _orderType, params.orderType);
    __privateSet(this, _data, params.data);
  }
  toPacked() {
    const values = [
      __privateGet(this, _sender),
      __privateGet(this, _recipient),
      __privateGet(this, _inputToken),
      __privateGet(this, _outputToken),
      __privateGet(this, _amountIn),
      __privateGet(this, _amountOut),
      __privateGet(this, _senderNonce),
      __privateGet(this, _originDomain),
      __privateGet(this, _destinationDomain),
      __privateGet(this, _destinationSettler),
      __privateGet(this, _fillDeadline),
      __privateGet(this, _orderType),
      __privateGet(this, _data)
    ];
    return { types: ORDER_DATA_PACKED_TYPES, values };
  }
  static decode(packed) {
    const bytes = hexToBytes(packed);
    if (bytes.length !== ORDER_DATA_LENGTH) {
      throw new Error(`Invalid OrderData length: got ${bytes.length}, expected ${ORDER_DATA_LENGTH}`);
    }
    const sender = bytesToHex(read(bytes, OFF.sender, 32));
    const recipient = bytesToHex(read(bytes, OFF.recipient, 32));
    const inputToken = bytesToHex(read(bytes, OFF.inputToken, 32));
    const outputToken = bytesToHex(read(bytes, OFF.outputToken, 32));
    const amountIn = u256be(read(bytes, OFF.amountIn, 32));
    const amountOut = u256be(read(bytes, OFF.amountOut, 32));
    const senderNonce = u256be(read(bytes, OFF.senderNonce, 32));
    const originDomain = u32be(read(bytes, OFF.originDomain, 4));
    const destinationDomain = u32be(read(bytes, OFF.destinationDomain, 4));
    const destinationSettler = bytesToHex(read(bytes, OFF.destinationSettler, 32));
    const fillDeadline = u32be(read(bytes, OFF.fillDeadline, 4));
    const orderType = read(bytes, OFF.orderType, 1)[0];
    const data = bytesToHex(read(bytes, OFF.data, 32));
    return {
      sender,
      recipient,
      inputToken,
      outputToken,
      amountIn,
      amountOut,
      senderNonce,
      originDomain,
      destinationDomain,
      destinationSettler,
      fillDeadline,
      orderType,
      data
    };
  }
  encode() {
    const { types, values } = this.toPacked();
    return encodePacked(types, values);
  }
  // TODO: understand why sometimes it returns a wrong id
  async id() {
    return await poseidon2Hash([
      Fr3.fromBufferReduce(Buffer.from(__privateGet(this, _sender).slice(2), "hex")),
      Fr3.fromBufferReduce(Buffer.from(__privateGet(this, _recipient).slice(2), "hex")),
      Fr3.fromBufferReduce(Buffer.from(__privateGet(this, _inputToken).slice(2), "hex")),
      Fr3.fromBufferReduce(Buffer.from(__privateGet(this, _outputToken).slice(2), "hex")),
      Fr3.fromBufferReduce(Buffer.from(__privateGet(this, _amountIn).toString(16), "hex")),
      Fr3.fromBufferReduce(Buffer.from(__privateGet(this, _amountOut).toString(16), "hex")),
      Fr3.fromBufferReduce(Buffer.from(__privateGet(this, _senderNonce).toString(16), "hex")),
      Fr3.fromHexString("0x" + __privateGet(this, _originDomain).toString(16)),
      Fr3.fromHexString("0x" + __privateGet(this, _destinationDomain).toString(16)),
      Fr3.fromBufferReduce(Buffer.from(__privateGet(this, _destinationSettler).slice(2), "hex")),
      Fr3.fromHexString("0x" + __privateGet(this, _fillDeadline).toString(16)),
      Fr3.fromHexString("0x" + __privateGet(this, _orderType).toString(16)),
      Fr3.fromBufferReduce(Buffer.from(__privateGet(this, _data).slice(2), "hex"))
    ]);
  }
};
_sender = new WeakMap();
_recipient = new WeakMap();
_inputToken = new WeakMap();
_outputToken = new WeakMap();
_amountIn = new WeakMap();
_amountOut = new WeakMap();
_senderNonce = new WeakMap();
_originDomain = new WeakMap();
_destinationDomain = new WeakMap();
_destinationSettler = new WeakMap();
_fillDeadline = new WeakMap();
_orderType = new WeakMap();
_data = new WeakMap();

// src/utils/index.ts
var getAztecAddressFromAzguardAccount = (account) => account.split(":").slice(-1)[0];
var hexToUintArray = (str) => Array.from(hexToBytes2(str));
async function setPublicAuthWit(wallet, from, messageHashOrIntent, authorized) {
  return SetPublicAuthwitContractInteraction.create(wallet, from, messageHashOrIntent, authorized);
}

// src/context/BridgeContext.ts
import * as viemChains from "viem/chains";
var _forwarderChain, _wallet, _account, _aztecGatewayRegistered;
var BridgeContext = class {
  constructor(configs) {
    __privateAdd(this, _forwarderChain);
    __privateAdd(this, _wallet);
    __privateAdd(this, _account);
    __privateAdd(this, _aztecGatewayRegistered, false);
    const { azguardClient, aztecWallet, beaconApiUrl, evmPrivateKey, evmProvider } = configs;
    if (!aztecWallet && !azguardClient) {
      throw new Error("You must specify aztecWallet or azguardClient");
    }
    if (evmPrivateKey && evmProvider) {
      throw new Error("Cannot specify both evmPrivateKey and evmProvider");
    }
    if (azguardClient && aztecWallet) {
      throw new Error("Cannot specify both azguardClient and aztecWallet");
    }
    this.azguardClient = azguardClient;
    this.aztecWallet = aztecWallet;
    this.beaconApiUrl = beaconApiUrl;
    this.evmPrivateKey = evmPrivateKey;
    this.evmProvider = evmProvider;
    this.chainsConfig = configs.chainsConfig ?? defaultChainsConfig;
    this.forwarderAddress = configs.forwarderAddress ?? DEFAULT_FORWARDER_ADDRESS;
    this.aztecRollupContractL1Address = configs.aztecRollupContractL1Address ?? DEFAULT_AZTEC_ROLLUP_L1_ADDRESS;
    this.opStackAnchorRegistryAddress = configs.opStackAnchorRegistryAddress ?? DEFAULT_OP_STACK_ANCHOR_REGISTRY;
    this.forwarderChainId = configs.forwarderChainId ?? DEFAULT_FORWARDER_CHAIN_ID;
  }
  getAztecConfig() {
    const aztecConfig = this.chainsConfig.aztecDevnet;
    if (!aztecConfig) throw new Error("Aztec chain config not found");
    return aztecConfig;
  }
  getAztecRpcUrl() {
    return this.getAztecConfig().chain.rpcUrls.default.http[0];
  }
  getAztecGatewayAddress() {
    return this.getAztecConfig().gatewayAddress;
  }
  getAztecChainId() {
    return this.getAztecConfig().chain.id;
  }
  getForwarderChain() {
    if (!__privateGet(this, _forwarderChain)) {
      if (this.forwarderChainId === DEFAULT_FORWARDER_CHAIN_ID) {
        __privateSet(this, _forwarderChain, FORWARDER_CHAIN);
      } else {
        const chain = Object.values(viemChains).find((c) => c.id === this.forwarderChainId);
        if (!chain) throw new Error(`Forwarder chain not found for ID: ${this.forwarderChainId}`);
        __privateSet(this, _forwarderChain, chain);
      }
    }
    return __privateGet(this, _forwarderChain);
  }
  async getAztecWallet() {
    if (!__privateGet(this, _wallet)) {
      if (!this.aztecWallet) {
        throw new Error("No Aztec wallet provided. Please provide an aztecWallet in BridgeConfigs.");
      }
      __privateSet(this, _wallet, this.aztecWallet);
    }
    return __privateGet(this, _wallet);
  }
  async getAztecAccount() {
    if (!__privateGet(this, _account)) {
      const wallet = await this.getAztecWallet();
      const accounts = await wallet.getAccounts();
      if (!accounts || accounts.length === 0) {
        throw new Error("No accounts found in the provided wallet. Please register an account with the wallet first.");
      }
      const accountAddress = accounts[0].item;
      __privateSet(this, _account, await wallet.getAccountFromAddress(accountAddress));
      if (!__privateGet(this, _account)) {
        throw new Error(`Could not retrieve account ${accountAddress.toString()} from wallet`);
      }
    }
    return __privateGet(this, _account);
  }
  getChainInAndOutByChainIds(chainIdIn, chainIdOut) {
    return {
      chainIn: this.getChainByChainId(chainIdIn),
      chainOut: this.getChainByChainId(chainIdOut)
    };
  }
  getChainByChainId(chainId) {
    const chains2 = Object.values(this.chainsConfig);
    const chain = chains2.find((c) => c.chain.id === chainId);
    if (!chain) throw new Error("Chain not supported");
    return chain;
  }
  async getEvmWalletClientAndAddress(chain) {
    const walletClient = this.evmProvider ? createWalletClient({
      chain,
      transport: custom(this.evmProvider)
    }) : createWalletClient({
      chain,
      account: privateKeyToAccount(this.evmPrivateKey),
      transport: http()
    });
    let address;
    if (walletClient.account) {
      address = walletClient.account.address;
    } else {
      ;
      [address] = await walletClient.getAddresses();
    }
    return {
      walletClient,
      address
    };
  }
  getGatewaysByChainIds(chainIdIn, chainIdOut) {
    const chains2 = Object.values(this.chainsConfig);
    const chainIn = chains2.find((c) => c.chain.id === chainIdIn);
    if (!chainIn) throw new Error("Unsupported source chain");
    const gatewayIn = chainIn.gatewayAddress;
    const chainOut = chains2.find((c) => c.chain.id === chainIdOut);
    if (!chainOut) throw new Error("Unsupported destination chain");
    const gatewayOut = chainOut.gatewayAddress;
    return {
      gatewayIn,
      gatewayOut
    };
  }
  async maybeRegisterAztecGateway() {
    const aztecConfig = this.chainsConfig.aztecDevnet;
    if (!aztecConfig) throw new Error("Aztec chain config not found");
    const gateway = aztecConfig.gatewayAddress;
    if (!__privateGet(this, _aztecGatewayRegistered)) {
      if (this.azguardClient) {
        await this.azguardClient.execute([
          {
            kind: "register_contract",
            chain: `aztec:${AZGUARD_CHAIN_ID}`,
            address: gateway,
            artifact: AztecGateway7683ContractArtifact
          }
        ]);
      } else {
        const wallet = await this.getAztecWallet();
        const instance = await createAztecNodeClient2(aztecConfig.chain.rpcUrls.default.http[0]).getContract(
          AztecAddress2.fromString(gateway)
        );
        if (!instance) {
          throw new Error(`Contract instance not found for gateway address ${gateway}`);
        }
        await wallet.registerContract(instance, AztecGateway7683Contract.artifact);
        const sponsoredFPC = await getSponsoredFPCInstance(aztecConfig.chain.rpcUrls.default.http[0]);
        await wallet.registerContract(sponsoredFPC, SponsoredFPCContractArtifact2);
      }
      __privateSet(this, _aztecGatewayRegistered, true);
    }
  }
  async getAztecFilledLogByOrderId(orderId) {
    const aztecConfig = this.chainsConfig.aztecDevnet;
    if (!aztecConfig) throw new Error("Aztec chain config not found");
    const gateway = aztecConfig.gatewayAddress;
    const { logs } = await createAztecNodeClient2(aztecConfig.chain.rpcUrls.default.http[0]).getPublicLogs({
      contractAddress: AztecAddress2.fromString(gateway)
    });
    const filledLogs = logs.filter(({ log }) => log.fields.length === 13 && log.fields[11] !== void 0);
    const parsedLogs = filledLogs.map(({ log }) => parseFilledLog(log.fields));
    return parsedLogs.find((log) => log.orderId === orderId);
  }
};
_forwarderChain = new WeakMap();
_wallet = new WeakMap();
_account = new WeakMap();
_aztecGatewayRegistered = new WeakMap();

// src/operations/AztecToEvmOperations.ts
import { createPublicClient, erc20Abi, http as http2, padHex as padHex2 } from "viem";
import { AztecAddress as AztecAddress3 } from "@aztec/aztec.js/addresses";
import { Fr as Fr4 } from "@aztec/aztec.js/fields";
import { createAztecNodeClient as createAztecNodeClient3 } from "@aztec/aztec.js/node";
import { TxHash } from "@aztec/aztec.js/tx";
import { sleep } from "@aztec/foundation/sleep";
import { TokenContract, TokenContractArtifact } from "@defi-wonderland/aztec-standards/artifacts/Token.js";
var AZTEC_WAIT_TIMEOUT = 12e4;
var AztecToEvmOperations = class {
  constructor(context) {
    this.context = context;
  }
  async openOrder(order, callbacks) {
    const { amountIn, amountOut, chainIdIn, chainIdOut, data, mode, recipient, tokenIn, tokenOut } = order;
    const { gatewayIn, gatewayOut } = this.context.getGatewaysByChainIds(chainIdIn, chainIdOut);
    const fillDeadline = order.fillDeadline ?? 2 ** 32 - 1;
    const nonce = Fr4.random();
    const isPrivate = mode.includes("private");
    const baseOrderData = {
      recipient: padHex2(recipient, { size: 32 }),
      inputToken: padHex2(tokenIn, { size: 32 }),
      outputToken: padHex2(tokenOut, { size: 32 }),
      amountIn,
      amountOut,
      senderNonce: nonce.toBigInt(),
      originDomain: chainIdIn,
      destinationDomain: chainIdOut,
      destinationSettler: padHex2(gatewayOut, { size: 32 }),
      fillDeadline,
      orderType: this.getOrderType(mode),
      data: data || padHex2("0x", { size: 32 })
    };
    await this.context.maybeRegisterAztecGateway();
    let orderOpenedReceipt;
    if (this.context.azguardClient) {
      const selectedAccount = this.context.azguardClient.accounts[0];
      const orderDataEncoder = new OrderDataEncoder({
        ...baseOrderData,
        sender: isPrivate ? PRIVATE_SENDER : getAztecAddressFromAzguardAccount(selectedAccount)
      });
      const response = await this.context.azguardClient.execute([
        {
          kind: "register_contract",
          chain: `aztec:${AZGUARD_CHAIN_ID}`,
          address: tokenIn,
          artifact: TokenContractArtifact
        },
        {
          kind: "send_transaction",
          account: selectedAccount,
          actions: [
            {
              kind: isPrivate ? "add_private_authwit" : "add_public_authwit",
              content: {
                kind: "call",
                caller: gatewayIn,
                contract: tokenIn,
                method: isPrivate ? "transfer_private_to_public" : "transfer_public_to_public",
                args: [getAztecAddressFromAzguardAccount(selectedAccount), gatewayIn, amountIn, nonce]
              }
            },
            {
              kind: "call",
              contract: gatewayIn,
              method: isPrivate ? "open_private" : "open",
              args: [
                {
                  fill_deadline: fillDeadline,
                  order_data: hexToUintArray(orderDataEncoder.encode()),
                  order_data_type: hexToUintArray(ORDER_DATA_TYPE)
                }
              ]
            }
          ]
        }
      ]);
      for (const res of response) if (res.status === "failed") throw new Error(res.error);
      const orderOpenedTxHash = response[1].result;
      const waitForReceipt = async (txHash) => {
        while (true) {
          const receipt = await createAztecNodeClient3(this.context.getAztecRpcUrl()).getTxReceipt(
            TxHash.fromString(txHash)
          );
          if (receipt.status === "success") return receipt;
          if (receipt.status === "pending") {
            await sleep(5e3);
            continue;
          }
          throw new Error("Aztec transaction failed");
        }
      };
      orderOpenedReceipt = await waitForReceipt(orderOpenedTxHash);
    } else {
      const wallet = await this.context.getAztecWallet();
      const account = await this.context.getAztecAccount();
      const tokenInstance = await createAztecNodeClient3(this.context.getAztecRpcUrl()).getContract(
        AztecAddress3.fromString(tokenIn)
      );
      if (!tokenInstance) {
        throw new Error(`Token contract instance not found for address ${tokenIn}`);
      }
      try {
        await wallet.registerContract(tokenInstance, TokenContractArtifact);
      } catch (e) {
        console.warn(`Failed to register token contract at ${tokenIn}: ${e}`);
      }
      const orderDataEncoder = new OrderDataEncoder({
        ...baseOrderData,
        sender: isPrivate ? PRIVATE_SENDER : account.getAddress().toString()
      });
      const gateway = await AztecGateway7683Contract.at(AztecAddress3.fromString(gatewayIn), wallet);
      const token = await TokenContract.at(AztecAddress3.fromString(tokenIn), wallet);
      let witness;
      if (isPrivate) {
        const action = token.withWallet(wallet).methods.transfer_private_to_public(account.getAddress(), AztecAddress3.fromString(gatewayIn), amountIn, nonce);
        const call = await action.getFunctionCall();
        witness = await account.createAuthWit({
          caller: AztecAddress3.fromString(gatewayIn),
          call
        });
      } else {
        const action = token.withWallet(wallet).methods.transfer_public_to_public(account.getAddress(), AztecAddress3.fromString(gatewayIn), amountIn, nonce);
        const call = await action.getFunctionCall();
        await (await setPublicAuthWit(
          wallet,
          account.getAddress(),
          {
            caller: AztecAddress3.fromString(gatewayIn),
            call
          },
          true
        )).send({ fee: { paymentMethod: await getSponsporedFeePaymentMethod() } }).wait({
          timeout: AZTEC_WAIT_TIMEOUT
        });
      }
      orderOpenedReceipt = await gateway.methods[isPrivate ? "open_private" : "open"]({
        fill_deadline: fillDeadline,
        order_data: hexToUintArray(orderDataEncoder.encode()),
        order_data_type: hexToUintArray(ORDER_DATA_TYPE)
      }).with({
        authWitnesses: witness ? [witness] : []
      }).send({
        from: account.getAddress(),
        fee: { paymentMethod: await getSponsporedFeePaymentMethod() }
      }).wait({
        timeout: AZTEC_WAIT_TIMEOUT
      });
    }
    const { transactionHash: orderFilledTxHash, resolvedOrder } = await this.monitorAztecToEvmOrder(
      order,
      orderOpenedReceipt,
      callbacks
    );
    return {
      orderOpenedTxHash: orderOpenedReceipt.txHash.toString(),
      orderFilledTxHash,
      resolvedOrder
    };
  }
  async fillOrder(details) {
    const { orderId, orderData } = details;
    const internalChainOut = Object.values(this.context.chainsConfig).find(
      (internalChain) => internalChain.chain.id === orderData.destinationDomain
    );
    if (!internalChainOut) throw new Error("ChainOut not supported");
    if (internalChainOut.type !== "EVM" /* EVM */) throw new Error("ChainOut must be an EVM chain");
    const gatewayOut = internalChainOut.gatewayAddress;
    const chainOut = internalChainOut.chain;
    const { address, walletClient } = await this.context.getEvmWalletClientAndAddress(chainOut);
    const fillerData = padHex2(address, { size: 32 });
    const publicClient = createPublicClient({
      chain: chainOut,
      transport: http2()
    });
    const tokenAddress = `0x${orderData.outputToken.slice(26)}`;
    const currentAllowance = await publicClient.readContract({
      abi: erc20Abi,
      address: tokenAddress,
      functionName: "allowance",
      args: [address, gatewayOut]
    });
    if (currentAllowance < orderData.amountOut) {
      const approvalHash = await walletClient.writeContract({
        abi: erc20Abi,
        account: this.context.evmPrivateKey ? walletClient.account : address,
        address: tokenAddress,
        args: [gatewayOut, orderData.amountOut],
        chain: chainOut,
        functionName: "approve"
      });
      await publicClient.waitForTransactionReceipt({
        hash: approvalHash,
        confirmations: 1
      });
      let newAllowance = 0n;
      let retries = 3;
      while (retries > 0) {
        newAllowance = await publicClient.readContract({
          abi: erc20Abi,
          address: tokenAddress,
          functionName: "allowance",
          args: [address, gatewayOut]
        });
        if (newAllowance >= orderData.amountOut) break;
        retries--;
        if (retries > 0) {
          await new Promise((resolve2) => setTimeout(resolve2, 2e3));
        }
      }
      if (newAllowance < orderData.amountOut) {
        throw new Error(
          `Insufficient allowance after approval. Required: ${orderData.amountOut}, Current: ${newAllowance}`
        );
      }
    }
    const orderDataEncoder = new OrderDataEncoder(orderData);
    return await walletClient.writeContract({
      abi: l2Gateway7683_default,
      account: this.context.evmPrivateKey ? walletClient.account : address,
      address: gatewayOut,
      args: [
        orderId,
        orderDataEncoder.encode(),
        fillerData
        // NOTE: needed for the settlement
      ],
      chain: chainOut,
      functionName: "fill"
      // nonce: accountNonce + 1,
    });
  }
  async refundOrder(details) {
    const { orderId, chainIdIn, chainIdOut } = details;
    const internalChainOut = this.context.getChainByChainId(chainIdOut);
    if (internalChainOut.type !== "EVM" /* EVM */) throw new Error("ChainOut must be an EVM chain");
    const chainOut = internalChainOut.chain;
    const { gatewayIn, gatewayOut } = this.context.getGatewaysByChainIds(chainIdIn, chainIdOut);
    let status = 0;
    if (this.context.azguardClient) {
      const selectedAccount = this.context.azguardClient.accounts[0];
      const [response] = await this.context.azguardClient.execute([
        {
          kind: "simulate_views",
          account: selectedAccount,
          calls: [
            {
              kind: "call",
              contract: gatewayIn,
              method: "get_order_status",
              args: [orderId]
            }
          ]
        }
      ]);
      if (response.status === "failed") throw new Error(response.error);
      status = parseInt(BigInt(response.result.encoded[0][0]).toString());
    } else {
      const wallet = await this.context.getAztecWallet();
      const account = await this.context.getAztecAccount();
      const gateway = await AztecGateway7683Contract.at(AztecAddress3.fromString(gatewayIn), wallet);
      status = parseInt(
        await gateway.methods.get_order_status(Fr4.fromString(orderId)).simulate({ from: account.getAddress() })
      );
    }
    const OPENED3 = 1;
    if (status !== OPENED3) throw new Error("Cannot find an opened order for the specified order id");
    const { walletClient, address } = await this.context.getEvmWalletClientAndAddress(chainOut);
    const log = await this.getAztecOpenLogByOrderId(orderId);
    return await walletClient.writeContract({
      abi: l2Gateway7683_default,
      account: this.context.evmPrivateKey ? walletClient.account : address,
      address: gatewayOut,
      args: [
        [
          {
            fillDeadline: log?.fillDeadline,
            orderDataType: ORDER_DATA_TYPE,
            orderData: log?.fillInstructions[0].originData
          }
        ]
      ],
      chain: chainOut,
      functionName: "refund"
    });
  }
  async monitorAztecToEvmOrder(order, receipt, callbacks) {
    const { chainIdIn, chainIdOut } = order;
    const { onOrderOpened, onOrderFilled } = callbacks || {};
    const { chainIn: internalChainIn, chainOut: internalChainOut } = this.context.getChainInAndOutByChainIds(
      chainIdIn,
      chainIdOut
    );
    if (internalChainIn.type !== "AZTEC" /* AZTEC */) throw new Error("ChainIn must be Aztec");
    if (internalChainOut.type !== "EVM" /* EVM */) throw new Error("ChainOut must be an EVM chain");
    const chainIn = internalChainIn.chain;
    const chainOut = internalChainOut.chain;
    const { gatewayIn, gatewayOut } = this.context.getGatewaysByChainIds(chainIdIn, chainIdOut);
    const { logs } = await createAztecNodeClient3(chainIn.rpcUrls.default.http[0]).getPublicLogs({
      fromBlock: receipt.blockNumber - 1,
      toBlock: receipt.blockNumber + 1,
      contractAddress: AztecAddress3.fromString(gatewayIn)
    });
    const [resolvedOrder] = getResolvedOrderByAztecLogs(logs);
    onOrderOpened?.({ orderId: resolvedOrder.orderId, transactionHash: receipt.txHash.toString(), resolvedOrder });
    const evmPublicClient = createPublicClient({
      chain: chainOut,
      transport: http2()
    });
    const waitForFilledOrder = async (orderId) => {
      while (true) {
        const result = await evmPublicClient.readContract({
          address: gatewayOut,
          abi: l2Gateway7683_default,
          functionName: "filledOrders",
          args: [orderId]
        });
        if (result[0] !== "0x" && result[1] !== "0x") break;
        await sleep(5e3);
      }
      const currentBlock = await evmPublicClient.getBlockNumber();
      const [log] = await evmPublicClient.getLogs({
        address: gatewayOut,
        event: l2Gateway7683_default.find((el) => el.type === "event" && el.name === "Filled"),
        args: {
          orderId
        },
        fromBlock: currentBlock - 100n,
        toBlock: currentBlock
      });
      return log.transactionHash;
    };
    const orderFilledTxHash = await waitForFilledOrder(resolvedOrder.orderId);
    onOrderFilled?.({ orderId: resolvedOrder.orderId, transactionHash: orderFilledTxHash });
    return { transactionHash: orderFilledTxHash, resolvedOrder };
  }
  async getAztecOpenLogByOrderId(orderId) {
    const gateway = this.context.getAztecGatewayAddress();
    const { logs } = await createAztecNodeClient3(this.context.getAztecRpcUrl()).getPublicLogs({
      contractAddress: AztecAddress3.fromString(gateway)
    });
    const parsedOpenLogs = getResolvedOrderByAztecLogs(logs);
    return parsedOpenLogs.find((order) => order.orderId === orderId);
  }
  getOrderType(mode) {
    switch (mode) {
      case "private":
        return PRIVATE_ORDER;
      case "privateWithHook":
        return PRIVATE_ORDER_WITH_HOOK;
      case "public":
        return PUBLIC_ORDER;
      case "publicWithHook":
        return PUBLIC_ORDER_WITH_HOOK;
      default:
        throw new Error("Invalid mode");
    }
  }
};

// src/operations/EvmToAztecOperations.ts
import { createPublicClient as createPublicClient2, erc20Abi as erc20Abi2, http as http3, padHex as padHex3 } from "viem";
import { AztecAddress as AztecAddress4 } from "@aztec/aztec.js/addresses";
import { Fr as Fr5 } from "@aztec/aztec.js/fields";
import { createAztecNodeClient as createAztecNodeClient4 } from "@aztec/aztec.js/node";
import { computeSecretHash } from "@aztec/stdlib/hash";
import { sleep as sleep2 } from "@aztec/foundation/sleep";
import { TokenContract as TokenContract2, TokenContractArtifact as TokenContractArtifact2 } from "@defi-wonderland/aztec-standards/artifacts/Token.js";
var AZTEC_WAIT_TIMEOUT2 = 12e4;
var EvmToAztecOperations = class {
  constructor(context) {
    this.context = context;
  }
  async openOrder(order, callbacks) {
    const { amountIn, amountOut, chainIdIn, chainIdOut, data, mode, recipient, tokenIn, tokenOut } = order;
    const { onSecret, onOrderOpened, onOrderClaimed } = callbacks || {};
    const { gatewayIn, gatewayOut } = this.context.getGatewaysByChainIds(chainIdIn, chainIdOut);
    const internalChainIn = this.context.getChainByChainId(chainIdIn);
    if (internalChainIn.type !== "EVM" /* EVM */) throw new Error("ChainIn must be an EVM chain");
    const chainIn = internalChainIn.chain;
    const { walletClient, address: sender } = await this.context.getEvmWalletClientAndAddress(chainIn);
    const fillDeadline = order.fillDeadline ?? 2 ** 32 - 1;
    const nonce = Fr5.random();
    const isPrivate = mode.includes("private");
    const secret = isPrivate ? Fr5.random() : null;
    const orderData = {
      sender: padHex3(sender, { size: 32 }),
      recipient: secret ? (await computeSecretHash(secret)).toString() : padHex3(recipient, { size: 32 }),
      inputToken: padHex3(tokenIn, { size: 32 }),
      outputToken: padHex3(tokenOut, { size: 32 }),
      amountIn,
      amountOut,
      senderNonce: nonce.toBigInt(),
      originDomain: chainIdIn,
      destinationDomain: chainIdOut,
      destinationSettler: padHex3(gatewayOut, { size: 32 }),
      fillDeadline,
      orderType: isPrivate ? PRIVATE_ORDER : PUBLIC_ORDER,
      data: data || padHex3("0x", { size: 32 })
    };
    const orderDataEncoder = new OrderDataEncoder(orderData);
    const publicClient = createPublicClient2({
      chain: chainIn,
      transport: http3()
    });
    const accountAddress = this.context.evmPrivateKey ? walletClient.account.address : sender;
    const balance = await publicClient.readContract({
      abi: erc20Abi2,
      address: tokenIn,
      functionName: "balanceOf",
      args: [accountAddress]
    });
    if (balance < amountIn) {
      throw new Error(
        `Insufficient token balance: have ${balance}, need ${amountIn} for token ${tokenIn} on chain ${chainIdIn}`
      );
    }
    let txHash = await walletClient.writeContract({
      abi: erc20Abi2,
      account: this.context.evmPrivateKey ? walletClient.account : sender,
      address: tokenIn,
      args: [gatewayIn, amountIn],
      chain: chainIn,
      functionName: "approve"
    });
    await publicClient.waitForTransactionReceipt({ hash: txHash, confirmations: 5 });
    let allowance = 0n;
    const maxAllowanceRetries = 3;
    for (let i = 0; i < maxAllowanceRetries; i++) {
      allowance = await publicClient.readContract({
        abi: erc20Abi2,
        address: tokenIn,
        functionName: "allowance",
        args: [accountAddress, gatewayIn]
      });
      if (allowance >= amountIn) {
        break;
      }
      if (i < maxAllowanceRetries - 1) {
        await new Promise((resolve2) => setTimeout(resolve2, 5e3));
      }
    }
    if (allowance < amountIn) {
      throw new Error(`Token approval failed: allowance is ${allowance}, need ${amountIn} for gateway ${gatewayIn}`);
    }
    txHash = await walletClient.writeContract({
      abi: l2Gateway7683_default,
      account: this.context.evmPrivateKey ? walletClient.account : sender,
      address: gatewayIn,
      args: [
        {
          fillDeadline,
          orderData: orderDataEncoder.encode(),
          orderDataType: ORDER_DATA_TYPE
        }
      ],
      chain: chainIn,
      functionName: "open"
    });
    const receipt = await publicClient.waitForTransactionReceipt({ hash: txHash });
    const { orderId, resolvedOrder } = getResolvedOrderAndOrderIdEvmByReceipt(receipt);
    if (secret)
      onSecret?.({
        orderId,
        secret: secret.toString()
      });
    onOrderOpened?.({
      orderId,
      resolvedOrder,
      transactionHash: txHash
    });
    await this.monitorEvmToAztecOrder(order, orderId, callbacks);
    if (secret) {
      const orderClaimedTxHash = await this.claimEvmToAztecPrivateOrder(orderId, secret.toString());
      onOrderClaimed?.({ orderId, transactionHash: orderClaimedTxHash });
      return {
        orderOpenedTxHash: txHash,
        orderClaimedTxHash,
        resolvedOrder
      };
    }
    return {
      orderOpenedTxHash: txHash,
      resolvedOrder
    };
  }
  async fillOrder(details) {
    const { orderId, orderData } = details;
    const gatewayOut = this.context.getAztecGatewayAddress();
    const orderType = orderData.orderType;
    const isPrivate = orderType === PRIVATE_ORDER || orderType === PRIVATE_ORDER_WITH_HOOK;
    const orderDataEncoder = new OrderDataEncoder(orderData);
    await this.context.maybeRegisterAztecGateway();
    if (this.context.azguardClient) {
      const selectedAccount = this.context.azguardClient.accounts[0];
      const fillerData2 = getAztecAddressFromAzguardAccount(selectedAccount);
      const response = await this.context.azguardClient.execute([
        {
          kind: "register_contract",
          chain: `aztec:${AZGUARD_CHAIN_ID}`,
          address: orderData.outputToken,
          artifact: TokenContractArtifact2
        },
        {
          kind: "send_transaction",
          account: selectedAccount,
          actions: [
            {
              kind: isPrivate ? "add_private_authwit" : "add_public_authwit",
              content: {
                kind: "call",
                caller: gatewayOut,
                contract: orderData.outputToken,
                method: isPrivate ? "transfer_private_to_public" : "transfer_public_to_public",
                args: isPrivate ? [
                  getAztecAddressFromAzguardAccount(selectedAccount),
                  AztecAddress4.fromString(gatewayOut),
                  // NOTE: private orders must be claimed by the user
                  orderData.amountOut,
                  orderData.senderNonce
                ] : [
                  getAztecAddressFromAzguardAccount(selectedAccount),
                  AztecAddress4.fromString(orderData.recipient),
                  orderData.amountOut,
                  orderData.senderNonce
                ]
              }
            },
            {
              kind: "call",
              contract: gatewayOut,
              method: isPrivate ? "fill_private" : "fill",
              args: [hexToUintArray(orderId), hexToUintArray(orderDataEncoder.encode()), hexToUintArray(fillerData2)]
            }
          ]
        }
      ]);
      for (const res of response) if (res.status === "failed") throw new Error(res.error);
      return response[1].result;
    }
    const wallet = await this.context.getAztecWallet();
    const account = await this.context.getAztecAccount();
    const fillerData = account.getAddress().toString();
    const tokenInstance = await createAztecNodeClient4(this.context.getAztecRpcUrl()).getContract(
      AztecAddress4.fromString(orderData.outputToken)
    );
    if (!tokenInstance) {
      throw new Error(`Token contract instance not found for address ${orderData.outputToken}`);
    }
    await wallet.registerContract(tokenInstance, TokenContractArtifact2);
    const [token, aztecGateway] = await Promise.all([
      TokenContract2.at(AztecAddress4.fromString(orderData.outputToken), wallet),
      AztecGateway7683Contract.at(AztecAddress4.fromString(gatewayOut), wallet)
    ]);
    let witness;
    if (isPrivate) {
      const action = token.withWallet(wallet).methods.transfer_private_to_public(
        account.getAddress(),
        AztecAddress4.fromString(gatewayOut),
        // NOTE: private orders must be claimed by the user
        orderData.amountOut,
        orderData.senderNonce
      );
      const call = await action.getFunctionCall();
      witness = await account.createAuthWit({
        caller: AztecAddress4.fromString(gatewayOut),
        call
      });
    } else {
      const action = token.withWallet(wallet).methods.transfer_public_to_public(
        account.getAddress(),
        AztecAddress4.fromString(orderData.recipient),
        orderData.amountOut,
        orderData.senderNonce
      );
      const call = await action.getFunctionCall();
      await (await setPublicAuthWit(
        wallet,
        account.getAddress(),
        {
          caller: AztecAddress4.fromString(gatewayOut),
          call
        },
        true
      )).send({ fee: { paymentMethod: await getSponsporedFeePaymentMethod() } }).wait({
        timeout: AZTEC_WAIT_TIMEOUT2
      });
    }
    const receipt = await aztecGateway.methods[isPrivate ? "fill_private" : "fill"](
      hexToUintArray(orderId),
      hexToUintArray(orderDataEncoder.encode()),
      hexToUintArray(fillerData)
    ).with({
      authWitnesses: witness ? [witness] : []
    }).send({
      from: account.getAddress(),
      fee: { paymentMethod: await getSponsporedFeePaymentMethod() }
    }).wait({
      timeout: AZTEC_WAIT_TIMEOUT2
    });
    return receipt.txHash.toString();
  }
  async refundOrder(details) {
    const { orderId, chainIdIn, chainIdOut } = details;
    const { gatewayIn, gatewayOut } = this.context.getGatewaysByChainIds(chainIdIn, chainIdOut);
    const internalChainIn = this.context.getChainByChainId(chainIdIn);
    if (internalChainIn.type !== "EVM" /* EVM */) throw new Error("ChainIn must be an EVM chain");
    const chainIn = internalChainIn.chain;
    const [orderType, orderData] = await createPublicClient2({
      chain: chainIn,
      transport: http3()
    }).readContract({
      address: gatewayIn,
      abi: l2Gateway7683_default,
      functionName: "openOrders",
      args: [orderId]
    });
    let originDataHex = orderData;
    if (!originDataHex || originDataHex.length <= 2) {
      const evmPublicClient = createPublicClient2({
        chain: chainIn,
        transport: http3()
      });
      const currentBlock = await evmPublicClient.getBlockNumber();
      const openEvent = l2Gateway7683_default.find((el) => el.type === "event" && el.name === "Open");
      const [log] = await evmPublicClient.getLogs({
        address: gatewayIn,
        event: openEvent,
        args: {
          orderId
        },
        fromBlock: currentBlock - 1000n,
        // Look back 1000 blocks
        toBlock: currentBlock
      });
      if (log) {
        const resolvedOrder = parseResolvedOrderEvm(log);
        if (resolvedOrder.fillInstructions?.[0]?.originData) {
          originDataHex = resolvedOrder.fillInstructions[0].originData;
        }
      }
    }
    if (!originDataHex || originDataHex.length <= 2)
      throw new Error("Cannot find an opened order (origin data) for the specified order id");
    await this.context.maybeRegisterAztecGateway();
    if (this.context.azguardClient) {
      const selectedAccount = this.context.azguardClient.accounts[0];
      const [response] = await this.context.azguardClient.execute([
        {
          kind: "send_transaction",
          account: selectedAccount,
          actions: [
            {
              kind: "call",
              contract: gatewayOut,
              method: "refund",
              args: [hexToUintArray(orderId), hexToUintArray(originDataHex)]
            }
          ]
        }
      ]);
      if (response.status === "failed") throw new Error(response.error);
      return response.result;
    } else {
      const wallet = await this.context.getAztecWallet();
      const account = await this.context.getAztecAccount();
      const gateway = await AztecGateway7683Contract.at(AztecAddress4.fromString(gatewayOut), wallet);
      const receipt = await gateway.methods.refund(hexToUintArray(orderId), hexToUintArray(originDataHex)).send({
        from: account.getAddress(),
        fee: {
          paymentMethod: await getSponsporedFeePaymentMethod()
        }
      }).wait({
        timeout: AZTEC_WAIT_TIMEOUT2
      });
      return receipt.txHash.toString();
    }
  }
  async claimEvmToAztecPrivateOrder(orderId, secret) {
    const gatewayOut = this.context.getAztecGatewayAddress();
    const log = await this.context.getAztecFilledLogByOrderId(orderId);
    if (!log) throw new Error(`Log not found for the specified order id ${orderId}`);
    const decodedOrder = OrderDataEncoder.decode(log.originData);
    if (this.context.azguardClient) {
      const selectedAccount = this.context.azguardClient.accounts[0];
      const [response] = await this.context.azguardClient.execute([
        {
          kind: "send_transaction",
          account: selectedAccount,
          actions: [
            {
              kind: "call",
              contract: gatewayOut,
              method: "claim_private",
              args: [
                secret,
                hexToUintArray(orderId),
                hexToUintArray(log.originData),
                hexToUintArray(log.fillerData)
              ]
            }
          ]
        }
      ]);
      if (response.status === "failed") throw new Error(response.error);
      return response.result;
    }
    const wallet = await this.context.getAztecWallet();
    const tokenAddress = AztecAddress4.fromString(decodedOrder.outputToken);
    const tokenInstance = await createAztecNodeClient4(this.context.getAztecRpcUrl()).getContract(tokenAddress);
    if (!tokenInstance) {
      throw new Error(`Token contract instance not found for address ${tokenAddress.toString()}`);
    }
    try {
      await wallet.registerContract(tokenInstance, TokenContractArtifact2);
    } catch (e) {
      console.warn(`Token contract at ${tokenAddress.toString()} might already be registered.`);
    }
    const account = await this.context.getAztecAccount();
    const gateway = await AztecGateway7683Contract.at(AztecAddress4.fromString(gatewayOut), wallet);
    const receipt = await gateway.methods.claim_private(
      Fr5.fromString(secret),
      hexToUintArray(orderId),
      hexToUintArray(log.originData),
      hexToUintArray(log.fillerData)
    ).send({
      from: account.getAddress(),
      fee: { paymentMethod: await getSponsporedFeePaymentMethod() }
    }).wait({
      timeout: AZTEC_WAIT_TIMEOUT2
    });
    return receipt.txHash.toString();
  }
  async monitorEvmToAztecOrder(order, orderId, callbacks) {
    const { chainIdIn, chainIdOut } = order;
    const { onOrderFilled } = callbacks || {};
    const { gatewayOut } = this.context.getGatewaysByChainIds(chainIdIn, chainIdOut);
    await this.context.maybeRegisterAztecGateway();
    if (this.context.azguardClient) {
      const selectedAccount = this.context.azguardClient.accounts[0];
      while (true) {
        const [response] = await this.context.azguardClient.execute([
          {
            kind: "simulate_views",
            account: selectedAccount,
            calls: [
              {
                kind: "call",
                contract: gatewayOut,
                method: "get_order_status",
                args: [orderId]
              }
            ]
          }
        ]);
        if (response.status === "failed") {
          if (response.error?.includes("feePerL2Gas")) {
            console.warn("[SDK] Transient gas error in order status check, retrying...", response.error);
            await sleep2(5e3);
            continue;
          }
          throw new Error(response.error);
        }
        const status = parseInt(BigInt(response.result.encoded[0][0]).toString());
        if (status === FILLED_PRIVATELY || status === FILLED) {
          onOrderFilled?.({ orderId });
          return;
        }
        await sleep2(3e3);
      }
    }
    const wallet = await this.context.getAztecWallet();
    const account = await this.context.getAztecAccount();
    while (true) {
      const gateway = await AztecGateway7683Contract.at(AztecAddress4.fromString(gatewayOut), wallet);
      const status = parseInt(
        await gateway.methods.get_order_status(Fr5.fromString(orderId)).simulate({ from: account.getAddress() })
      );
      if (status === FILLED_PRIVATELY || status === FILLED) {
        onOrderFilled?.({ orderId });
        return;
      }
      await sleep2(3e3);
    }
  }
};

// src/operations/ForwardOperations.ts
import { createPublicClient as createPublicClient3, encodeAbiParameters, http as http4, keccak256, padHex as padHex4 } from "viem";
import { computeL2ToL1MessageHash } from "@aztec/stdlib/hash";
import { AztecAddress as AztecAddress5, EthAddress } from "@aztec/aztec.js/addresses";
import { Fr as Fr6 } from "@aztec/aztec.js/fields";
import { sha256ToField } from "@aztec/foundation/crypto/sha256";
import { hexToBuffer } from "@aztec/foundation/string";

// src/utils/abi/rollup.ts
var rollup_default = [
  {
    inputs: [],
    name: "getProvenBlockNumber",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/utils/abi/forwarder.ts
var forwarder_default = [
  {
    type: "constructor",
    inputs: [
      {
        name: "l2Gateway",
        type: "address",
        internalType: "address"
      },
      {
        name: "aztecInbox",
        type: "address",
        internalType: "address"
      },
      {
        name: "aztecOutbox",
        type: "address",
        internalType: "address"
      },
      {
        name: "anchorStateRegistry",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "ANCHOR_STATE_REGISTRY",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "AZTEC_GATEWAY_7683",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "AZTEC_INBOX",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "AZTEC_OUTBOX",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "L2_GATEWAY",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "SECRET_HASH",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "forwardRefundToAztec",
    inputs: [
      {
        name: "orderId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "originData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "accountProofParams",
        type: "tuple",
        internalType: "struct StateValidator.AccountProofParameters",
        components: [
          {
            name: "storageKey",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "storageValue",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "accountProof",
            type: "bytes[]",
            internalType: "bytes[]"
          },
          {
            name: "storageProof",
            type: "bytes[]",
            internalType: "bytes[]"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "forwardRefundToL2",
    inputs: [
      {
        name: "l2ToL1Message",
        type: "tuple",
        internalType: "struct DataStructures.L2ToL1Msg",
        components: [
          {
            name: "sender",
            type: "tuple",
            internalType: "struct DataStructures.L2Actor",
            components: [
              {
                name: "actor",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "version",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          },
          {
            name: "recipient",
            type: "tuple",
            internalType: "struct DataStructures.L1Actor",
            components: [
              {
                name: "actor",
                type: "address",
                internalType: "address"
              },
              {
                name: "chainId",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          },
          {
            name: "content",
            type: "bytes32",
            internalType: "bytes32"
          }
        ]
      },
      {
        name: "message",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "aztecBlockNumber",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "leafIndex",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "path",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "forwardSettleToAztec",
    inputs: [
      {
        name: "orderId",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "originData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "fillerData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "accountProofParams",
        type: "tuple",
        internalType: "struct StateValidator.AccountProofParameters",
        components: [
          {
            name: "storageKey",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "storageValue",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "accountProof",
            type: "bytes[]",
            internalType: "bytes[]"
          },
          {
            name: "storageProof",
            type: "bytes[]",
            internalType: "bytes[]"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "forwardSettleToL2",
    inputs: [
      {
        name: "l2ToL1Message",
        type: "tuple",
        internalType: "struct DataStructures.L2ToL1Msg",
        components: [
          {
            name: "sender",
            type: "tuple",
            internalType: "struct DataStructures.L2Actor",
            components: [
              {
                name: "actor",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "version",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          },
          {
            name: "recipient",
            type: "tuple",
            internalType: "struct DataStructures.L1Actor",
            components: [
              {
                name: "actor",
                type: "address",
                internalType: "address"
              },
              {
                name: "chainId",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          },
          {
            name: "content",
            type: "bytes32",
            internalType: "bytes32"
          }
        ]
      },
      {
        name: "message",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "aztecBlockNumber",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "leafIndex",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "path",
        type: "bytes32[]",
        internalType: "bytes32[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "owner",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "renounceOwnership",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setAztecGateway7683",
    inputs: [
      {
        name: "aztecGateway7683",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferOwnership",
    inputs: [
      {
        name: "newOwner",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "event",
    name: "OwnershipTransferred",
    inputs: [
      {
        name: "previousOwner",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "newOwner",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RefundForwardedToAztec",
    inputs: [
      {
        name: "message",
        type: "bytes",
        indexed: false,
        internalType: "bytes"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RefundForwardedToL2",
    inputs: [
      {
        name: "message",
        type: "bytes",
        indexed: false,
        internalType: "bytes"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "SettleForwardedToAztec",
    inputs: [
      {
        name: "message",
        type: "bytes",
        indexed: false,
        internalType: "bytes"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "SettleForwardedToL2",
    inputs: [
      {
        name: "message",
        type: "bytes",
        indexed: false,
        internalType: "bytes"
      }
    ],
    anonymous: false
  },
  {
    type: "error",
    name: "ContentLengthMismatch",
    inputs: []
  },
  {
    type: "error",
    name: "EmptyItem",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidAccountRLP",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidAccountStorage",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidContent",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidDataRemainder",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidFilledOrderCommitment",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidHeader",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidRecipient",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidRefundedOrderCommitment",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidSender",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidStorageKey",
    inputs: []
  },
  {
    type: "error",
    name: "OwnableInvalidOwner",
    inputs: [
      {
        name: "owner",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "OwnableUnauthorizedAccount",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "UnexpectedList",
    inputs: []
  },
  {
    type: "error",
    name: "UnexpectedString",
    inputs: []
  }
];

// src/utils/abi/anchorRegistry.ts
var anchorRegistry_default = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  { inputs: [], name: "AnchorStateRegistry_AnchorGameBlacklisted", type: "error" },
  { inputs: [], name: "AnchorStateRegistry_InvalidAnchorGame", type: "error" },
  { inputs: [], name: "AnchorStateRegistry_Unauthorized", type: "error" },
  {
    anonymous: false,
    inputs: [{ indexed: true, internalType: "contract IFaultDisputeGame", name: "game", type: "address" }],
    name: "AnchorNotUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [{ indexed: true, internalType: "contract IFaultDisputeGame", name: "game", type: "address" }],
    name: "AnchorUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [{ indexed: false, internalType: "uint8", name: "version", type: "uint8" }],
    name: "Initialized",
    type: "event"
  },
  {
    inputs: [],
    name: "anchorGame",
    outputs: [{ internalType: "contract IFaultDisputeGame", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "GameType", name: "", type: "uint32" }],
    name: "anchors",
    outputs: [
      { internalType: "Hash", name: "", type: "bytes32" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "disputeGameFactory",
    outputs: [{ internalType: "contract IDisputeGameFactory", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAnchorRoot",
    outputs: [
      { internalType: "Hash", name: "", type: "bytes32" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "contract ISuperchainConfig", name: "_superchainConfig", type: "address" },
      { internalType: "contract IDisputeGameFactory", name: "_disputeGameFactory", type: "address" },
      { internalType: "contract IOptimismPortal2", name: "_portal", type: "address" },
      {
        components: [
          { internalType: "Hash", name: "root", type: "bytes32" },
          { internalType: "uint256", name: "l2BlockNumber", type: "uint256" }
        ],
        internalType: "struct OutputRoot",
        name: "_startingAnchorRoot",
        type: "tuple"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "contract IDisputeGame", name: "_game", type: "address" }],
    name: "isGameBlacklisted",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "contract IDisputeGame", name: "_game", type: "address" }],
    name: "isGameClaimValid",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "contract IDisputeGame", name: "_game", type: "address" }],
    name: "isGameFinalized",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "contract IDisputeGame", name: "_game", type: "address" }],
    name: "isGameProper",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "contract IDisputeGame", name: "_game", type: "address" }],
    name: "isGameRegistered",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "contract IDisputeGame", name: "_game", type: "address" }],
    name: "isGameResolved",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "contract IDisputeGame", name: "_game", type: "address" }],
    name: "isGameRespected",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "contract IDisputeGame", name: "_game", type: "address" }],
    name: "isGameRetired",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "portal",
    outputs: [{ internalType: "contract IOptimismPortal2", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "respectedGameType",
    outputs: [{ internalType: "GameType", name: "", type: "uint32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "contract IDisputeGame", name: "_game", type: "address" }],
    name: "setAnchorState",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "superchainConfig",
    outputs: [{ internalType: "contract ISuperchainConfig", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/operations/ForwardOperations.ts
var ForwardOperations = class {
  constructor(context) {
    this.context = context;
  }
  getAztecChainId() {
    return this.context.getAztecChainId();
  }
  async forwardRefundOrder(details) {
    const { chainIdIn, chainIdOut } = details;
    const aztecChainId = this.getAztecChainId();
    if (chainIdOut === aztecChainId) {
      return this.forwardToL2({ ...details, type: "forwardRefundToL2" });
    } else if (chainIdIn === aztecChainId) {
      return this.forwardToAztec({ ...details, type: "forwardRefundToAztec" });
    }
    throw new Error("Neither chain is Aztec");
  }
  async forwardSettleOrder(details) {
    const { chainIdIn, chainIdOut } = details;
    const aztecChainId = this.getAztecChainId();
    if (chainIdOut === aztecChainId) {
      return this.forwardToL2({ ...details, type: "forwardSettleToL2" });
    } else if (chainIdIn === aztecChainId) {
      return this.forwardToAztec({ ...details, type: "forwardSettleToAztec" });
    }
    throw new Error("Neither chain is Aztec");
  }
  async finalizeForwardRefundOrder(details) {
    const { chainIdIn, chainIdOut } = details;
    const aztecChainId = this.getAztecChainId();
    if (chainIdOut === aztecChainId) {
      return this.finalizeForwardToL2({
        ...details,
        type: "forwardRefundToL2"
      });
    } else if (chainIdIn === aztecChainId) {
      return this.finalizeForwardRefundOrderToAztec(details);
    }
    throw new Error("Neither chain is Aztec");
  }
  async finalizeForwardSettleOrder(details) {
    const { chainIdIn, chainIdOut } = details;
    const aztecChainId = this.getAztecChainId();
    if (chainIdOut === aztecChainId) {
      return this.finalizeForwardToL2({
        ...details,
        type: "forwardSettleToL2"
      });
    } else if (chainIdIn === aztecChainId) {
      return this.finalizeForwardSettleOrderToAztec(details);
    }
    throw new Error("Neither chain is Aztec");
  }
  async forwardToL2(details) {
    const { chainIdForwarder, chainIdIn, chainIdOut, fillerData, orderId, type } = details;
    if (!chainIdForwarder) throw new Error("You must specify a forwarder chain");
    const { gatewayOut } = this.context.getGatewaysByChainIds(chainIdIn, chainIdOut);
    const rollupAddress = this.context.aztecRollupContractL1Address;
    const forwarderAddress = this.context.forwarderAddress;
    if (!rollupAddress || !forwarderAddress) throw new Error("Forwarder chain not supported");
    const message = type === "forwardRefundToL2" ? [hexToBuffer(REFUND_ORDER_TYPE), hexToBuffer(orderId)] : [hexToBuffer(SETTLE_ORDER_TYPE), hexToBuffer(orderId), hexToBuffer(padHex4(fillerData))];
    const messageHash = sha256ToField(message);
    const forwarderChain = this.context.getForwarderChain();
    const l2ToL1MessageHash = computeL2ToL1MessageHash({
      l2Sender: AztecAddress5.fromString(gatewayOut),
      l1Recipient: EthAddress.fromString(forwarderAddress),
      content: Fr6.fromString(messageHash.toString()),
      rollupVersion: Fr6.fromString(AZTEC_VERSION.toString()),
      chainId: Fr6.fromString(forwarderChain.id.toString())
    });
    await this.context.maybeRegisterAztecGateway();
    const getRefundOrSettlementBlockNumber = async () => {
      const wallet = await this.context.getAztecWallet();
      const gateway = await AztecGateway7683Contract.at(AztecAddress5.fromString(gatewayOut), wallet);
      return await gateway.methods[type === "forwardRefundToL2" ? "get_order_refund_block_number" : "get_order_settlement_block_number"](Fr6.fromBufferReduce(hexToBuffer(orderId))).simulate({
        from: (await this.context.getAztecAccount()).getAddress()
      });
    };
    const aztecMessageBlockNumber = await getRefundOrSettlementBlockNumber();
    if (aztecMessageBlockNumber === 0n)
      throw new Error(`Order ${type === "forwardRefundToL2" ? "refund" : "settlement"} block number not found`);
    const aztecProvenBlockNumber = await createPublicClient3({
      chain: forwarderChain,
      transport: http4()
    }).readContract({
      address: rollupAddress,
      args: [],
      abi: rollup_default,
      functionName: "getProvenBlockNumber"
    });
    if (aztecMessageBlockNumber > aztecProvenBlockNumber) {
      throw new Error(
        `cannot forward to L2 for order ${orderId} because the corresponding block number ${aztecMessageBlockNumber} is > than the last proven ${aztecProvenBlockNumber}!`
      );
    }
    throw new Error("Forward to L2 not yet supported in SDK v2");
  }
  async forwardToAztec(details) {
    const { chainIdForwarder, chainIdIn, chainIdOut, fillerData, fillTransactionHash, orderId, originData, type } = details;
    if (!originData || !fillerData || !fillTransactionHash) {
      throw new Error("You must specify originData, fillerData and fillTransactionHash");
    }
    const forwarderChain = this.context.getForwarderChain();
    if (chainIdForwarder !== forwarderChain.id) {
      throw new Error(`chainForwarder must be ${forwarderChain.id}`);
    }
    const internalChainOut = this.context.getChainByChainId(chainIdOut);
    if (internalChainOut.type !== "EVM") throw new Error("chainOut must be an EVM chain");
    const chainOut = internalChainOut.chain;
    const { gatewayOut } = this.context.getGatewaysByChainIds(chainIdIn, chainIdOut);
    const forwarderAddress = this.context.forwarderAddress;
    if (!forwarderAddress) throw new Error("Forwarder chain not supported");
    const opStackAnchorRegistryAddress = this.context.opStackAnchorRegistryAddress;
    if (!opStackAnchorRegistryAddress) throw new Error("Invalid chainForwarder");
    const [_, l2EvmAnchorRootblockNumber] = await createPublicClient3({
      chain: forwarderChain,
      transport: http4()
    }).readContract({
      abi: anchorRegistry_default,
      functionName: "getAnchorRoot",
      args: [],
      address: opStackAnchorRegistryAddress
    });
    const l2EvmClient = createPublicClient3({
      chain: chainOut,
      transport: http4()
    });
    const receipt = await l2EvmClient.getTransactionReceipt({ hash: fillTransactionHash });
    if (receipt.blockNumber > l2EvmAnchorRootblockNumber) {
      throw new Error(
        `cannot forward to Aztec for order ${orderId} because the corresponding block number ${receipt.blockNumber} is > than the anchor root one ${l2EvmAnchorRootblockNumber} ...`
      );
    }
    const storageKey = keccak256(
      encodeAbiParameters(
        [{ type: "bytes32" }, { type: "uint256" }],
        [orderId, type === "forwardSettleToAztec" ? L2_GATEWAY_FILLED_ORDERS_SLOT : L2_GATEWAY_REFUNDED_ORDERS_SLOT]
      )
    );
    const proof = await l2EvmClient.request({
      method: "eth_getProof",
      params: [gatewayOut, [storageKey], `0x${l2EvmAnchorRootblockNumber.toString(16)}`]
    });
    const accountProofParameters = {
      storageKey: proof.storageProof[0].key,
      storageValue: proof.storageProof[0].value,
      accountProof: proof.accountProof,
      storageProof: proof.storageProof[0].proof
    };
    const { walletClient, address } = await this.context.getEvmWalletClientAndAddress(forwarderChain);
    return await walletClient.writeContract({
      abi: forwarder_default,
      account: this.context.evmPrivateKey ? walletClient.account : address,
      address: forwarderAddress,
      args: [orderId, originData, fillerData, accountProofParameters],
      chain: forwarderChain,
      functionName: type === "forwardSettleToAztec" ? "forwardSettleToAztec" : "forwardRefundToAztec"
    });
  }
  async finalizeForwardToL2(details) {
    const { chainIdForwarder, chainIdIn, chainIdOut, fillerData, orderId, type } = details;
    const forwarderChain = this.context.getForwarderChain();
    if (chainIdForwarder !== forwarderChain.id) {
      throw new Error(`chainForwarder must be ${forwarderChain.id}`);
    }
    const { chainIn, chainOut: internalChainOut } = this.context.getChainInAndOutByChainIds(chainIdIn, chainIdOut);
    if (internalChainOut.type !== "EVM") throw new Error("chainOut must be an EVM chain");
    const chainOut = internalChainOut.chain;
    const { gatewayIn } = this.context.getGatewaysByChainIds(chainIdIn, chainIdOut);
    const forwarderAddress = this.context.forwarderAddress;
    if (!forwarderAddress) throw new Error("Forwarder chain not supported");
    const message = type === "forwardRefundToL2" ? [hexToBuffer(REFUND_ORDER_TYPE), hexToBuffer(orderId)] : [hexToBuffer(SETTLE_ORDER_TYPE), hexToBuffer(orderId), hexToBuffer(padHex4(fillerData))];
    const messageHash = sha256ToField(message);
    const { parentBeaconBlockRoot: beaconRoot, timestamp: beaconOracleTimestamp } = await createPublicClient3({
      chain: chainOut,
      transport: http4()
    }).getBlock();
    if (!this.context.beaconApiUrl) throw new Error("Beacon api url not specified");
    const resp = await fetch(`${this.context.beaconApiUrl}/eth/v2/beacon/blocks/${beaconRoot}`, {
      headers: { Accept: "application/octet-stream" }
    });
    throw new Error("Beacon block processing not yet implemented in this version");
  }
  async finalizeForwardRefundOrderToAztec(details) {
    throw new Error("Not implemented");
  }
  async finalizeForwardSettleOrderToAztec(details) {
    throw new Error("Not implemented");
  }
};

// src/Bridge.ts
var Bridge = class _Bridge {
  get azguardClient() {
    return this.context.azguardClient;
  }
  get aztecWallet() {
    return this.context.aztecWallet;
  }
  get beaconApiUrl() {
    return this.context.beaconApiUrl;
  }
  get evmPrivateKey() {
    return this.context.evmPrivateKey;
  }
  get evmProvider() {
    return this.context.evmProvider;
  }
  constructor(configs) {
    this.context = new BridgeContext(configs);
    this.aztecToEvmOps = new AztecToEvmOperations(this.context);
    this.evmToAztecOps = new EvmToAztecOperations(this.context);
    this.forwardOps = new ForwardOperations(this.context);
  }
  static async create(configs) {
    const bridge = new _Bridge(configs);
    if (!bridge.azguardClient) {
      await bridge.context.maybeRegisterAztecGateway();
    }
    return bridge;
  }
  getAztecChainId() {
    const aztecConfig = this.context.chainsConfig.aztecDevnet;
    if (!aztecConfig) throw new Error("Aztec chain config not found");
    return aztecConfig.chain.id;
  }
  async openOrder(order, callbacks) {
    const validModes = ["private", "public", "privateWithHook", "publicWithHook"];
    const { chainIdIn, chainIdOut, mode, data } = order;
    if (chainIdIn === chainIdOut) throw new Error("Invalid chains: only cross-chain orders are supported");
    if (!validModes.includes(mode)) throw new Error(`Invalid mode: ${mode}`);
    if (data.length !== 66) throw new Error("Invalid data: must be 32 bytes");
    const aztecChainId = this.getAztecChainId();
    if (chainIdIn === aztecChainId) {
      return this.aztecToEvmOps.openOrder(order, callbacks);
    } else if (chainIdOut === aztecChainId) {
      return this.evmToAztecOps.openOrder(order, callbacks);
    } else {
      throw new Error("Neither chain is Aztec");
    }
  }
  async fillOrder(details) {
    const { orderData } = details;
    if (orderData.fillDeadline <= Math.floor(Date.now() / 1e3)) throw new Error("Order expired");
    const aztecChainId = this.getAztecChainId();
    if (orderData.originDomain === aztecChainId) {
      return this.aztecToEvmOps.fillOrder(details);
    } else if (orderData.destinationDomain === aztecChainId) {
      return this.evmToAztecOps.fillOrder(details);
    }
    throw new Error("Neither chain is Aztec");
  }
  async refundOrder(details) {
    const { chainIdIn, chainIdOut } = details;
    const aztecChainId = this.getAztecChainId();
    if (chainIdIn === aztecChainId) {
      return this.aztecToEvmOps.refundOrder(details);
    } else if (chainIdOut === aztecChainId) {
      return this.evmToAztecOps.refundOrder(details);
    }
    throw new Error("Neither chain is Aztec");
  }
  async claimEvmToAztecPrivateOrder(orderId, secret) {
    return this.evmToAztecOps.claimEvmToAztecPrivateOrder(orderId, secret);
  }
  async forwardRefundOrder(details) {
    return this.forwardOps.forwardRefundOrder(details);
  }
  async forwardSettleOrder(details) {
    return this.forwardOps.forwardSettleOrder(details);
  }
  async finalizeForwardRefundOrder(details) {
    return this.forwardOps.finalizeForwardRefundOrder(details);
  }
  async finalizeForwardSettleOrder(details) {
    return this.forwardOps.finalizeForwardSettleOrder(details);
  }
};

// src/config.ts
import { baseSepolia as baseSepolia2, sepolia as sepolia2 } from "viem/chains";
import * as chains from "viem/chains";
import * as fs from "fs";
import * as path from "path";
function findLatestDeploymentFile(baseDir, pattern) {
  const deploymentsDir = path.resolve(baseDir, "deployments");
  if (!fs.existsSync(deploymentsDir)) {
    return null;
  }
  const files = fs.readdirSync(deploymentsDir).filter((f) => pattern.test(f)).sort().reverse();
  const firstFile = files[0];
  return firstFile ? path.join(deploymentsDir, firstFile) : null;
}
function loadDeploymentJson(filePath) {
  if (!filePath || !fs.existsSync(filePath)) {
    return null;
  }
  try {
    return JSON.parse(fs.readFileSync(filePath, "utf-8"));
  } catch (e) {
    console.warn(`Failed to load deployment config from ${filePath}:`, e);
    return null;
  }
}
function loadTokensJson(filePath) {
  if (!filePath || !fs.existsSync(filePath)) {
    return null;
  }
  try {
    return JSON.parse(fs.readFileSync(filePath, "utf-8"));
  } catch (e) {
    console.warn(`Failed to load tokens config from ${filePath}:`, e);
    return null;
  }
}
function getChainById(chainId) {
  const chain = Object.values(chains).find(({ id }) => id === chainId);
  if (!chain) {
    throw new Error(`Chain not found for ID: ${chainId}`);
  }
  return chain;
}
var DEFAULT_AZTEC_CHAIN_ID = 999999;
var DEFAULT_EVM_L2_CHAIN_ID = baseSepolia2.id;
var DEFAULT_FORWARDER_CHAIN_ID2 = sepolia2.id;
var DEFAULT_AZTEC_ROLLUP_L1_ADDRESS2 = "0xb05f36c9dffa76f0af639385ef44d5560e0160c1";
var DEFAULT_OP_STACK_ANCHOR_REGISTRY2 = "0x0729957c92A1F50590A84cb2D65D761093f3f8eB";
function createSdkConfig(input) {
  const baseDir = input.baseDir || process.cwd();
  let deployment = null;
  let tokens = null;
  if (input.deploymentJsonPath) {
    deployment = loadDeploymentJson(input.deploymentJsonPath);
    if (deployment) {
      console.log(`Loaded deployment config from: ${input.deploymentJsonPath}`);
    }
  } else {
    const autoDeploymentPath = findLatestDeploymentFile(baseDir, /^deploy_\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}\.json$/);
    if (autoDeploymentPath) {
      deployment = loadDeploymentJson(autoDeploymentPath);
      if (deployment) {
        console.log(`Auto-loaded deployment config from: ${autoDeploymentPath}`);
      }
    }
  }
  if (input.tokensJsonPath) {
    tokens = loadTokensJson(input.tokensJsonPath);
    if (tokens) {
      console.log(`Loaded tokens config from: ${input.tokensJsonPath}`);
    }
  } else {
    const autoTokensPath = findLatestDeploymentFile(
      baseDir,
      /^tokens_deploy_\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}\.json$/
    );
    if (autoTokensPath) {
      tokens = loadTokensJson(autoTokensPath);
      if (tokens) {
        console.log(`Auto-loaded tokens config from: ${autoTokensPath}`);
      }
    }
  }
  const evmL2ChainId = input.evmL2ChainId ?? DEFAULT_EVM_L2_CHAIN_ID;
  const forwarderChainId = input.forwarderChainId ?? DEFAULT_FORWARDER_CHAIN_ID2;
  const aztecChainId = input.aztecChainId ?? DEFAULT_AZTEC_CHAIN_ID;
  const l2EvmGatewayAddress = input.l2EvmGatewayAddress ?? deployment?.L2Gateway7683?.address;
  const aztecGatewayAddress = input.aztecGatewayAddress ?? deployment?.AztecGateway7683?.address;
  const forwarderAddress = input.forwarderAddress ?? deployment?.Forwarder?.address;
  const aztecTokenAddress = input.aztecTokenAddress ?? tokens?.AztecToken?.address;
  const evmTokenAddress = input.evmTokenAddress ?? tokens?.EVMToken?.address;
  if (!l2EvmGatewayAddress) {
    throw new Error("Missing L2 EVM Gateway address. Provide via config or deployment JSON.");
  }
  if (!aztecGatewayAddress) {
    throw new Error("Missing Aztec Gateway address. Provide via config or deployment JSON.");
  }
  if (!forwarderAddress) {
    throw new Error("Missing Forwarder address. Provide via config or deployment JSON.");
  }
  const evmL2Chain = getChainById(evmL2ChainId);
  const forwarderChain = getChainById(forwarderChainId);
  return {
    chains: {
      aztec: {
        type: "AZTEC" /* AZTEC */,
        id: aztecChainId,
        name: "Aztec",
        rpcUrl: input.aztecRpcUrl,
        gatewayAddress: aztecGatewayAddress,
        tokens: aztecTokenAddress ? [{ name: "Token", symbol: "TKN", decimals: 18, address: aztecTokenAddress }] : []
      },
      evm: {
        type: "EVM" /* EVM */,
        id: evmL2ChainId,
        name: evmL2Chain.name,
        rpcUrl: input.evmL2RpcUrl,
        chain: evmL2Chain,
        gatewayAddress: l2EvmGatewayAddress,
        tokens: evmTokenAddress ? [{ name: "Token", symbol: "TKN", decimals: 18, address: evmTokenAddress }] : []
      }
    },
    forwarderAddress,
    forwarderChain,
    aztecRollupContractL1Address: input.aztecRollupContractL1Address ?? DEFAULT_AZTEC_ROLLUP_L1_ADDRESS2,
    opStackAnchorRegistryAddress: input.opStackAnchorRegistryAddress ?? DEFAULT_OP_STACK_ANCHOR_REGISTRY2,
    l1ChainId: forwarderChainId
  };
}
function configToInternalChains(config) {
  const aztecChain = {
    id: Number(config.chains.aztec.id),
    name: config.chains.aztec.name,
    rpcUrls: {
      default: {
        http: [config.chains.aztec.rpcUrl]
      }
    }
  };
  return {
    aztecDevnet: {
      type: "AZTEC" /* AZTEC */,
      chain: aztecChain,
      gatewayAddress: config.chains.aztec.gatewayAddress
    },
    baseSepolia: {
      type: "EVM" /* EVM */,
      chain: config.chains.evm.chain,
      gatewayAddress: config.chains.evm.gatewayAddress
    }
  };
}
var isEvmChainConfig = (config) => {
  return config.type === "EVM" /* EVM */;
};
var isAztecChainConfig = (config) => {
  return config.type === "AZTEC" /* AZTEC */;
};

// src/services/EvmService.ts
import { createWalletClient as createWalletClient2, custom as custom2, http as http5 } from "viem";
import { privateKeyToAccount as privateKeyToAccount2 } from "viem/accounts";
var _config;
var EvmService = class {
  constructor(config) {
    __privateAdd(this, _config);
    __privateSet(this, _config, config);
  }
  async getWalletClientAndAddress(chain) {
    if (__privateGet(this, _config).evmPrivateKey) {
      const account = privateKeyToAccount2(__privateGet(this, _config).evmPrivateKey);
      const client = createWalletClient2({
        account,
        chain,
        transport: http5()
      });
      return { client, address: account.address };
    }
    if (__privateGet(this, _config).evmProvider) {
      const client = createWalletClient2({
        chain,
        transport: custom2(__privateGet(this, _config).evmProvider)
      });
      const [address] = await client.getAddresses();
      return { client, address };
    }
    throw new Error("No EVM provider or private key configured");
  }
};
_config = new WeakMap();

// src/helpers/BridgeHelpers.ts
var BridgeHelpers = class _BridgeHelpers {
  static getChainInAndOutByChainIds(chainIdIn, chainIdOut, chainsConfig2 = defaultChainsConfig) {
    return {
      chainIn: _BridgeHelpers.getChainByChainId(chainIdIn, chainsConfig2),
      chainOut: _BridgeHelpers.getChainByChainId(chainIdOut, chainsConfig2)
    };
  }
  static getChainByChainId(chainId, chainsConfig2 = defaultChainsConfig) {
    const chainConfig = Object.values(chainsConfig2).find((config) => config.chain.id === chainId);
    if (chainConfig) {
      return chainConfig;
    }
    throw new Error(`Chain not found for chainId: ${chainId}`);
  }
  static getOrderType(mode) {
    switch (mode) {
      case "public":
      case "publicWithHook":
        return PUBLIC_ORDER;
      case "private":
      case "privateWithHook":
        return PRIVATE_ORDER;
      default:
        throw new Error(`Invalid order mode: ${mode}`);
    }
  }
  static getGatewaysByChainIds(chainIdIn, chainIdOut, chainsConfig2 = defaultChainsConfig) {
    const chainIn = Object.values(chainsConfig2).find((c) => c.chain.id === chainIdIn);
    const chainOut = Object.values(chainsConfig2).find((c) => c.chain.id === chainIdOut);
    if (!chainIn || !chainIn.gatewayAddress) {
      throw new Error(`Gateway not found for chain ${chainIdIn}`);
    }
    if (!chainOut || !chainOut.gatewayAddress) {
      throw new Error(`Gateway not found for chain ${chainIdOut}`);
    }
    return {
      gatewayIn: chainIn.gatewayAddress,
      gatewayOut: chainOut.gatewayAddress
    };
  }
};

// src/utils/LogQueries.ts
import { createAztecNodeClient as createAztecNodeClient5 } from "@aztec/aztec.js/node";
import { AztecAddress as AztecAddress6 } from "@aztec/aztec.js/addresses";
function getDefaultConfig() {
  const aztecConfig = defaultChainsConfig.aztecDevnet;
  return {
    aztecGatewayAddress: aztecConfig.gatewayAddress,
    aztecRpcUrl: aztecConfig.chain.rpcUrls.default.http[0]
  };
}
var LogQueries = class {
  /**
   * Find a filled order log by order ID
   * Searches through Aztec gateway public logs for a filled event matching the given order ID
   *
   * @param orderId - The order ID to search for
   * @param config - Optional config with gateway address and RPC URL
   * @returns The filled log if found, undefined otherwise
   */
  static async getAztecFilledLogByOrderId(orderId, config) {
    const { aztecGatewayAddress, aztecRpcUrl } = config ?? getDefaultConfig();
    const { logs } = await createAztecNodeClient5(aztecRpcUrl).getPublicLogs({
      contractAddress: AztecAddress6.fromString(aztecGatewayAddress)
    });
    const filledLogs = logs.filter(({ log }) => log.fields.length === 13 && log.fields[11] !== void 0);
    const parsedLogs = filledLogs.map(({ log }) => parseFilledLog(log.fields));
    return parsedLogs.find((log) => log.orderId === orderId);
  }
  /**
   * Find an opened order by order ID
   * Searches through Aztec gateway public logs for an open event matching the given order ID
   *
   * @param orderId - The order ID to search for
   * @param config - Optional config with gateway address and RPC URL
   * @returns The resolved order if found, undefined otherwise
   */
  static async getAztecOpenLogByOrderId(orderId, config) {
    const { aztecGatewayAddress, aztecRpcUrl } = config ?? getDefaultConfig();
    const { logs } = await createAztecNodeClient5(aztecRpcUrl).getPublicLogs({
      contractAddress: AztecAddress6.fromString(aztecGatewayAddress)
    });
    const parsedOpenLogs = getResolvedOrderByAztecLogs(logs);
    return parsedOpenLogs.find((order) => order.orderId === orderId);
  }
};
export {
  AZGUARD_CHAIN_ID,
  AZTEC_VERSION,
  Bridge,
  BridgeHelpers,
  DEFAULT_AZTEC_ROLLUP_L1_ADDRESS,
  DEFAULT_FORWARDER_ADDRESS,
  DEFAULT_FORWARDER_CHAIN_ID,
  DEFAULT_OP_STACK_ANCHOR_REGISTRY,
  EvmService,
  FILLED,
  FILLED_PRIVATELY,
  FORWARDER_CHAIN,
  FORWARDER_REFUNDED_ORDERS_SLOT,
  FORWARDER_SETTLE_ORDER_SLOT,
  L2_GATEWAY_FILLED_ORDERS_SLOT,
  L2_GATEWAY_REFUNDED_ORDERS_SLOT,
  LogQueries,
  OPENED,
  ORDER_DATA_PACKED_TYPES,
  ORDER_DATA_TYPE,
  OrderDataEncoder,
  PRIVATE_ORDER,
  PRIVATE_ORDER_WITH_HOOK,
  PRIVATE_SENDER,
  PUBLIC_ORDER,
  PUBLIC_ORDER_WITH_HOOK,
  REFUND_ORDER_TYPE,
  SETTLE_ORDER_TYPE,
  SponsoredFPCContractArtifact,
  aztecRollupContractL1Addresses,
  aztecSepolia,
  chainsConfig,
  configToInternalChains,
  createSdkConfig,
  defaultChainsConfig,
  forwarderAddresses,
  getAztecAddressFromAzguardAccount,
  getResolvedOrderAndOrderIdEvmByReceipt,
  getResolvedOrderByAztecLogs,
  getSponsoredFPCAddress,
  getSponsoredFPCInstance,
  getSponsporedFeePaymentMethod,
  hexToUintArray,
  isAztecChainConfig,
  isEvmChainConfig,
  opStackAnchorRegistryAddresses,
  parseFilledLog,
  parseResolvedAztecOrder,
  parseResolvedOrderEvm,
  parseResolvedOrderFromOpen1AndOpen2Logs,
  setPublicAuthWit
};
