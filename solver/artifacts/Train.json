{"transpiled":true,"noir_version":"1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec","name":"Train","functions":[{"name":"constructor","is_unconstrained":true,"custom_attributes":["external","initializer","public"],"abi":{"parameters":[],"return_type":null,"error_types":{"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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"},{"name":"get_htlc","is_unconstrained":true,"custom_attributes":["external","view","public"],"abi":{"parameters":[{"name":"swap_id","type":{"kind":"field"},"visibility":"private"},{"name":"htlc_id","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"Train::HTLC_Public","fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"hashlock_high","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"hashlock_low","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret_high","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret_low","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"src_receiver","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"timelock","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"claimed","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"reward","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"reward_timelock","type":{"kind":"integer","sign":"unsigned","width":64}}]},"visibility":"public"},"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"2718955667607728260":{"error_kind":"string","string":"Function get_htlc can only be called statically"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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"},{"name":"get_user_swaps_count","is_unconstrained":true,"custom_attributes":["external","view","public"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"3781809441605198943":{"error_kind":"string","string":"Function get_user_swaps_count can only be called statically"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBGJwAABEYnAgIEAScCAwQAHwoAAgADAEQtCEQBJQAAAEUlAAAASy0CAUUnAgIERScCAwQBOw4AAwACJwBDBAMmJQAABWgeAgACAB4CAAMAMyoAAgADAAQnAgIBASQCAAQAAAB0JQAABY4eAgADCSQCAAMAAACGJQAABaAnAgMAAC0IAQQnAgUEBAAIAQUBJwMEBAEAIgQCBS0KBQYtDgMGACIGAgYtDgMGACIGAgYtDgMGKwIABQAAAAAAAAAAAgAAAAAAAAAALQgBBicCBwQFAAgBBwEnAwYEAQAiBgIHLQoHCC0OAwgAIggCCC0OAwgAIggCCC0OAwgAIggCCC0OBQgtCAEFAAABAgEtDgQFLQgBBAAAAQIBLQ4GBC0IAQcAAAECAScCCAQALQ4IBy0IAQkAAAECAScCCgEALQ4KCScCCwACJwIMBAEkAgAKAAABqSMAAAFiLQgBDScCDgQEAAgBDgEnAw0EAQAiDQIOLQoODy0OCw8AIg8CDy0OAw8AIg8CDy0OAw8tDg0FLQ4GBC0ODActDgoJIwAAAjUtCggGIwAAAbIMIgZDDSQCAA0AAATiIwAAAcQtCwUGLQsEDS0LCQ4tCw0PACIPAg8tDg8NLQgBDycCEAQFAAgBEAEnAw8EAQAiDQIQJwIRBAQAIg8CEj8PABAAEi0CBgMnAAQEBCUAAAWyLQgFDQAqDQwQLQ4LEC0ODQUtDg8ELQ4MBy0ODgkjAAACNS0LBQYtCwQLLQsJDQoqDQoOJAIADgAAAlcnAg8EADwGDwEkAgAKAAACmSMAAAJkJwINBAItAgYDJwAEBAQlAAAFsi0IBQ4AKg4NDy0OAQ8tDg4FLQ4LBC0ODQctDgoJIwAAAyUtCggGIwAAAqIMIgZDCyQCAAsAAARcIwAAArQtCwUGLQsECy0LCQ0tCwsOACIOAg4tDg4LLQgBDicCDwQFAAgBDwEnAw4EAQAiCwIPJwIQBAQAIg4CET8PAA8AES0CBgMnAAQEBCUAAAWyLQgFCwAqCwwPLQ4BDy0OCwUtDg4ELQ4MBy0ODQkjAAADJS0LCQYKKgYKCyQCAAsAAAM/JwINBAA8Bg0BLQoIASMAAANIDCIBQwYkAgAGAAAD1iMAAANaLQsFAS0LBAYtCwcILQsGCwAiCwILLQ4LBi0IAQsnAg0EBQAIAQ0BJwMLBAEAIgYCDScCDgQEACILAg8/DwANAA8tDgEFLQ4LBC0OCActDgIJACoLDAItCwIBCioBAwIKKgIKAyQCAAMAAAPLJQAABhYvCgABAAItCgIBJi0LBQYtCwQILQsHCy0LCQ0MKgELDiQCAA4AAAP4IwAABE4AIggCDwAqDwEQLQsQDgAiBgIQACoQAREtCxEPACoODxAtAggDJwAEBAUlAAAFsi0IBQ4AIg4CDwAqDwERLQ4QES0OBgUtDg4ELQ4LBy0ODQkjAAAETgAqAQwGLQoGASMAAANILQsFCy0LBA0tCwcOLQsJDwwqBg4QJAIAEAAABH4jAAAE1AAiDQIRACoRBhItCxIQACILAhIAKhIGEy0LExEAKhAREi0CDQMnAAQEBSUAAAWyLQgFEAAiEAIRACoRBhMtDhITLQ4LBS0OEAQtDg4HLQ4PCSMAAATUACoGDAstCgsGIwAAAqItCwUNLQsEDi0LBw8tCwkQDCoGDxEkAgARAAAFBCMAAAVaACIOAhIAKhIGEy0LExEAIg0CEwAqEwYULQsUEgAqERITLQIOAycABAQFJQAABbItCAURACIRAhIAKhIGFC0OExQtDg0FLQ4RBC0ODwctDhAJIwAABVoAKgYMDS0KDQYjAAABsigAAAQEeEYMAAAEAyQAAAMAAAWNKgEAAQXaxfXWtEoybTwEAgEmKgEAAQUGYTs9C529MzwEAgEmKgEAAQU0e6+mdxikXzwEAgEmLQEDBgoABgIHJAAABwAABcgjAAAF0S0AAwUjAAAGFS0AAQUAAAEEAQAAAwQJLQADCi0ABQsKAAoJDCQAAAwAAAYLLQEKCC0ECAsAAAoCCgAACwILIwAABecnAQUEAQIABgIGJioBAAEFursh14IzGGQ8BAIBJg==","debug_symbols":"tZnbbhs5DIbfxde+kEhRh7xKURRp6hYBDCdwkwUWRd59SQ1/2c5iBNdpb+JvONE/POkw9q/Nt93X1x9fHg/fn35u7j792nw9Pu73jz++7J8e7l8enw5q/bUJ9qfq37TdVNncle2m6VUM+ln1M243MbBDjICsoCMimUUMmgOnzR2RQXNIDKgOAovAkmHJxaFEQHYwLxcQgD2CtxuKAZAAuEWwECwMC1eHRIDiIBGQHTIekQVggpoNKgyoDpUA2aFFgAB8OIcEgCUyoDgQAWARGyUG1aHnsAMsBZYCS3esQ3bojnWQBVIIAHtENqgOkQDZoSezKojdagbZoWesQwJUh+5YBw2HNZxUIyA7NFiaWyREACwRFksUa0uINeQC2YFhYXFIAaCOMRtUB4tigexg5eZk0BzM+QXsoZoosax2sKmzgCyQoyc891IaUAR4CTLDwl6CnALAS5CTlyALAbwEuXgJcvMS5OYlKCEAEsBLUCIDvASFIsDTWxgWhiXBkmARWMRLUHIEeAlKgaV4CUoNAC9BqV6C0gjgJajBRhUDK4FGWm2ad7B5sUBxsNSlYIuZCiZ1rGYCZIcSAAnQHKqmJdlDa3EwfxZwSwsEgCXCEmEha5JmUBx6MjsIwB6qjdSsyguYz7YE2wq5ACzdeQNLppAtz7RE2mzKdGgBkAA6XNjW8OjBx2B1dho21pGSOgkoDZv5J9KpYUT3cKEKysNmy/hChQYNWx0e2FLuNJQbVGLA2L7hWI/HSGFQGlRBrCMkG4m3vpKA8rDZkiSlUwOVYbPlUrpeZYywflgI00wJNrKlySmD4rBFGdRAxIOGCo+xgihJ0iBESdbRTtnjpZowto5ntGHrfWCxsW3mTsNm7dvjXTYcG8EUB8Er5mFjRMQpDDrZ4AELDxrKeaiUPvbtbbvBmeTLy3G3syPJ2SFFjy7P98fd4WVzd3jd77ebf+73r/2ffj7fH/rny/1R72rD7w7f9FMFvz/ud0Zv29PosD5UWy1UH67c6pDQzrwQiRMRsgm6aFAuZxJyIUETiRpKhEYN9RRKiRcavK7BJNJcQ7nImsYsFKYENzil1VDkD4SS/3IoVHmEEtarUtclSi2Q0O2prTnRJoFwtjV7CYRz+3AgaT2QSZvrRoUObTG19SaftCg1ZvSGsqzWNc56lNnON54PTnVN5NpgJK4GE6YpLWPaUwunssi7WCZNmrnAj5zorC71cvmJZeKILeJLSgMNBavyhcKsR9OIpAidAuHYLjVmXTp6VA/4Q4H4Mhc0SahucJjzRKGta0z6XAhTXjjcptBGQaLcFofuooiDzyryP400qylhR4pyNl9/TyO3oVHbbRr6YjnWDarrGmXWXegMPfnfpNAS5rueaW9S0H2Zxhad1+vKk7qmlNGfKZ3v8u030plOW6PcWFYeHapYb9L4E6FEHh0aU71tppQ4lq4yma+c/65GzHnEkku9TaOMfT7qRr+u0T46U2YK182UmcK1MyXRh9trms52WngaradzurlKQChZz4Krm2uanERzYfih3XV2UIjv0jFr0RrHhlA5n6Xj+neMy8PG2Q777rCR6uzgNN5T9NzEq36k2Tavr9hDJDRZPdBKmInQ6USrb0xxVSTODhx5lFeZV4/F0/kSxjGQbpxxGU60Ih+dsxOF6f54VRRThauiuHKPfq/wWS/vHx6PF78evJnU8fH+637nl99fDw9nd1/+fcYd/PrwfHx62H17Pe5M6fQThP75pG201W+6P9uXQHqp5/Gtfl1ul9Hu6pfu+tLw+c2c+Q8="},{"name":"has_htlc","is_unconstrained":true,"custom_attributes":["external","view","public"],"abi":{"parameters":[{"name":"swap_id","type":{"kind":"field"},"visibility":"private"},{"name":"htlc_id","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16190783185788596410":{"error_kind":"string","string":"Function has_htlc can only be called statically"}}},"bytecode":"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","debug_symbols":"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"},{"name":"lock_dst","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"swap_id","type":{"kind":"field"},"visibility":"private"},{"name":"htlc_id","type":{"kind":"field"},"visibility":"private"},{"name":"hashlock_high","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"hashlock_low","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"reward","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"reward_timelock","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"timelock","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"src_receiver","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"total_amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"src_asset","type":{"kind":"string","length":30},"visibility":"private"},{"name":"dst_chain","type":{"kind":"string","length":30},"visibility":"private"},{"name":"dst_asset","type":{"kind":"string","length":30},"visibility":"private"},{"name":"dst_address","type":{"kind":"string","length":90},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"459713770342432051":{"error_kind":"string","string":"Not initialized"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2360858009427093503":{"error_kind":"string","string":"InvalidTimelock"},"3380315280177356474":{"error_kind":"string","string":"FundsNotSent"},"4736483829072576196":{"error_kind":"string","string":"HTLCAlreadyExists"},"7413154743021792023":{"error_kind":"string","string":"InvalidRewardAmount"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14576755381182599325":{"error_kind":"fmtstring","length":24,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16884080922827299127":{"error_kind":"string","string":"InvalidRewardTimelock"}}},"bytecode":"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","debug_symbols":"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"},{"name":"lock_src","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"swap_id","type":{"kind":"field"},"visibility":"private"},{"name":"hashlock_high","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"hashlock_low","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"timelock","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"src_receiver","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"src_asset","type":{"kind":"string","length":30},"visibility":"private"},{"name":"dst_chain","type":{"kind":"string","length":30},"visibility":"private"},{"name":"dst_asset","type":{"kind":"string","length":30},"visibility":"private"},{"name":"dst_address","type":{"kind":"string","length":90},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2360858009427093503":{"error_kind":"string","string":"InvalidTimelock"},"3380315280177356474":{"error_kind":"string","string":"FundsNotSent"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14576755381182599325":{"error_kind":"fmtstring","length":24,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"17552554873437466887":{"error_kind":"string","string":"SwapAlreadyInitialized"}}},"bytecode":"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","debug_symbols":"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"},{"name":"process_message","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"private"}],"return_type":null,"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"H4sIAAAAAAAA/+y9CbwdR3Eu3kd3sa50paN9t3WuJEuybMuLvIFtRd43yRaWN8wqW/ICBhlLAgwkOICBEIgBL2Bs2fLO5gUwYJaADEnIvpEX3iPhkUcWSAIEwpIF/uTP2FP3fvc73/Tpmem590ia+f1snTtdXVVdXVVdXb1Mwz37NNN/r79h25Vbt29/ySt++b/NV2+9+JevGmlRb/rvAem/yfvpbvRjsC0X9DRywI6ulINGw1VPY4KrnkaPq55Gr6ueRp+rnka/q57GAa56GhNd9TQGXPU0JrnqaUx21dMYdNXTmOKqpzHVVU+j6aqnMc3lp1GEznQ3NnRmhMM+g3udeJeH3kxXfR/NctXTmO2qpzHHVU9jrquexjxXPY35rnoaC1z1NBa66mksctXTONBVT+MgVz2Nxa56Gi1XPY0hVz2NJa56Gktd9TSWueppHOyqp7HcVU9jhauexkpXPY1DXPU0VrnqaRzqqqdxmKuexuGuehqrXfU0jnDV0zjSVU/jKFc9jaNd9TTWuOppHOOqp3Gsq57Gca56Gse76mmc4Kqn8RxXPY3nuuppnOiqp3GSq57Gya56Gmtd9TR+xVVPY52rnsYprnoap7rqaZzmqqdxuquexhmuehpnuuppnOWqp3G2q57GOa56Gue66mmc56qnsd5VT2ODq57G+a56Ghe46mlsdNXTeJ6rnsaFLj+NInQ2ubGhc5EbGzoXuwJ0LiGCyYaGZMNBsiEgWbBPFtSTBe9kQTpZME4WdJMF12RBNFmwTBYUkwW/ZEEuWSxLFrKSxaVk8SdZnEkWT5LFjWTxIVkcSJL3SXI9SX4nyekkeWzJ3aFf/pckL5PkYpL8S5JzSfIsSW4lyackOZQkb5LkSpL8SJITSfIgmdwnk+9kcpxMXpPJZTL5SyZnyeQpmdwkk49kcpAE70lwnQS/SXCaBI9JcLful/8lwVESvCTBRTL4J4NzMngmg1sy+CSDQ+K8E+eaOL/EOSXOIzHuxPgS40iUN1GspNMvdtmPdW7G/pubL3v29cS0eAJUy7EfpDGRyOWrf9PHJzLCXPXdM/WTOhOL1b/E6g8Uq/+M+ibPC6E+8mJ4e9J/XwF1X0E0DeZxgHmcYIzfYvJ2LyzZ3umDbnQbDYcD3iYVwz0D22RPD71D/AOuVN83GoTP6HH7zDYGAcboNaisV/BpZX1QZvJPXN8qgOO+nUhlxkvyvILKeqDslem/1ifIVw4ZbSupL+sq1JdT9kZ96aWyGPqCOFhfDEfyPE5l/VD2BJUdAGUfA9rHwu8L0t8lfdKwDy84Bj0TEjB9xGX82tND/yaPyclkP1HAW9kAlKHsk2cSvO8RuA6gegZ/TPrv1PRf7Bur3xT0+4m+4lvpZkPg6hHvDD6Rz+HAs+E8DWBbLujpsbqnq7o/3v61h//oXZ/4nQ/ueOShO6Z/fcqdkw+b9Mabb/63hd9f9IEf3PyA1T0D2tFwwbT7rf6ZivbaT/dcfs3H/nvb5LPe/Phrvv5/zt85ZdHmLy1++0OX/+57Fv/zS95qdc9Sdb/zzrve2Hz8vbtbh/7JT/rPuuW7L/nROX0nfP1P3jD/y2/6+T//4Fare7aq+5eX//wbTzZvfd1r3/WZ15+wcubmj976tR/+y1f+6LHmj/7fo6/62rFW9xxoc579tFb/3GL1h2O884rVn2D110P9IjHmhmL1p1n98+Fly378+oMf/MYp7/qTI//+55PesWHzW1675je/eun3XjfvkYP/8WWPLvrodKt7gar7rR2nvWfH3Fcc972Jf/auo+5beOA3f/zIk9/+6Y1bT/jut7/zqaEfWd2Nqm6Hx+o+T9Sdd/SK51z//j+f9bcrl/zNuj0fXX3b/B8vO+lvnzr7vh/89x/8J9S9MP03p7yG+2tTsfq9Vv+iYvWH/cPFUD+HjQ/ryyXF6g/Tv7RY/WH5XQYvW/46wyGM1X1+eF17+qzu5aLuqpMGfvDQO37tZvd3j/zrb/101efXHT79oFOmr/6ru/564StveMH8H1jdFwBDOfpsUTImJGPburTRyRR+WVq4c8e1112748ZTtm/fesOO07a94vrNO6694rqtF9yw+crrtl6y9Ybt1257JSNs0N+nZbxP6MwbTeesrTsufvbXadteuWPra3f0EV6ORQfo70n092T6m+Mze6/ivJDHYq4phE/961x7jJs8Nk43CRe2x+KsqVCWQ683Wv1msfpbrf60YvVvsPrTi9W/yurPKFZ/eC40s1j9V1j9WcXqX2v1Zxer/0qrP6dY/aut/txi9VtWf16x+tut/vxi9Tdb/QXF6m+x+guL1b/S6i8qVv/VVv/AYvVvND9zELw0H2K4F8P7HP7/wBA/hfgHiJe8MWGD8Bk9bh/OxVFWWLcpynw+ske8m+DB1YyIa1pEXNMj4poREVfMNs6MiGtWRFyzI+KaExHX3Ii4Yso+pg3N61Jc8yPiiqkTMWUfU78WRMQV07Zj6sTCiLhi+uhFEXF16/hocZbFDhhrNDL+NTr8zugMEK6GKxb3tIge82f0Jrr2duWgNyzHIUFPxVkGvySQv2Rubf2fzt9P33rFzqvXb7va0cNT6jMyWFzkRrPf8rDGeBv0H79n3D0CFp+keeaK0+aduXXHlddctPnqq7du+WUjt3MNxnR6xntTyiFR1zp9CXHackHPhBClRvwDxEtRpVZKg+1DpTFnlkp1/bbNW07bfP32nddtxSVSVFOm0iCs+E71aQM4w3eTCO50+nu9qOcEbtSlpVCmJGE4p7r2Ni3NqMcmy+8mCPglhGuJqGe893jqIw6sxxrj0+oQrbR2JE/TZbc/ZCpc0HpmFbWeslNhn6yTh4eEpcXozfTpKOI0fkzWy0SZ4To4/bs/A5fV7SX430//bRJc8mwkGssEv/gOlzq/TLyjbFlPysgR8Rlf+A7xD7hSetnw9Ru2j/VkWTF6M0LkjvyYrA8WZYZrefp3fwYuq9tL8P8r/bdJcMnDenKw4BffoZ78OfGOsmU9KSjH4G0uhn/AldLLhq/fsH2sJwcXo7cuRO7Ij8l6uSgzXCvSv/szcFndXoL/Vvpvk+CSh/VkueAX36GefCP9PTGD35YLeq5Tss5R/zUTXbvsctTfYfVXFKt/jdVfWaz+663+IcXqH2n1VxWr/6ume4fCS7bzw+B9niXUUDs3/APES1E7P4zocfs4hX644KUpyjiFfrigc7igo3BNi4hrRkRcCyPiakbENa9Lcc2KiGt2RFxzIuKaGxHXsoi4Yup9t8rr4Ii4Yurq8oi4VkTEFVP2Mds4PyKubtXVlRFxHRIRF28vx/igkf47UdTLOzdEfMYnvkP8A8RLTnoNn1ywfTynWV2M3vQG1Ud6iNP4MVkfIcoM15Hp3/0ZuKxuL8EflQq0SXDJw3OaIwS/+A7nNIeleKcKfjm/k1cfsT7LCOuxPpbpL8RnfOI7xD/gSul/w6cfSi7WviOK0ZsW0r/Ij8n6SFFmuI5K/+7PwGV1ewn+FNLHI4En1scjBb/4DvXxpMZo3lG2rCcF5XhGqJ4Y/gFXSi8bvn7D9rGeHFmM3ukhckd+TNZHiTLDdXT6d38GLqvbS/Dnk54cBTyxnhwl+MV3qCfnpHgnZvDbcmEP24jhQNwol/B+aPwwVM8M/4Ar1e8NnxyVvVn7ji5Er/ED1g2khziNH5P1GlFmuOwIVX8GLqvbS/AvJD1DGqwbVob84jvUs0vJH6FsWU+KydGdGqonhn/AldHLET1R/abszdq3phi9U0LkjvyYrI8RZYbLjjD2Z+Cyur0Efy3pyTHAE/ujYwS/+A71ZAv5I+Q3eVou6GkoWeeo3yY7xGG4j4X3Ofrxf0L11PAPuPZ+LKKnxxK9rH6wth8neGmKMpQxliGd4wSdGleNq8ZV46px1bhqXHs3rqNrXPsErv1Bv2obqvux9hO1Pe6tuGr9qnV1f9TVOp6o5VW3sZb93oqr1tVaJ/ZHedX6Vffj/oirtqFaJ/ZH2dd+tbahWl41rk646rlV3cbaR9e6urfiqvWr5qvGVdvjWLaxxlX7nHocqttYt7H2ObW86n6s9WvvxVXnOuo21j6n9hM1rlrvaxuqZV/bUI2rm3W1jidqnahlX8t+LHHV41Atr9qGalydcHW7Tti9sHhn2FKio+7nOtZDB+sb3KCo10j/nSj4S+i0XNATfG+Z4R9w7W3OQa/hk7+Si7X9eMFLU5RxPx8v6Bwv6NS4yuNa06W46jbuG/LaH/iqce0b9lj7iRpXrau1vx9Lvup+rNtY61c9duytfNU6Ucur1q+6H2tctQ3VOrF/yr72q7UN1fKqcXXCVc+t6jbWPrrW1b0VV61fNV81rtoex7KNNa7a59TjUN3Guo21z6nlVfdjrV97L64611G3sfY5tZ+ocdV6X9tQLfvahmpc3ayrdTxR60Qt+1r2Y4mrHodqedU2VOPqhKvWiRpXjavGVeOqcdW4alz7Oi67twzvDDuW6OS9Hw3rG5y6myz5r+WCnosmijbkqP8Sq39CsfqvsvrPKVb/tXZ32XPhZSP913CfCO97wnEf1SB8Lq2P7xD/APGSk97wvW0nEj1un+mFtf0kwUtTlLGOnCTonCToKFwrIuJqRsQ1NyKuhRFxLYuIa35EXLMi4poZEVdMnVgQEdfxEXHNi4jrhIi4pkXEtTwirpi2vTIirpi+MKY9zo6IK2Y/roqIK6ZOxJR9TNuO2caYOjEjIq5u9RMx+dofYqZ6TBs/2ce0x+kRccVs43O6lK+Y8UTMNtpYq+bCyX8tF/Ts5Lmm4UDcJ8P7HPPetQ3C59L6+A7xD7j2dhaZZ59M9LLkam1fK3hpijKeZ68VdNYKOgrXioi4mhFxze3SNs6KiGt2RFzLI+KKKfuVEXHV/ZgP16qIuGLqxIKIuGZExBXTf82LiCum7GPqakzZd6v/iqmrMfVrZkRcMfsxpn7FtKGY+jUtIq75XdrGbo3lYrYxZjzRrf3YrbHccyLi6tY4J2aMWccT+4YNxfQTMfmKqV8nRMR1YkRcMWUfMwawsdbyQCdAvUb6b8kc2FCD8Bmf+A7xD7j2voyVA8P2mVysfWuL0WuF9APyY7L+FVFmuNalf/dn4LK6vQR/bf+z/zYFjSOIhpUhv/jO5NP3y/+2pHinCn7Z5pTcTxZ4m6I+ywjrsT4W7K+eUH00/AOulP43fPqh5KL0w+qqfmX5h/arDxfnha08eSaKejnk0Rsqf8M/4Er1d8MnF+Unre3rBC9NKkuejQDHZT3i3YQxxsX9lTwt532sO9pkYbwh3lPgfY5+6QvVA8M/4Nr7pYgenEL0smRqbT9V8NKksuThvjtV0DlV0NlbcKEOmWxQlqwXWC9HP00P1QvDP+BK6WHDJxdsH8cLpxWjN61B9ZEe4jR+TNanizLDdUb6d38GLqvbS/B3UbyANDhesDLkF99hvHAHxQvKhorqI9Y3uH2NzqCox/ZVUP+C/a7hH3Cl7Lnh03clF6XvVlfpKcs/VE/3Rlymf6d56Pj8iqKD9U+r6USns7YknbWBdNaVpLNO0BkU9dgPoZ6G+4XG34X6IcM/4Er5vYbPDpVcrH1nFKLX+GaD6iM9xGn8mKzPFGWG66z07/4MXFa3l+D/nMZ5pMHjvJUhv/gOx/k/onEe+eV5aV7/h/VZRliP9bFYf7lmqD4a/gFXRv9H9FHph5KLte/MYvSmhvQv8mOyPkuUGa6z07/7M3BZ3V6C/zvSx7OAJ56vnCX4xXeoj3+T4p2YwW/LBT3nK1nnqP//Jrp22eWof5TVP7tY/d1W/5xi9Q+x+ucWq/+U1T+vWP0zrP76YvU/ZfU3FKv/61b//GL1L7P6FxSr/yKrv7FY/ZVW/3nF6q+x+hcWq/8dq7+pWP2zrf5Fxep/xupfXKz+9Vb/kmL132P1Ly1W/zSrf1mx+j+x+s8vVv9Wq395sfo/sPovhPp51lSs/ouL1e8xfl+ELwVPht/GuhcAfCPjX8PFZUZrgHDl5L3h4x3543jpRUAP25iF60U5cU0UZUX65IUuu12If9DDi+LzEPhdts0LIuI6IyKuaRFxnRkR11kRcZ0dEdc5EXGdGxHX1Ii4zouIa31EXBu6FNf5EXFdEBHXxoi4nhcR14URcW2KiOvAiLguiojr4oi4LomI69KIuGKOHZdFxPX8iLguj4jriC7ElTymqyXzHeeUzFc8t2S+YkPJfMWmkvmGU0rmG84qmS84vWS+YL3F2s+Dl430X5ULyBH3n98gfM7p+ZPhHyBectIbnj9dSPS4fbzeuEnw0hRlbCObBJ1Ngo7CNTsirkURcc2PiGtZRFyzIuJaEBHX3Ii4ZkbE1YyIa16X4oqpq3Mi4oop+7Mj4oqpqzHtcXmXtjGmPZ4YEVdMG+pW2a+IiCumn4g51sb0EzFlH1Ne3apfMWOTmP0YU/b7g59YGRHXORFxnRcR17ldimt9RFwbIuKKKfvju5Sv8yPimhoRV0ydOCMirgsi4orZjzH5iqmr3eoLj4uIK6auxuzHmHx1q7xi6urGiLhi6mpM/7UqIq6Y8df0iLhi5hRixuQx5woxc48W31se+3yo10j/LZnDn9ogfMYnvkP8A8RLTnreHD62j/dGbypGb0pIPyA/JuuLRJnhsrXb/gxcVreX4H96wLP/NgkuedjHXST4xXe4N/qHB4zmHWXLelJQjotC9cTwD7hSetnw9Ru2j9d6LhK8NEUZx8Sh8la4pkXENSMiroURcTUj4prXpbhmRcQ1OyKuORFxzY2I6+KIuGLaUMx+XBQR1/yIuJZHxBXTtmPqV0wbiulX9wfZz4yIK6aPNl9o5xIxnllMdPLG3ljf4Eqed7mw5HmXS0qeV7mg5HmTMy2uej68bKT/qrMkOWK8X28QPud0TGn4B4iXnPSGY8rLiR63j2PKFwpemqKM9w+p8xAvFHQUrtkRcS2KiGt+RFzLIuKaFRHXgoi45kbEdXFEXNMi4oop+27V1eURcTUj4oqpXzF9zoyIuPYH2c/s0jbO61JcMW17TkRcMWV/dkRcMXW1W2OAmLjqcTsfrkURcdXjdj5c9bg9frKvx+3xs+1uHbdjyqtbdfXEiLhiyiumz4kp+xURccW0oUURcXWrj+7WeCJmG2PGvjH7Mabs9wc/sTIirqkRcW2KiCtmnvyiiLjWR8R1XERc50XEdXxEXGdExHVJRFz7g+zPiYjr3Ii4NkTEFVNel0bEFVNXY9pQt+p9t7Zxf/CFMfmqx459Y+y4LCKumLFcTHltjIjrgoi4Yo61MXUipry6dexYFRFXzDnf9Ii4Yq7pxMwDxMxPxNyfw2dscG9YI/235J3HUxqEz/jEd4h/gHjJSa/hkwu2z+RS8v7fwQbVR3rqjl+T9YtFmeF6Sfp3fwYuq9tL8OcOPPtvk+CSh33ciwW/+M7kk5yxOWNgNO8oW9aTgnJcFqonfB91Qb303ket7Ef1m9VtijLOP4XKW+GaFhHXjIi4FkbE1YyIa16X4poVEdfsiLjmRMQ1NyKuiyPimh8RV0x7XB4RV0z9iimvZRFxxdSvmDYU06/G1ImYfrVbbTumPca0oUURccW0x/1Bv2ZGxBUzBuAzXBgv8xmuvHdgY/2s741YefKU/B7NexqEz/jEd4h/wLW3uUjMruSv5GJtf4ngpSnKOJ/3EkHnJYKOwjU7Iq5FEXHNj4hrWURcsyLiWhAR19yIuC6OiGtaRFwxZd+turo8Iq5mRFwx9Sumz5kREdf+IPuZXdrGeV2KK6Ztz4mIK6bsz46IK6audmsMEBNXt47bMWUfMwaI6aNjxhPdqqv1uD1+frWOyfPhqmPy8dOvOi4cP/3q1rgwpry6VVdPjIgrprxi+pyYsl8REVdMG4o5dnSrj+7WMS1mG2PGvjH7Mabs9wc/sTIirqkRca2PiGtTRFzHRcQVc30oprw2RsR1fERcZ0TEdUlEXDF14ryIuGLKPqZtx7THmDZ0UURcMe1xf9CvcyLiOjcirg0RccWU16URccX0hTF9dLfqfbe2cX8Ya2PyVccm+8bYcVlEXDHjiZjyihmTXxARV8yxNqZOxJRXt44dqyLiiplTmB4RV8x1q5h5ppj5r5j7C/kMJu5tbaT/ThT1EjotF/QMNgif8YnvEP8A8ZKTXsMnF7VP2tr30mL0JjeoPtJDnMaPyXqzKDNcV6R/92fgsrq9BP+Hk579t0lwycM+brPgF9+ZfJIzmL87aTTvKFvWk5fC+xxyfDpUT16a/h5wpfSy4es3ZT/Wvs3F6O0JkTvyY/SuKEavx/pqi8BtvGxN/+7P4MXq9hL8N0gfrhR1mlSWPKyDWNYj3k0YJ1xbBC6Uo/VJYhtfTWWh9D/5r+WCnqPZLxgOxF1QFy4NtS3DP+BK6XqD/ZjRy/IxSo+sblOUcb6saN8nv5d3Ka5mRFwzI+K6OCKumPKaFRHX7Ii45kTENbdL2zijS/laGBFXTHuM2Y8LIuKKaUPzIuKK2Y8xdXVRRFwx9WtaRFwHRsQVU++71efEbOPKiLgOiYhrVURcMeUVMzaJqV/dGhfG1PtujeXmR8S1LCKu/SGW61a9jxmb1GNaPlzdGst1qy+MGcvF9IUx+zGmvLo1/jorIq5ujb+mR8QV07Zj2lBMecUch2LaULfKPqb/ipmX69bcUEz9ihn7dmuM2a1jx0sj4rKxY5BwW3nylFxvOrBB+IxPfIf4B1x7O3PQ8643vRTeFV1v4v3s3eIPY9pRt+bKY/qwmLjq9aZ8uGLm5mLaUMx+jLkeEDPW6dY8TEz9islXt67rdGuOImY/xtyrENPf892pGBstJjoqDrnCQwfrG9ygqNdI/50o+MsRL93cIHzGJ75D/AOuvc1F4jMlfyUXtXfN6jZFGe/D9+3fQjoK1+yIuBZFxDU/Iq5lEXHNiohrQURccyPiujgirmkRccWUfbfq6vKIuJoRccXUr5h8xezHmHzF9KsxdSJmP86MiCum7Od1Ka6YfmJORFwxZX92RFwxdbVb44mYuOoYYPzGjjoGGD++6hhg/PqxjgHGz090awwQU17dqqsnRsQVU17d6idWRMQV04a6dezo1ti3W/VrWURcMfsxpuz3Bz+xMiKuqRFxbYqIK2b+/qKIuNZHxHVcRFznRcR1fJfyFbMfY/J1RkRcMXUiZj+eExHXuRFxbYiIK6a8Lo2I65KIuLpVV2t7HL82dqt+1eNQrfeM67KIuGLGmDH7Mc/dQ51wXRARV8xxO6ZOxJRXt9rjqoi4Ys5Fp0fEFXPdKmZ+YllEXDH3M1muw/Yf4lx+LdGZKuhM9dDB+gY3UdRruaDnRNu/dxy8bBBe9Mc94bh7G4TPpfXxHeIfIF5y0hveu3gm0eP2mUyt7WcLXpqijHMyZws6Zws6TVG2sQJcEzP4bLmg52LV3znqv5zlaTiQN5yv5ujbeaG6ZPgHXHv/FdGlc4heVr9Y288VvDRFGffRuYLOuYKOwjU7Iq4zu5SvGRFxHRwRV8w2zo2Ia2ZEXPMi4poTEVdMeS2PiOvAiLgujoirGRFXTNnPiohrQZe2cWVEXIdExLUq/T1Wsaqis64knXWCzqCo10j/LRmLHNYgfMYnvkP8A669zbFiESWXvLEI5266ZZw+MSKumON0t/qYRRFxzY+Ia1lEXPvDWNGtcXNMvhZGxBUzrokZ68bUiekRccXUiWkRccWUV0z/1a3zjJj9GJOvbh07YvZjTNnHtO39ac7SbfLq1nE7pm1XMdbafAXnN43034miXhVzNcM/QLzkpNfwyQXbx3O1DYKXpii7AH5jGdLZIOgoXLMi4poXEdfCiLhmRMS1KCKuZkRc07qUrwURcc2NiGtlRFyHRMS1KiKumPKaHRFXTHtcHhFXTL2P6Qtj9uP0iLhi+pyYOjEzIq6Ysp/fpXxdHBFXTJ2IGZvEHLdj9mO3+q+Y+hXTHrvVR8fEFVO/5kTEZbK39Tucj11OdPLOCbH+uWNMR80vk/9aLui5gudvhgNx416vHHPJKxuEzzk9dzX8A66934rMXTcSvSw9sbZvErw0RRnv4d0k6GwSdBSu50TEdXFEXM2IuBZGxLW8S9u4ICKuuRFxxdSJ+RFxxdSJMyPi2h90YnZEXDMi4upW244p+5jymt6lbVwWEVfMfoyp93Mi4oqp9ysi4oqpEysj4oqpE3X8tW/46Jhj7fERce0PvnBVRFwxfc65EXGdGBFXTBuKKa+YY1q3xoXdOqZ169wqpuxj2lBMecX00fXYsW+MHTHnVjF94bSIuOqcwvjZUEzZx2zjgRFxdet8KKbsZ0XE1a35wphxTu0n8uGKGU/UfmL8ZN+tfsLiL74zI3laLuhp2PrpefiS8BZcO+5rED7nwtaOzytGz7t2jO0runYca63Kufa7V7oNl+19QNznEx0l540eOljf4AZFPdY/7IMc+nBiqP4Z/gFXSt8bPvkruVjbLxK8NEUZn5G+SNC5SNBRuOZHxDUrIq5lEXE1I+JaEBHX3Ii4lkfENaNL27iwS9s4MyKuiyPiOjEirpj6FdMeY+pXTF8Yk6/ZEXHF1Pv9QSdWRMQVU7/mdWkbY8p+ekRcMfV+WkRctZ/YN/xEzDYeGBFXzHiiW2W/MiKu2oby4Tq+S9u4P9hQTNnPiogr5hzZcptTRZv5TsDjBZ3jPXSw/vEeOutK0lkXSKeK9kwU9VrO+/TaD86LGm7Ei31VRU7Y8A8QLznpNXy6qHKi1vZLBC9NKksezr1eIuhcIujsLbiU7mLfc044r81j/Ys8dNaWpLM2kM66knTW7QftUT4g+a/lgp7XWf1LitU/3Gz0SnjJ/gm/hZDDX6wP9U+Gf4B4Keqf1LcesH3sn7YKXpqijL8zslXQ2SroKFwzIuJaHhFXMyKuuRFxrYiIa35EXPMi4oopr5htjMnXRRFxxdTVaRFxxbTtmLKf3aVtrP3XvuG/YrYxpuwXRsQVU+9PjIgrpm13qz3G9NHdOtbG7McFEXHtD+PQ/tDGmHzF9KvdOm5f0qV8xZTXcyLimhURV8zYpFvHtNoex6+N3Tpu7w/ztJg6cW5EXN2q9xdHxNWtuY5FEXFV4aNtTQDHS74D7zmCznM8dLD+czx01pakszaQzqaSdDZ1WXvWlaSzrm7PPtGey0vSuTyQTq0H3dOeiaJeywU9x9ja4BnwskF4C+7bmNogfM6F7ds4oxg9774NbB+vi24RvDRFGc8f1frrFkGnKco21rhqXDWuKLjGaq/MRFGv5bzPFPvBvsZwI16MxavYH2f4B1y7byviZ9VcQ/Wdtf0qwUuTypKHdeQqQecqQWdvwYU6ZLqLfc+6m3dOh/W3euisK0lnnaAzUdRruVHPhD+b+eKd/Q++6MrDV0w544fzZtz25l/5nXe96VdWHMZ6YrgR79XwPofO9obaiOEfcO19VsRGriZ6WTpibb9G8NIUZXyvwDWCzjWCjsK1NSKuNenvfU2v9ys7/fH2rz38R+/6xO98cMcjD90x/etT7px82KQ33nzzvy38/qIP/ODmB0va4qVW/5pi9Wda/WuL1Z9h9V9WrP50q//yYvVPt/rXFat/itV/RaH6jeG+fyW8bQXVHWn7tmFsuXhfZ/WvL1Z/sdV/VbH6v7D6NxSq3/iB1d9eqL77/6z+DnjZsh9rP91z+TUf++9tk8968+Ov+fr/OX/nlEWbv7T47Q9d/rvvWfzPL3mb1d1ZjPag1X91sfqTrf5ritVfaPVfCy9bQVXdBKt7I9CeEF5/otV/XbH6x1n91xerf7zVfwPUzyG7ltX/1WL1h9v/a4XqN75p9d+ITKX/Lvvrzx7wHx++pffj//sH217zk1W3/uFZ7/rCR056758cvvamTX9/x/c3WN2bCtF2U6z+rwvaHfge9nVvGn6TL4dl9d+cm7brtbpvUXW/88673th8/L27W4f+yU/6z7rluy/50Tl9J3z9T94w/8tv+vk//+A2q3uzqvuXl//8G082b33da9/1mdefsHLm5o/e+rUf/stX/uix5o/+36Ov+tqwrr41Bc/Z5llW/23F6vdZ/bcXq99v9X+jWP0DrP47itUfsPq/Waz+JKv/TnjZCqrqmlb3XaLuzKPc1xZ/89gbD51z3LYLXv2Wb1706K/NeuCQbzfnfX/nSa/+r7/dZnV/S9Tt8Bzb98v/3Z0umFoMOjEtTH4Pwe/kv4H076SexaAtgLG6vQT/s7Uj9Xan9AapjuFwbiROHYD3OfpifoPwOafnfYZ/wLW3vci8b4Docft43jdZ8NIUZSvhN5YhncmCjsK1KiKuuRFxXRwRVzMirtkRcS2IiGtWl7ZxTkRc3apf8yPimhYR1/KIuGLqV0x5LYuIK6Z+xbShGRFxxdSJmH7V9r8OinqN9F+LAwbhfY5xeUKD8Bmf+A7xDwg+i8QBg0QvSy7JO+vrnTuuve7aHTeu37Z5y2mbr9++87qtExC1Gx0NsVQQK75ruNGtx7IeejeJ4M6kv9eLek7g7gG6B0GZkoThtOgT23RQRj2UhRPvJgj4QcI1KOoZ7z2e+s6NaOwA0U+e8dLYgpGyV2OxfRy5HiR4aYoylGGWx1ARcl6+JrsR75Ra0ulbr9h59fptuBbzzNNLf5+RweI8glufwVpD4G3Qf/x+Hr3rcX5T9U2WQlQmedgZ42SnRXRqZ1w7473DGfeIeqwxU8V73jKZN5S5XNBTdF5cks6LBZ2Jol7Lfvz6gx/8xinv+pMj//7nk96xYfNbXrvmN7966fdeN++Rg//xZY8u+uiMZ1I300fzi/KfSPxav2PKR/VXL8GfBSmfA1J6Cb8WcqcWdurO615+4dYdN1y79dVbf+mrtzt6OpnF+fT3BaKeekLG8IKOJ9jRGf5YY7hSrayxMtzRsUKgVBArvmu44o7uAvq7iKPrFDWwo/M5J+yViYKuvZvgsh2RcmKca/Q5Mufqobm4xu7PQ3OIxoYOzVkamzU0c70+l63hvQS7LB0ySmr2qBuimcd6DHj2qceAvWUM6BH1WGN8Wh2ildaO5Gm67PZPdO3yaNmPb+047T075r7iuO9N/LN3HXXfwgO/+eNHnvz2T2/cesJ3v/2dTw39uKR1XVLSK1yceKITKAjGrAVP7obSv7PWPa1uL8E/cMhIvZMgCD44LU8t75LN1127ZfOOrWe88lU7t+7cuuX8bTu2bj/llVvOePXWV+7IHRKfRX+fLeqpxwSBjZ9CZZOgjA19EvHI71ipGqINjCtL4Iarl+BPT4V8wC//O/Oy0TiVIaHSr/e01TfDYznkneE1AukcXpLO4YKOL6gs6iwUz5y/wv5M+vh500feo2Fj/6Oj2ZD+20vw7wGDu4gMHGlnpSVxEMFBLSv31+9GZIIwEzL4ez7o5zmknxOozdhOxfMg0GC6ye81GTy8mEKrKdT2lgt7VGjF/gL5OZL4R/kqmbNeYX1OR2cFIPiv0eF3TEfxbHQGI9LBwauV/ja5YZ9w8DWF6PA7X553CrWnIXhI9O+66Zom2qPyW70E/3ywx20ee5xA7cc+GKSyrACK/ViITwzxCaFjkMG/JucYhH6Nx6AJAfz1unabSn4fAW3OwuXEO4PH8W8SwQ4S7GQPbJbfSn7bZvSq7cum6Mq+jiH+8toX1g+1r7fmtC/b+M72dTrY12+QfeFiPcsVZcOwZxLsNGh3KN4+qps8/OHOJuFFnXy+G91ew/vj6SP4353+HhS0yuoObsph3cFx71j4jWVGh98xHaxvcGwLrDvvn65pZmXoWXcM/psgy7umZ7dxGvEVQ872fga8Z7rTCXYmweImmSbxOIPqqn878dgUdGYS3lke/puEZ5qoN+h0W9W/ofxOF/wOOs2/+jeUDuK6nOhk6e6jpLuzoEzprh066SX4J0F3n/CsZrHuYlvXUBmOCejH5s0YzTNu9DI5vUDUNfg5BI84kofnFrZCljW3sLq9BP8ZMbewts0S9JK2fW66bhv2B24EnEO0Df7/QH98gfoD5WX9MdW1y4ZtYC7wwrBnZsjg94CPL0/PpsV2odqY4Pj96dlwZwo4xjFByMBwKL9g9aYKemy7s4nGLA+NmaKeosH+GGU2F+ibbszrUD5XtM2JdxME/OyM9jpBe04HvLMEHuXf51DZdFHGvgvbi/GQ2Znyiej3HvXYS5ZNKL2a7eGdN7rOFrzP8vCu5If+wxc32N8hY31D/G384eFL9rGm3/1OjyNWt5fg/9GTj5kJ7ewRfL0qA+d3AOd6wql05lh4x9vffP2E/Ex12XaueEdfwu98sYwTPKAvVDqbFcexPBQPMwQe5Tf5A9sqDg+1TYyn37+fzjF+HmmOcQTMT/9nL59jcM68G+YYkwlPPcf4JW8UrxedY/SC7s5KceadYxxNZZ3mGFZm8p0g6k0hfo3eyTNG8C0kfA2ghXqTPHzB0QzA70SbeF3B4BenP5Jx74J03Jsq6p9EeFkn+B3rBNd3nnaqMYzl9tyU74mu3RZzrIec4tN/wz2rIO4Q+1E2r+YPA6KsN4CXV/7H5jWb+1/3B2xXxgu/C4llThLwJiueN7dc0HMybt5wRFutmc2isj4oMx4SnV5F/M0uyF+I/BB/U5S9Fn7n6QuFa0pEXJML4pruRuso2qHy95y7UXnmpB9fQH4bbeW5xGtD8OrzQ1zfib+VH1LrNslzGfkhzLPn0K9jfPGJ4Z5ZEHeoH8qKCZCvAVEW4oeu+fkp13/pwq8e2HDt/rZHvGM/pHTyuQK+pJ0fqfwQ+xr0QzOpDP2Q8aD8UMEx5cgQ+SF+lUtiPxTaFwrXlIi4JhfEZX7It7aAfojju2miPeiHeD3rCojZXjRjNC60J/Z3Kn7jGFOVNQXOhParMuLP/vTf50EZrweqObqDNtg71HWsw+voBv8ykM3VxB/aNLYT+VP9hXtsrpuRDTfNA4f9wv2v1sF9sX9ov/BYsYPGClyrz+ED5B4ew5W0xeKfdKPiWVt3bLpm8w1bt2zaeuUNW3fwTsQG/Z21awDr8WM4+DTlAfQ371ibQn83BZ5ONNUOkxPgN9MN2WFyguB5POmcXJLOyYKO8kqNjH+NDr/z7SI8mdqDlsTXcebdvYH1p3jorCtJZ10gnb25PWoEsj4uGdUOhegR4h9w7W0ucqCiSfSy5GLtm1aMXqtB9ZEe4uRoRGU4DJcNmv0ZuHBkRvgPpD9Utu8IohGajU5Gs9tpJMVRvAVwd1MGT+0GxizvhdQOgz9qxUi9e2kmqHbDqZ3fp7jRvOTd5Y71Da6mE4/OqSXpnCroDIp6jYx/jQ6/YzqKZ9+4WfKIy/RQf2n4x/pIZ8nd59NCxi3kR0XavIpsvrE/AxdnkA3+i+QvkQb7SzWe4Dv0l5/1rDpk7apFvIMCr4qvWEaoHy3g53cC/DLqW5Zf/oflI/W+4vHLkwLaqE5pKD/BfT2lA64LCRfW98VVkwLo+OKqSYF0QtrjozOe7fHZAvbBRR6+ONaZ1gHXJsKF9XlX2gQPz3lPrWB93ymHZkk6zUA6Y9WeiSXphJ4OmVySzmRBZ1DUa2T8a3T4HdNRPHfyt98jf6tOpCDNDem/fCLlL8Hf/oD8bd72l5znBMclhn/AtcuvSFzSyT9wXDK9GL3huMQ3L0J+eLWGZZv8p3a3IS5csUf4X1BcgjQ4Lpkh+MV3GJf8F83jqtoVNVb22CI6WfbYP3PkPfZBqD0a/GfBHgdSnMoepxHPKJvJGe1Buj6fqGJyn600PfBK11VMUOHKZLBf4V0QBXd7DPsVtZqo7GYywKbZ9FO2bj/q6BNO/2Uq/cbrd2StUrJtzSS8rHOqD61tvKNngqCRPBsycLFfmk7v1Y6hTjx1gu1UrmKCGRntdC4sJlCrU4wr61So9U8vwS9MC0JPhaIOrfe01Xe9CI+Z3IZJGfV+1Wn+rM3Ik2qzwS/xtHlKhzbz/Av5m0L1MCZVJ/nx/UTXrgOIQ8n4NDea97z6hPXHakw7jehkjWmraUzrdBLVPiXDJ1EfgTHtKBrTVCxfdft5/jFRtAs/i8PzCNxlqXDyLkiDf27a9pLrHXJllnP/DcH/M1fNUJ+qtvv61ODvhD79lYA+9dmH75Jf5QsGPfAqb6ByvL74tFyc3/i7EB1F/APES059GI43VJyO7Ssabxjeb0KDkP9O8QbX88UbDJtlexwDNOl9p3hD8ZQFWybemJbRTufCxgc15+HrtXLqS8t4mQR8qLlj1g0aE1y7bSl4FWOo3Y7si3qdHodbUI7wmyCWuJB2l2P90zP4cy6sL7D+WI1VpxOdqm/5VvlxPMGMZUYny8c2RX3fet20knSmCTqhum6f4esUE22l8dOXd0O6HP+eA+PnNTR+Iu8heVQ17nL7UW98467KzWfFS53sVMXnzyNcefcYYX3frTeKd47LDP5tFJcVXFfdWOEel40hNo741Zqm8TUgykJ2V//zwEl/+K+fuOvPGlTfeOF3Ibmj5wn4knnWDWp3NeZUkwd1pElluLvaeFC7qwvGaxtC5If41ToOf+47tC+aomx9QVy2I1qtPY6XTwq9kcvg35Uz94Ljz3pPW0OudnWu3ec4l61H/0OP4TP5HyBoob4j7G3Q7osvG83roODVfESPh4YT7xouWzZMY4Koa5+XVfmcLN7U+jXimJjBZ4JjPNftzy9J53xBxzcm8b9Gh9/51nnPJzqIs5X+TmzyYYqbmlCm4qab0t+9BH88xE0forgJ6/NaNu+CR5+QPOwDrX7oLZ4G/xjYVadbPLGdPj0LvcXT4D8xBnkmblOva/etyXOO023KyhezDJSetDzwar0JdZl9tm/Pq7XtT+aM8PDZmfnaf24Gzi/NHsH52zlxnpeB809njuDc47GNs91oemz//I7tn+snz6CoZ78nunbdzaGHwRfmG/4B197mIvk0lR9QchkEGsxLU5Tx2KjonC3oNAhXJ74muxH7KfnhM0M5l+DWZ7DWEHgbTquc/T2X3qmmIe5nLg5JK5mao6t8KeFHXnrEO+4yrG9wis7iknQWCzo+XC8VuAy+T8AvFvARVcPKFwEMe2lmjfF2Ug3GnaUa9vQQzeQ3r/5x1zCPUwWOhqdNPeIdd3VD0FJ0rihJ5wpBh6OEH1OUgPRzeMu3mffrh5fs+Qtmqt+G8rJHeX7DPyjoGV/qQ+4hWY9VX/jV+09ces0FDapvvPA7Nkk1i7xCwJfMPr1FZT1wN2HyqMyYynrYO5X1KHgK4C0h8kP8KkvNWY+8GQR1n3ZeXJb16If6PlseK59RBR0fLpUJMXiTTb/TK0Xskwz+FzB7uoyyEkreTryb4Nr9UYpqWG6Ia20G74q24U8edarS4Cr0iX3YT8gnvkP8A669zUWiYWUfSi7qvLvV5Z3VybMR4LL8pW9FoNtxoW4Ounb9bWT8a3T4Hcs5xopgzFPafGdCGVwqS3Yc/MYyw8XvuF+w/hQq6xN01DjUT2Uot/VUpu4mUn6I/XdeP9QQ/HU6TbtslqapTtOiD2e//QLIZqyYld3GrJNJvYJ3lBfHroelNMyXToU6OXybzHAZrk6yW51DdslzEbXF4NeC7I7yyI7HfpUJn+ra5cEnmNWKYIPKnAtbRVKnrgZFPR77Cq6cBY99fEKkYAbUe0LEd9K/4Mplr9FTO7lUP0xzWqZZJ0Cc076O/Rn6uiaV4bg2lcrU/Uc+f6ZWIad6+Bsrv6noXF6SzuWCji9ODNF1RUfx3MmXbSRfplZTse7O9Ddnpw8DX7aJfBnW5/7j2BTHmuTJmqtlrc5MyuDvspQntTqj2rzTwzPScK7dbnjsMvgX0dhVcD4txy4+PahuKShJt/DnawveQ+X9fK3aDZbAdc/nawcI7mz6e72o5wRuzHiqs+6+fQlqrV7NyicKurw2r7586dvjYLz3eOojjqz9Ij0Z9ZK/bxZ1Yt7TEXNGE7JHrGA0OzPUMg1/rHuQphI9bh+3vSl4UXuc+FO7Rfc4Jb97I+FKno01rhpXjavGNQ64fHvKeBaWPHxWMmsvEZYhf76Fa6xvcIOiHo9vBcebqaHjG+9z7i1Gb3h8UxlGJZeS4/cU33iKOHlvny+jo+6tQlxWl++t+nA6S4mp18nM6qFZo3mval+ib8NGlXqPvLfS30m7Pz5L08za/8gzbIM/EGbYn5w1mmc1w86SAeqQ4eA24TkPK8tjr8ks+wX0tUHki1cZld7jrPum9HfTteuxTxc425LVR3uoj9R+zYbgh/fh9UMffZmyIFg/ZB+Yosc61J8Bz3tUDf73IQtymedrLJMy6GVlha7NoPfHQG896IO10xHtkno3U+kd2jPrncrkKfv3jQeopz5dZNoNgcu3L9nq9zvdB4avl+C/Jvo8VM+5Xw3+64H9GsmfyH5FWYXsWkB4lpvSA7XDQmVaWY97BC7sa+7XTrZs+Ni2/tHTr1Yf+xX55H41+O8E9ivGPYYH+W25oEf2K8qK+0CN1wgfsimSeU0etTJyAJWxT8Tfyn+jHoT0uZIv9/mPRZ9z7K/8Quh+5iS/Zve2pBnUTTu23bA1TaE6enwpz4bLvoZvhqjvqG6D3vH1Pcp9+jZ5DQ/RTqcc2X0a/M+EyH3uN3lCtsRjd1eRhLd3sbbEd3JrnOrzmZkvJB8HVU2eszPYaIj6jnA1xLvkUdvUES9HgT7vpkTFJ5UY3vDxHorJaZSqRg5fhOMED74MMPKj2j+Vynwn7wwWRzRUIx7RDH4GtNU3ohntKkY0lBGPaGoGjfAsb98tfCiTJsGj7NWINpXodDJDc69qZoVRJc+slL74IjOffJR+qdPdam+MbxZscFXMgrE9rAsxblhUN9Y0CV7pie8W5U5Rl08XcOb48Yy9BojXNwNSN27gEH5T+ptveThS+ADDOdihbSEzQHVq2ndDnbo9HDMVhtsRXEl9nKL0EdsTkpVRq3uhtupbpeO9/zjD4qwn0sW9GxvHeA8dj9/4fTAVIhpezrieAVmjy2aPxhl6i6rBq/1jaPe8vxb9xYwAXL5YQH1Pb4aHdta355k284nfKzdaVhZpHO9TtoL+mW3F54uTJ0RWqp+aBI+yybufj28VCd3P14Q2s36qzIny4cp2cd/sarJdFUP6fLBv3zfWx33HyMNLYYzg20A67Y2+KQPnlZ5xR7WhIdoQ4ouVbaHv88XZ7BfR97FfVP5a+RH2i+pbjwjP++UM/pWp/GzKXPBWZrlfjn0d3h6oYi/ew23wbwHf/arZGmdfTpw7xnbO0lu1r+s0JplMmq69b7L2iyIutZeY7azf6fmS4eM58hvFHFn5W/ap6G/Zp04WdJW/xW993p/ywfFa8rsFcG8l3VPzZfQ5rHsG/xDo82+kv2P6Db4lCv0Az+t8X71LHvbzWJ+/pBD/ttfwMwmxb3tV9qdyBiX95vCZBBWrqH7AMwnqHALiwtVzw2swVfo1Xy6mk1z5fBe2ke0ZcbMfCInJFL2smOz+imKyZRSToX2x/aONs/2rL1SoOQDHDTOAFxXz4JiN8B8FH/ZFko3SZV+ORX3JQX2ffKpr1/VZAbh8ub7ZAn6WhzbyhXWZdpZNKls02VQxn8K4gG3RN5dMnhBZqX5qEjzKJq/t8jzM95UW1G38QswXM8ZtbAeO22y7UwSvGA+YbmCfvtCNpqmWdvAdj7NY3+AUncUl6SwWdHy4XihwGbzKYVZ8PY6xuBRgkvctD2uMt0H/8XvGraaS+KhuamTw7VxYNzWIvsLVB78vBBi+FBrdy4sIV97Nelifl8KMl2/TFLOge7vVd7zfcBe8huFWlK89KszMOlqIfKkrIUKuwvnsB5835atfOmH4KpfQI5AGr1L9LxLwJa/Cebcawvi6G3XkPO9VOAWv8Hh3iPwQv0qHnwm/8/RFU5RdWBCXXYWD8uKNt1X7GLNlc9ffFSm8sebFhuMfetKJnZbTeOM+8u7b3MztyusvG4F0XlySzosFHd/hgRD/p+gonjsdh/4FhWN9UKZSv69Of/Omy8/CxaGN9LfaAsH9x+MPjpHJw/bKm0IZZlIGf/0pT+o4tGrzqz08YwrNuXa/wOldg5+c8lDSp8r0Ll8LV8F1TME7scbrOqZ8x6F5AoZSQaz4ruFGtx7Leugdb7g6k/4uchxafSakX+D0XUmvRt88l4whXrUpgS9X9I32iEMt6hkOVS/5e4eoE/OiibE6Wl3yuFjwZz/5uFjBqNN7XAzbx21XG5JUMpujF98xMaTjS4zHwDU5Eq7k2VjjqnHVuLoOl5qBDlIZjge2sKhmL5wVyDvzwvoGNyjq8ThS8MKbKaHjCF9401OMnvfCGyWXktmSwQbVR3qIky8Xyvq0LupQfwYu3oBj8BelswHekJo8rNehG4CSGOqCOaN5j3HRpUr4G/xY6z3y3kp/J+1+4RxNM+uoH89kDf4jMJN9yZzRPKuZbJYM+EJqtpHkqWKDq+/4p9J7pG1HsX1HrJQuhB4Nfxn1UafjmHw03OBvgz56BWUbsD4fquh07HgnwVs/hR47NvgbINvgO3bcn0FPZV+SZ0MGvVcDvTE4djxd6R3ac8gxRmX/vvFAnaFSusjHGH1HVxuCjm9DvjrGyLw7136M8U1CHziWYN3I4k/JLfIxxokZbEwT9R3VbdC7aRm4DE/yN6YfQo4xqpPK7CJ+Q4jc12XJUx9j3OuOMZ6ZwUZD1HeEqyHeJU+nY4xssT4RK1GZtwo9AG/wdwqVDvGYTvCgIgGObLPaz1sa1TZPpqMO5icPj2gGvztwRDPaVYxoKCN2OaGZL4PvtJ2dTc13jEjNTEPNMPQYI0dqSl98xxg7HRtj/cI+9R0b80XV+8qxMZONOjbGeqKO24W6fp8uYCTKM6tOl41krbGjD0AZ3pT+5vWyLwgfYDgndmhbiL9TqxbqOAn7O7UHQOmjwZXUx0Glj9j+kFme77NNnWyV/Y+6cEqFCBxGdtIb3zZdXKP9BW31Qzqse3k/m3Sh4F/RWVySzmJBx4frQoHL198Vb/UzFhcCTPK+5WGN8TboP37PuJWZ46O6qTeDb+fCukmps6LTKEmnEUjn+SXpPF/Q4a08P46zTeHNIQueBU+ivBnlZY+aTeHJWaZnfA2IspAtgt9vXvy71/344Q83qL7xwu9CTok9X8CbrHB3dw5Z3aSGJqOttgjyaWMcXowHtUWw4Kmbm0Lkh/jVaRSeBob2RVOUrS+Iy7YI+m5HqNpn8BbB/4IQircIVs2LClXY/gsu5AQvVLGNF/RlDd9Qq+RSckPH8EKVb+EH+eHbVli2qLP9GbisLp9KHkhTITwdSZ4y9+P2zh3NuxonQvoZ8aqFC9bHrK2QU+eObov6SgrWzfoyzMHLR+pNz3EbFutm8q/vyzBWP/TLMAY/J+VJbYWcJNqMiyITM3joFXST32syeFiY8lDSTuRWSE4fID88BqsNdepLK2phcpKHzktK0nmJoBNzM1rTw3PV9thKf6tT1pvhN5YZHX7HdLD+FA+d3pJ0egUd5VNxyss+2mCSp2Q83BvSL6N8OvFSdDxUsZHy93wCEuuqWxA4laViZXU6UuEaiIiLV7OU3mwWuPLKK+JU3Vi8hOAuymCtR+Bt0H/8/hJ6lzVVN9zKJEOyUj6TxPpjbfqKztqSdNYG0llXks66QDobStLZEEjnvJJ0zgukU3SPVVPU35/0YKzas6kknU1d1p51Jems20/bc2VJOlcG0hkrv1PbT7H2rCtJZ13dnr2uPWr1vZH+a1OmglOY4BSi4Y/1CUmVIlNyKTklHE4hdkqrGz9qioayTf6z9H+/86foewn+Nkoh4nSL47DQ6Vkytb6F0mvIL+t9aGpS6b3BKTrrStJZF0hnX2vPGSXpnBFIZ6zktqUknS1d1p51JemsC6RzVUk6VwXSqf1B97Sn0zmRPXM1zaxzIpZm5eXP780bqfdlGiswj8O77/Le8IH1fTeJ8JKBun1H7UDLuoEC+fPdgKNuAOoRdFS6Wi03lDxnGLwZns8ZTipGz3vOUC3D8BII1lVLGiGX9qpzqHn5ipgWNhYPJbj1Gaw1BN4G/cfvD6V3PQIWcY+V6is655Skc04gnbFqz6SSdCYJOj5c5whctXqPwq26aUIG386FdRPWH2u1C7lrqKDHDv4AtuGPdddQpxt2eHZe5qR9lmkgTl78HxRlhsuyCP0ZuHCzBsL/J83OceGfZ+e+k/PJg7PzH80dDYf84qapTtHgzwI25mBdjgaHaUE0+Iu5I7/trFfCnzrTFOLOJgsZKBvl66DVKeqidHoFHcaVJbNt6W8+czaQykydwZgMfCjfxyvMKiPoO6PW6cwUyxJtY2oAbXX1uME3c/LqW9hH+lMFf9Nz8nrhGPM6WfBa4WaW4NnBeG1myXfPHGosSwWx4ju2JCzroXd8IvYs+rvIPXMqB9sUOE1DVA7Yp1lOvJsg4KcTruminvHe46mPOLAea4yql/z9FlHHZwEhGpw8WdujYuCaKXCZZeKl+jksZXaoZRr+AeKlqGX6PkqQPNx232X3WMZbw9Sl+rMFHYVrWkRcg5FwJc/GGleNq8ZV49rLcVkZjtkzqQzHT76XT51oblAZ8jfo4Q/rD3ro9Jeko06hV709n7NIOHaz3NRHa2Z66GD9mdQePFrSSn8ns9Ut8zTNrI8i70x/8x6E/wuz/6vnZbcR5WztYp5LnuiXH8rGGIdP9Hf6MNJN6W8VS0yiMuxrw9GpD15FfaBudfF9mNrgvwJ9sIP6QH1oyGc3ih7rSH8GPGfCDP5GyHZc5jku2cygh/JAOb81g96viuyK0jujXVLvZiu9Q3tlvQuNu0P11Nqm9JQzNuoIKuoBZ2w63cPJR2QN/u2iz0P1nPvV4H8zsF8j+ZPZeW8vUpk1NQ759AD7i7/egn2elYlEXNjXIf06UeDnfr3D068qg4x8cr8a/J2B/RrpJqLZeW9+Uf3qu/lFjd/Yr7zmzfN4xKV8tC/DqvrVt1ph8A96+lVluX1+2OAf6QI/jLIK6Ve1EhDar+yHsV/5/kwc69iWx8pHf0L0Ocf87Bey+FNyi3x/5vQMNmaJ+o7qNujdrAxchid5h2nVrAXurFP/LHKD/6wQuTJTtZBXwY0PwYsC43XjA29VV2amFq+4nzrRiaiqyXNWBhsNUd8RroZ4h2VKVbGOqapa/8UR+me0cw9ViGcKyvOpyN/gLQLNii7w880I/8eeUcgXBScPe+s5Ah4jY75EBtswh8qwXjODDo6O6Pl5dDT4rwaOjka7itERZcSj41wo6xHwLO95An4uwHBWaR6UsUmjjOcQnU6ug/Vf6amafatofIKnvZ1mZaxf6rPKU0U9X6bE4KrIlGB7WBd8tpQ8LBuf7qBsmq6znqBdziY6Pr+UPD5dwOzCFsqaYKgRss7vuwQL6xucotNbko66bIxxhe5TMfifevapqNVs3/4I36e4kR8lG85qxljRVZFuyGpvUTpo/3x50qyIdNCXTCM6syPSQVvkL7vMiUgH/cYA0ZkbkQ76IN4fOC8iHTXumT3MhzLEYXwsEHzYFGAhvM8xFgRfcmP4B4iXnPSGpwALiR63j21xkeClKcpeC7+xDOksEnQUrv6IuKxvp7r2vuZTR/MFnfkeOmsD6awrSWedoDMo6pW1ESUbo7MwIh20mXVEZ1FEOqgHLaJzYEQ6BwLMGqLTFDwk8cDq+SPvk/8OgjLe/ZU8tgLcS/C/d/BIvaNSnKaD6CuQR6yP8csC0Q6md1xKw/wf3v2cwx/Jy+4MVyfZnUCyWwBlIbIz+A+B7E4k2WG72LaHoGwhlS2BskVUthTKEAeWOWgDvmOdw/oGNyjq8Xi1DN7n6K++ENtA/AOuvc1FxqtlRA/bnjx8huHgYvR6jd5yQU/1wzSnZYr0DZfZmPKzi6kMfeNSKkN/toTK0L6Pht+IM6tNNl9TYxfrN/I3g8owpp9JZRiHz6IyjJ15jo5t5vjW2txHeJLHdtr0EuwL5o/UuTT9rfwN+/EFAreVHSTKEvw3HDi6LehTUI5Yljw94p1vDDU4RWdDSTobBB3G1eva55bJw37X4F9PY8gQ4M1hs1eb/JfAS/Z3Bf3P1aH+Lsv3Il/KF4Zcyt77lQee/uzLfrwx7xjh850bBHxJ33mFypkZbVz5dK5dZsmDeS/jQV3KXnDsuiJEfoi/KeBPA7g8faFwXRQJF/vcsrhmFcRll8Vj7DNEuFSeF8clHoNmePha3AHXhYQL67MPG+qAi3deLhZt5LiE4foEbqY96Nrbxr6soJ8MzjUY/gHRhiKxm5KtGmvYj2PdpihjnV8i6CwRdBSuWRFxcb40Rh5T6fB5xLOyrVkenrE+nyiZKejwnDn53Up/J7p9x3zND+o9zrc5LjD498F87E6ajyFtX2zJOZ28u3rXBtLZVJLOJkGn6vw353SGItJB37SJ6CyJSAftrUV0lkakg+MizwVmCR4SnX2M7GAZlCm7NDn1EvwJYAcf89gB8oj1MdZSuSmm9ymKxwvGgTKnY7g6ye4pkh3O7ZTs2IcY/EKQ3edy+BCMLYeoDOWxhMqWQxniwDIHbcB3rHNY3+AGRT2Tr/XXCnhfRU7H8A+49jYXiQtWED1se/LwvGRlMXrDOZ1DBD3VD5jTQZkifcPFOR30swdS2RCULacy9GcHUxnaN+d0DuzQJo6nFX++XPh4xZwHFqPnjTmxfUVjzjPhN5YhnbxxYgxcnJ8bj1hoXUk66wSdfSUWWkd09pdY6Ps5YyEezw3+88tG6v1wDGKhn3ZBLPSfkWKhe0F2PyPZIW22bZTTEJVhjMKxEMqK1xutzEEb8J1vTZXlhvV4vCoYmwTHQoZ/wJXSj+HxSsWIarwqGesNx0IrBT3VDxgLoUxVXOSLhTi/MARlHO+gP8vKxSa/ORaa1aFNvliI94Bh7iL5G/dX8JqSwb4d7GxGulCk9pjZl4VUPmU+0J29YDS/KBfOX+aNHbD+EuInxtik1ro5X5U3R431eU10iaDDYzr719YCzQ/61yHgh/2rwb8a+n0p9RnSZj+JPHOMlrc/1wbS2VSSziZBp+qYhmO0qmIazlcti0gHx8sW0Tk4Ih0chzhGWyx4eGYfDdnBcihT+XrOVxn8XLCDEz12gDxifYzRhkQ7mN66lEbJMVHGaIark+xOJdkNQZmSHfsQg//vpSP1zsjhQ3BMXkplKI9lVIa5DMSBZQ7agO9Y57C+wQ2KeiZf669D4H0VMZrhH3DtbS4So4Xmj6x9q4rRG47RDhX0VD9gjIYyRfqGi2M0X94DfeNKKkN/toLK0L45RlvSoU0coyndr3C/R3C+yvAPuHY5FtEtFQupcZjHJqyr+obzVWoviMq5KlxDEXH59pNxLKT2rS300FkbSGddSTrrBJ2q90mPV76qqpirRXSqirlCY6HX0nh+MJSFjOcGfxeM56/3zON4rehgwOcE/JoMejdRLFQw/yFjIV6DypLdm0h2S6AsRHYG/2sgu5s9smPbxnFniMpC4ySOTdUaFb7zxd8cQ2I9Hq8KxibBsZDhH3DtbS4yXoXmj0rGesOx0CpBT/UDxkJqvQ5xcSyEfnYJlQ1BGcc76M94XQ/tm2Mhw5nVJo6F1J4xxtUL71TOiecd96T2ldja3ZSzUvuUE7hlC0fD1XHY6Lqq798Mv7EM6YTGTosi4qrjsBE6/C5PHFZVfLSO6OxrOakhwUPiY347ICc1BDQ5ljD4xRBL7PHEEiE5KV8cZvC/O4Y5qSzZfSUgDvPJzuAngOz+MEccVuekRvjEd4i/zkll56R8cVg35KQUf4wrNA4z+G+R3ygYN0m/YbjqeC0sXkue0wCOy/LGWAdGxFXHayN0+F0dr8WhUyReaywceY9jUN547YElI/V6U5xVxmsDKY3xjNcmk+yKxmtvBdlNJdkhbd9dBRyvqX3tKpbjcTBv3gzr7295MzVe7a15syEqQ9/IMZk65xASrw11aFNI3iw0x8U0s+K6S6nc4A9ZOIJzBeXN1Nn9BO7xOr+2z+TX+E4GxM3xWt77rdYKnhWddSXprBN0qr6nieO1xRHpoM2vIzr72jrnkOAh8TFnk39T65xDQDNrnXMFxBzneeK1WOucGyleq3KdM0t2F0aK1yaB7C72yI5tG8dG9i/1OuezT73OmR2v+e6PQt8Ya51zcYc2cbyG/PnuGrJ3vjjM4F9BfqNgHCP9Bu9LU/fJlrwnLzheM/wDxEtR/Vd9p+6UUOco+U4zjPNOAzgu88WFar54YERcvjiqjtdG0/HFa1Xdq7mO6FQVF7aIzpKIdFSc0ynmeCfFHEuhLCTmMPiPDI3Uu8WTI+J8zlLA5wT8mgx6t5HfxXGirN/Fu8XY17XS38/cS5Mxlw89R2nwvwWyu5Nkh7TZtlFOB1IZjqkcy8Xce4v1WW5qLlLy3GtwvGb4B1wp/Rger9T5UrQLjtcKzh+G47XQOywwXlN3gyIuX7zG5yjRN/JZSfRnnDtB++Z4bVGHNnG8pnRf5bjwTCXnuNS4NFG0MUcfTQ3VQcM/4NrlXUQH1Z0carxO7u03XUg/e3TW1h0bd15x3bVXnrf1xu2nvHLLxs037Lh283WnbNlyw9bt25FpJITfYMJyfBjGfs8Q7xHH4g6NYWXAzgq5ZA9x8YV96pI9w7WkAy6+sE8Nbvx3n2vn0w77TgjAg4aWxdcm4kstvvicPCrn2wgX1s9KuGThejvhwvq8uIjJIuaT5eXDk+VAka/fIL6yDqEn/63sgOtXCVfW5T7Jf4d0wPUOwqUm4fx3n2vnk+Xlw5P8t6oDX79JfGVtvkn+O7QDrlcTLrV5x3Ad1gHXTsKF9bEu/t3n2vlkefnwJP8d3oGvm4ivw6DscCrDelOITt5JGtYfq0naFKJzeEQ6hwNMC+olf6+GsiHA4TvEZIP/EfC+ioSJ4R8gXnLSGx78jyB63D5OmBwpeGmKMk5yHCnoHCnoKFyLI+JaTe3JvAiIJmFFL7N5zdBIvR/SJAxldDi1UcUx6jLSBrWrX8Ajvl6C/2nK0wGu/bOuh4v6CjeOpyEXAqN9VWEjhj/WhcCriR63j23kCMFLU5Rx0kLZ4hGCjsK1NCIuvmgvy0b6Fo2mWdRGXjo0Um9iirObbGRKylMZG8EYKsRGylweifiMH3yH+GPZiIplfTayWvDSFGW8sV7Z4mpBR+FaERFXqI0simQj5wyN1FtcoY2YvENtxOCXRbARjJtDbKRMMgzxGT/4DvHHshF1aZrPRlYIXpqiDOdMWIZ0fIvjiGtVRFyhNrImko0cPTRS77gutJETc9qI4r2KuZfKX50Bv7Nk5PsAzxmiPWqOdwa1J0tHzlik+VE6kvy2+TsvrLdAR8726Eg3LKxuKUlni6Czr2yE20J0lkekg+NKi+isiEgHfWXoBbUvIjtYCWXKDm5Kf/cS/NOtkXov9dhBVs4SF1Z9F9Qa/NaURsmNR3Jh1XB1kt3VkcaZB1sj9V6Ww4dgTM8+HuWxnMpwTOa8r8qv4jvWOaxvcIOinsnX+gvzllUsrBr+Adfe5iKxVujBT2vf4cXoDS+sqrmE6gdcWEWZIn3D5VtY5cv60TeuojL0Z4dQGdp3yGX92CbfRrg8l/WP9Sazspf1d4oXOY5fLnhRffNO+I1lSMf3IQ7EtSgiLltjqDeZtb/rxkMB+0sstCtHLJQ8PJ4b/BmtkXq7xyAWeqgLYqFHIsVCK1sj9T5cx0K+Z6+JhQ4rRm84FlJr2HliIbWmvS/EQj2CP4RD21P5JCfeNTz0mMYEUfddxDeWXUU08uaArhL8VpjX7Qm1r70lr8tr6GVysSExT8kNjMHx+FhsYLwK3kXaRNvj64fFHnoF1/ImGD3f3i6kl/jTftfeh50+hII0sL+ybL7ofsrlHXD59lPyOuCKDrh4P2XWxmUs+0GKIPHDf7doNIztBfwHgPlW+pttCuXwzF4SguN9hckT40M5iM85bXv8UcSCG+a9H0VUBw4T3TzA+XUE+wj3RiyF38tEW0J0FnkK0dm8fao2lSdw/+6BWyLgFK3kb/VhcY7FfwLrS9dfNrqNWH8IfmNZ8vSId77DGQan6KwtSWdtIJ11JemsE3QGRb1Gxr9Gh98xHSUb3yHMonRQx9YRnaoOurWITlW5Ds4NLBI8JDYzeODIe7Y133jBh97/YPFIvWaKU+3Rz/rAVegBNIOfldIYi4v1smQ3h2Q3BGUhsjP4j4Ls5ntkx7aNvn8WlaE8+HAajg2IA8sctMF3AE1dBrG/HEBTh4/3pgNoaqxTvpEPoKkPcyofFPIhP98BNDWWJ4erDkp/jxyuOm/rjZdsvu7aLZt3XLvtlRdufdXOrdt39AJmpo6tcE57YpMI4uGnQX9PoLIZVL5RwOHjG01LXnEQHPka/gHX3gtFLEed6FJRBl/Vg3XVVRW/Bb+xDOksFXQUroURcZne1Fd5tr9jOt3wCZwlEemgbbaIztKIdFDfQiO9DRSt4LHdkGjF4DdAtLKRohUcNZBHxI2R3izRjl6Cv5givYJZNxnp8eo7+rpW+jtp56UBskOfliW7I0F2l5PskDbbNsppiMrUtT9qxo44sMw5/+q8igjGYNdCcKQ3FrsW1NU4Ja++GI70VGSp+gEjPZSpOonru8pzBpUNQRmvEKE/W0RlaN8hkR62KSTSM91qCjpWtgDKZlLZQaLNid3dQHaHn4veSO2wMmwHvmMb2Sj4UXRmp797qY2/Sb6u4DVPJw8SHcOBuBcWxB1ql1lxA/I1IMp6A3j5j5nrDv/33T+8q0H1jRd+NwHwoy4j/EYBX3LMee4g0HBE28pwPFxIZX1QZjwkWctVxF/BlaHnhshP2T6WnQm/8/SFwjWzIK7pbrReoe2Y/aEfmZP+HnTtNs12UtAGg+dbhn/AtcugyPilfK/yWewjsG5TlL0ZfrNv6RHvJnhwNSPisjFA9TPPt5qCTtNDZ63gWdFZV5LOOkFnUNRrZPxrdPgd01GyGevM+uyIdFAPWkRnTkQ6cwCG51tZc4aP0JwBryEPmTMY/F8cNFLvMU/sgjxifRxfZop2ML1PUAxScGyR8y3eXZElu0+S7GZCWYjsDP5JkN1THtmxbavrrdR8azaVYZzAOaW88y2sv7/Nt9QYb+0bKkZveL6l8pF55ltIn1evlJ+dSWVqHq38GcdcaN8835rZoU0831L81bFQWCyUPKcBHJfljV/mR8Tli1HqWGg0nToWcoXoFImF/jVSLHQxjOffH4NY6EddEAv9JFIsdALI7j89uWe2bZQTx0Iqp6PiJJ7X5z2VhPXHYIducCw0Fjt01XgV40Rg8t+QoJe1Y1bJVMVFvliIc89qN6DyZwupzBcLzejQJl8sxOvumDdm2OnQ3lFtAzs79qBsWnOJD/QR86gs1D4RB8oXfQXCb6M2GPyclO8k17j9Mo1zgtM6av5H5T6tHROBrpXl0N+nE75ecNkIHdSX5MG8KeqLc/6YyuDnCnjUOY4N50IZx3NKHzG+MH1U8jIeq5AX8hAiL7UGFiovtnuU1wLCpeJflKFPXsZjFfJCHkLkpfa4hMrLZKDkdRDh6jTHWU/whrvfaZ/Au6YN/mjwCXwrj8/HTxe40Tc2CAe2oyHaMUhlWDfBuycV1ljleTjWVDfuoP/GfRAI/yswblxIshlyI0/I+pbKcQwBDO8kxXF8SQCumR7aSwX8Eg9t5Iv3yPDeHBVvKD9gsinpB/qUH8B8FfsB1U/qxJNPVqqf1Jo7740LzTnxzQqhOSc8acH6qfJPWT6b7QHnMzzXUfMEn+75ruhXuqdyrMr+2W+ofTXKlthvYN+y3yi6E/6laV9UuROe9bvXaf3O2uH+avBtV2b4tr6cOK+C8Wg92Khzer29pC/oVb5gCADYF/h8cPLk9Ztst9g3vNag1s1RphwTmIz6BTzi4715rwqMCYaI99AcuG/eZ/aQyP22lI9OeyBfS7qnbnPw7YE0+PeBPr+e5ngx/MYcKkM/wKedUad8eqZ27xucb89tyX3nwbkU3nc+VIyed9+5WueJ8cnl5D91ckb1A+ZSOp3eNF811n4N5RTi19Rak9pDyPaMPoL9gNrzqtZimB76CIzFbyPbVz4yNGbB/PW/Ui4V7YvtH22c7R/1neMGlCHHDUuBFxXzGF7+hNs94MM+RrJRuuyLY9UeVtyXyrfaoK4fHIDrQA9tdVr+YA9t5ItvgOIT58omlS2abKqYb2BcwLao+gnhQ2Sl+qlJ8CibvLa7lMpwfB+iMtRtPIn6sYxxG9uhcrydTqe/lsbuvSVX8Dmw3T+tcwVttJlPq1fnCtptt+pcwZ9WlCv4ZJ0ryJ0r+Nu9IFfw7+DbvhkpV/CtOlcwXDZeuYLvdUmuYFrKbKdcwY8j5Qpmwpm//6hzBb6nzhUQvTpXMD65AvMRPh9ZJFfwkb00V7AAfNjhJJs6V5Btk3WuIJ/txsgVsH7GyhX8mMZu5JvP6yubUjbP5/XVp925/7JyBYa3l+CPB9s9l2Sj7Eft/wu1H54zKfvx4fLtMVI3Ii330Ea++AZ2tmV1hr7CcVTaLton267PZyZPiKxUPzUJHmWjziHxvrchKONbonAcYptH3cZxl/VT7W0KHXdxrxHf33FgB7wsT9+XLNS4oXIovjNiyv7Zb6hb25Sus9+w/kRdRXjOFRj8ZSkzJW9clbkC/kIA3luh9JvnVgb/SvBtL8jwbX05cb44xdMpV2D9WEVMjfbOvsDng5Mnr99ku8W+4TtjQm9wYzvrdzqGyLqh9VroA84VoD/iOGMIyjgHskTQVf4IcwXvpFyBuskzgbuedE/l9dHnsO4Z/C2gz9vT3zH9xlIqQz/AN3OqMUfpWVPUxzGU65kfKHlTYnCugG+xL3jzZO5b7GPcVJ38t1LQU/2AuYJON5n7cgVV+jXfekgnufLcHdvI9ow+gv3AEJSx/1jioafmd+gjfD4ydL6BMcsGyhWoHKuycbZ/1HeOG1CGHDesAF5UzINjNsLfAT7sQyQbpcu+OFbd6I+38fM6jO9rvwqXL0+hvpJziIe2+koO8+Jctk0qWzTZVDHfwLiAbVH1k/qChk9Wqp+aBI+yyWu7K6gMx3e2a9Tt5dDmD2WM29gOla9U8QCO+dfT2I18V3GLc9bYnZXnM7wc+34CbPf3SDbKP6O/zBt38pxJzdd9uIY8tH36q2gjX1iXaTOfVk/ZrsmmCtuNOT9QslL91HTtds02GHqjNNtn6I3SOO6yfg6JdoSOu0OAl291V2utPt3z5VmV7i0R7VP278utsd9AHWW/ob6yyXaGuorwnCsw+L+iXEHBL/nIXAF/vQ7zGUq/eW5l8P8Cvu1rGb6tLyfOrwfmCqwfq4ip0d7ZF/h8cPLk9Ztst9g3IXvBUKacKzAZ9Tuds8Q9Lwj/j55cAfojzmuG3nDPe6fUVzYSuU9sPfub12KS3y2A+27G+hnqHvoc1j2Dn9waqfdvFG/E8Buct1Q5I9+Y4/tqrloXUPpsfqDkXDo4V8BffSqYm/B+9UnNd0r6zeFcgZrjqH7AXEGnL535cgVV+jXfekgnufLcHdvI9ow+gv0A+gj2H759DCoXhj7C5yNDYxZc8xykXAHal29djO0f9d03t+a4QX1RWM25egl+Rmuk3sGt0TiVLvvi2E7zdc59qvm6D5cvT6G+HLvKQxv5wrpMO8smlS2abKqYb2BcwLboy9EkT4isVD81CR5lk9d2V1IZju9s16jbmANj/ey0n4JtNyt/+F1Pnr+Kr0Hz3PpQ4IXX4XkcQPgjWiP1Tm2NxnmYG3lCdEJ9CfkwgGE/hTpxeAAu356g1QL+cA9t5AvrMm3m0+op2zXZVGG7aG9su6qfED5EVqqfmgSPsrGy0C9TH0ploV+mXgVtZv1U6/9Zd/KwPeCeIP46vPKFPt3rNGax7qkxS9k/+w20f/YbqKPsN7Bv2W/wF8cZnnMFBr+x9ey/Fn+ijuTQdZkrWE08HgY8KP3muZXBX9V69t+kjze1NM6+nDgvSfF0yhVYP1YRU6O9sy/w+eDkyes32W6xbzino/IOKFPOFZiM+gU84usl+M2tZ/9VuQL0R4cR7+iPOAZRuWPljzBX8JbWs78HXbvttgDumtbodqNPY3+RPKx7Bv+21ki9l6e/Y/qNFVSGfoBjazXmKD1Ta0U4hnI98wPmV1AXq8gVGP4B197mIrkCZX84PnCuoKDfHM4VHCHoqX7AXAHKFOkbLl+uoEq/hnIK8WsIz3N3bCPbM/oI9gPoI9h/LPfQQx+Bsbj5CJ+PDI1ZcH6+K22EsnG2f7Rxtn/Ud44bUIYcN6wGXlTMg2M2wv9Wa6Tefa3ROJUu++LYIwX8EQBzCLUHdf3IAFyrPLSPEvBHemgjX1iXaWfZpLJFk00V8w2MC9gWVT8hfIisVD81CR5lk9d2V1MZju9s16jbh0Ob72uNbocvzk8ett1DBK8YD+xtuYKPtEbqfaE1Gqfyz75cQd75Ovqw1QG4fPM1n/4q2sgX1mXazKfV66Zcgeonn49VslL91HTtds02OJa5AtbPWLmCq/fxXEHImI+6ivCcKzD4P249+6/Fn6gjZXMFRxCPmM8Imdcb/Ldaz/6b9PGftTTO0FyBwf9limc8cwVo7+wLfD44efL6TbZb7JvxyhV8o/Xsv51yBZzXjJ0rsM1GnXIF/9Aa3e6iuYKeoZF6305xVpkrQD/AuQI15ig9U7kCHEO5nvmBknPp4FyB4R9w7W0ukitQ9ufLFRT0m8O5AjXHUf2AuQI1F0Fc3Zgr6CRXnrurnGbe+Qb7jyK5AvMRPh9ZJFfwoki5AtR3jhtQhhw3HAG8qJgHx2yEnwQ+7ECSjdJlXxwbY77uw+XLFRwj4I/y0Ea+sC7TzrLJsc4VYFzAtujL0SRPiKxUPzUJHmWT13aPoDIc39muUbcxB8b6GStXwPFAp+/ac9yk9lj55ied9o769hqtpDK1V5/poE/APrkp/c17jVamcu4UUxvtkvo+tep9NJ3mg3x2Bn0373lBGeN5JB4b8IzLGTQ2YC6K92T47nrgutgH/RnwvJ/M4I+HPr7sMo0TefCd/8qrz9iGsvqMtrGT2mrwa8dWn6eMtz6zzqI+c05I6XPDtfuwMvmcNV2o/+fvR/p/cZfrv5pL+PS/U46E9R/jt/HQ/0U59H+1h6bSf2tblv5jPhHht3r0X8nXp/+d1gh9+n8klWG9RRl0UP+x31n/Df66QP032lXoP8qI9d83b0qevHMdXhPA+N2n/7xeG0v/+3Lovy/2Vvpvbc3Sf8PH+fI3ePRf2eAQvCu71oVtOILKsN6iDDpZ8Tzrv8G/OVD/jXYV+h9z/topz8DxPNqGT/95nSOW/n8/PahvfTwEcL47HEPOsauzKny+UJ3ZVGf6+Mzm7UMj9T44NBqnipGWwrsq5rw+XEMe2p3uxmDa6m4M5sUJPq1ehee/+qo+16pkpfqpSfAoG2VbQ1QWeq7Ed1cenhdj/RwS7Qi13SHAe8fC0XiXdcCb9w5Xo6Xs/2Aq8939mvccu9J19hu43ucEPK9FG/yn0kbZ+gbqSA5dl2vRfFcNnsNX+s1rdwb/x+DbPpPh2/py4vx8iqfTOBvprprequ+q6eQ32W7V2bQG/Y241PoN21m/03Ndw8dnvb8CfeBbi+b7ONR9TcofLaUytBlci/6XlA8+o5v8bgHcn5LuqftoQu5i/B7o81+kv2P6Db4PS911wPbjnF/PmqI+jqFcz/xAyTPgwWvRhn/Atbe5yFp06P10Jf3m8Fq0yhOqfsC1aHWGFnH51qKr9Gu+e3w6yZXXhrGNbM/oI3x377D/8N2/hz4CY/F/IdtXPnJI4B2kMqyb4H0nzTfQvnz3OYWcY1d75jhuOAR4UTEPjtkI/2PwYQcsGY1T6bIvju10zpzvD1LnzH24fOfrDxPwh3poq3M7zItz2TapbNFkU8V8A+MCtsVOa7IhslL91CR4lE1e2+X1bXWOXdku5t9ZP31xfvKw7S4TvGI8MFXQ943dvjtollIZ2jXfT6PWGIYAJut+iulLRuotI9nEvp9iiNqT934K3118nfwG067vpxgNr/op5H4KdV+Lsk/OMeA8g+cjasxR+tnpm2K+cRfvlrmQcgWx74Fk3VNxs7J/9huh4zr7Dexb9hscHzI85woM/uhUIBZ/oo6UzRXwOI5nbpR+89zK4M8G33Zshm/ry4nzhBRPp1xBpHG8t+pxvJPfZLvFvuH5oxpLUaacKzAZ9TudpzB8nN8+DfrAlyvIEy+o/J3yR5gruCrlg/O5ye8WwJ1Lulc0T3Ut6POG9HdMv+GLrXnfqhpzlJ6pvYE4hnI98wPmV1AXq8gVGP4B197mIrmC0Ll7Sb85nCtQcbjqB8wVoEzV/T2+XEGVfs2XA+0kV567YxvZnn35RPQR7D+Weuihj8BY/KqA+caQwKtiFpxvnE25ArX/KO85WY4b1HyOx42sPU1Z52SvBx/2ZpKN0uUyd2rxPvy8d2r5cuyrBbzvDEB9p9ZoeNVP6syJ704tn+1yjgHHd7Zr1G3cX/7mjHEb26HWQlQ8gGP+uTR2Y66Av3uRNx+gbJ7jNBX7DgleOfZ9F9ju7orzfEPUnrx5Pt98rVOej2nXeb7R8KqfQvJ8+N0LzhWE2ifbPOo2jru7K8oVTKZcgfIJPt3rtJ+GdS/0DAn7jbz5AKXr7DesP1FXEZ5zBQb/GOUKUEfK5goOIx4xn6H0O+tM8O+Ab/tYhm/Le874ycBcQaT927nPgvp8cPLk9Ztst2qMb9DfiEudAWM763c6Z5l1XuCLnlwB+iPOa6I/4hzIMkFX+SPMFXyLcgVouy2A+z3SPZXXR5/Dumfw/wj6/AcUb8TwG7zHSeWMfGOO0jO1zotjKNczP1ByLh2cKzD8A669zUVyBcr+1HynpN8czhWE3r+HuQI1F0FcvlxBlX7Ntx7SSa48d1d3vigf4VvDYP+xzEMPfQTG4t8i21c+ckjgVTEL7ldoUK4A7YvtP28+QM2tOW44DHhRMQ+O2Qj/XfBh/0OyUbrsi2M7zdd5HUbN1324ypx78t0X0ulOLWWTFd43IecbGBewLea9c1fJSvWTOiPG52dCbfcwKlP5AGW7mAP7n4xxG9uh8pUqHsAx//f20lzBwNKReouWjsZZ5wra+axzBaPLxjJXwPoZK1fwlQWj8da5gpHfWbmCVSkD3ZwrWAe+7fAM35Y3V3BkiqfOFYxfruBE6IPxzBW8OEXYKVdwKule0VzBZtDnM9Lfda5APnWugOjVuYLxyRW8mGw/Vq7gt9OYZW/LFVwDPuz1JJs6V5Btk3WuIJ/txsgVvD5j3MZ2FMkVnEpjty9XgLwNUVnMMwi4JyPrDMLNYLvvJ9nEPoPg2/9Y9RkE396r+gyC/24/3xkEX65gCMpinEF4f0CuQJ0pHHTt9oC5gjdRriD2GQTfvSO+MwjsN3z5h7E+g/Aw5QoKxvSVnkH4PPi2D2X4trxnED4amCuozyC0yzTWGYRPB+YKOM8xBGUxziB8nXIFWWcQvkC6V/QMwjdAn5+meCOG36jPINRnEJ5Bnv67r55BQB/BfmAIymKcQfg62b7ykaExC55BeC3lCkJzhWz/Y30G4R/Ah/0HyaY+g5Btk/UZhHy2G+MMwn9kjNvYjiJnEL5AYzfybfOMsd5XoM5ncuzbWDZSb9ay0Thj7ysIma/7cA15aHdaH2Pa9b6C0fCqn0L2FWBObIjKQu0zdF8B6+eQaEfouDsEeE8N2Ffg071O+wp8d5L49hWw3+imfQVLUiLdvK/gBPBtB2f4trz7ClameOp9BeO3r2AN9AHnCtAfVb2v4JK0Uqd9Bc8l3Su6r+D5oM8np79j+o16X0G9r+AZ5Om/++q+AnWXWVX7Ci4h21c+MjRmwX0FJ3j2FbD9d9O+gpeCD9tOsqn3FWTbZL2vIJ/txthXsD1j3MZ2FNlXwPHAUoF3SOBtEL8I7/sujfI5vv0KKhZS65xLMuigT8C2bUr/5bWfXwuMqatci4/57YBO80GTiYqNllEZythoqj1nS4H3Fo0NDYC7knhtuHZeG6JtzYz6Chf2yxr4fTSUI/y9NJdEeebo1w2DUMcBDsRdUGc2YFvtUfEkxk6KXvIMiLLeAF6+fMKe8+7/2ZopDapvvPA71ss+AX+lgDdZ9RPvLRf0nKds12hbGbcdy9D+jIfEZlcRf30F+QuRH+JvCviNAJenL6a70bqA+m72inf0zqQy9M1DVKZ8sy/nzP4N/TZ+B4TX7A3+YYjlPhMwVmL8zLrp2++E/Kj57iEBuHzfoe20x41pq7ks8+Jcdgyg7MNkU8XY5luD7RTThMhK9ZNas+Vc0kwo4+9RDUEZx4c4JvI6MOo2xiOsn7G+afWf80fjVbGZT/c6xWase6GxGfsN3/25eXNHbGeoqwjPuWOD/wqN9wVzLjJ3zHtOVwIPeXJt3wDf9oeR8nd/MrZxbu4cS949p538Jtutb+/BMoFLza3YzvqdjrENXy/B/29P7hj9Ec8th6DMl0/i+B1tBnPHP6PcMdpuC+C+mZE/Qt1Dn8O6Z/C/AH3+FuWOY/gNziuhH+B1AjXmKD1rivo4hnI98wPmVwru+wrOHQ+fzXftbS6SO1b2p+aZJf3mcO44NFeNuWO1Fo64fLnjKv2ab/7eSa6cy1VrqcpHsB8YgjL2H0s89NBHYCz+M7J95SNDY5ZlgPf7acyibJztP3SfaUjOmccN5cN4zB4Ff/BIvXkHj8apdNkXx3Za9/SthR0WgMuXH+q0x41pqz1uzItz2TZZ4TpOX9Xr00pWqp+aBI+yyWu7nB8OzTnjug/rpy/OTx623YMFrxgP7G25giVgu8eSbOpcQTufda5gdNlY5gpYP2PlCp6qcwW5cwWnpYx2c67g+eDbzszwbXlzBeekeOpcwfjlCi6CPhjPXMFrUj465QpekBFz5M0VvA70+cXp7zpXIJ86V0D06lzB+OQKXkO2HytX8Nhemiv4dfBht9W5gjbaWTZZ5wry2W6MXMFtFeUKOB6YJfAeKPA2XLsfMnjfPrOlAh7lwd/VRjlyTID1ZmbQUTmI5OF9ZgZ/b2BMbbSr0HeUEeu78tkIz/JW80eMlXl+rfb8KX03msbzgQJnwvsdNDYsALi0aLjsICjjs8y4x5m/tYY6gnxgP6EeNAHG8PYS/BMwNnyZbETp8EHwjvvA12fIj9LrkHnNAg/tTv3PtJEvrMu0mU/UB6NlZSabKmwF/Q/bis/XJE+IrFQ/KVvhuG4+lC2gMt/dSfitNT5jibo95EbazPq5QLSjCe94bGgKXhO8J1AuarHA69O9IQGPdsy6d5Bon7J/9hto/+w3UEfZb2Dfst/A+b4T8JyLMvi/oFwU6kgOXZe5qIOJx6XAg9Jvnrsb/LfBt/1Vhm/ry4nza4HjpvVjFXO2sRw32W6xbw4iXAcJXGr+xnbW73SMZPh6Cf5bnlwU+qOlxDv6oyEqWyToKn+Euai+NMBU55NaAPfPpHvo01Qsybpn8BOXj9T7LuWiYvgNjknRDyAO1imfnql5AsdUWM/8gPkV1MUqclGGf8C1t7lILkrZ3xC841xUQb85nItS8yPVD5iLQpmq+ZIvF1WlX0M5hfg1hOfcELaR7Rl9BPsB9BHsPxZ56KGPwFjcfITPR4bGLAcB3tU030D7Yvv33dWK+s5xA8qQ44aDgRcV8+CYjfBN8GFLSDbjcS+lD9eQh3anc00h91wwL85l2+RYz80xLmBb7JSTCZGV6id1BozXwkJtl/NbOL6zXaNuY76X9XNItKPIHSscD0wUeCcIvAY/BXD1EI7k903p716CPyRtD8auhrMpeGjAO+7T6QIefZXxM5V4wLpTRT3Tc6XvBldS36cofcf2sL7PgLIeAc+ymSngZwAMx0aYb5pCZYNQZjQHCQ/KO+F96tzR/HTqW9avaYBL9e2b0t+9BH+iR7+UvkyCdyxDn8yRn6nEA9adKuqZfJV+GVxJ/Zqq9Avbw/rl05fkYdmo3DXnhZOnSfAoJytDuzSag4QH5Z3w/vDM0XCDwE8j41/jld+xLSCujcTPlIh0sN1riM5kKGulv5N2P4/GA5RJj6j7hvR3L8G/AmKgi9LfU0X9KVTfyi4FO3v1Zdn1TZZTXbsv4XOWKA8cS7LaifBvymjni4DP7Z5cib0raXdNZXfo+0L8OsLn9evsu9EmJxOuyQIX6jf7ZJNRv9N9YPh6Cf4a6APOlWD7OOc7MSfvajxRfsTqJn2xNRWQigOmEU01hqm+aor6zQxcEwT/aLfc7z1Oj4cMbzqB+Urln3sJfif01Y2XaZwug4fJGTz3Z8DPIB4M/kahLz4/gPo/nXAa/BsA55k5cf5aBs43emINZafT4F3e8ZTjCZQj7zNF3nlcnAn0GfbXiT6WoZ4zXefhV8WQPn55vLGyO2C8ekf6eyLhy+mre3x99QLBb2hfTfa0j3FZvV7Xro8+G0F5vGe5xtmXE+dtYkxXscrRgP+OjHjEufZ4JHnYL6PPQDt8HsUkSH8C8W/jxN3CHtVYb7jKjfWNv1NjPc6jeaxXskF49gnTBDyPI87p8eYIKlPztIbgIe9YinO+k2aOxjvFgzf592XER6cY74b0N/vhj3j8sJKhT+ZqjohyNX6UH+acgtLZsdZHbD/ro6+tzuWfD7M+qvFD6SPHWT69SR6fPmJeajXFdtMFTeWj88bcDfptPr4/A559vsHv8cQ9swUP6FeZ5zkCfjbBYPtxXJrjNG20S5TJBmqPwf9eoD+OlPOYrvQf5cb675NR8rBM5wp4lJXJpEnwKF/lq2dTGdJlPVM2G2obVjeRQz/56tD5FPvVrLwD+2qD/+uc+Tmfr+7kjzgOC83P+Xx1lbrarfk5pY+d5tXfmzGalop9Jnj4D4191FjLvh3rTXGd+fLN6bF+00Nnckk6Ki5W+aRGxr9Gh98xHcWzshduj+qfaYHtmUbtmRaxPYpnzhEnv1vp70RX/5PmMOgne6hu8vB4Z/AzVozU+xnNX5A2602o7k5yo/mcBjJQPvtCN9J+5ypZx+ob73Us9lXo4wYJ16DAhbqHY6fBOBfV7/flzQ/7/GDyhIyJaBPWNhWjc+4Y9Y19r5Il6p4vDhmEtv7OjM78T/G0t5N+8PoDjvN8XkrNV5QuGFwVMQC2h3XBN6YnD8tGzRlwnGddwPnBdCrD/uc4QsVtyl9yH6N/xX7hNSuDX5L619B8q09vOsVHPJdXOTzfvHKsY8du0RvO+6Lvyas37EPUPgQcv5W/m0C/VSyJ8D0ZeJqEp0HvJ8F7rHcjtZljJMb9OoK3dvZnwBs+jkWeA7ZymWeepXC+nniY0YEHXnMx+JMFDz75J48vJpzo2m0xh9304hhkD8eUiH/Aaf1ouaCnwfIzekoPkodtWdkTlvGYrHygsnOFqxERl8UNKoZdS3Tyzouwvm/+ta4knXWCTtXzr7VEZ0ZEOmgz64jOzIh0UA9aRGdWRDo4Hq0hOlnzvBetGHmP41bWPI/PQBj8QytH6r00xanmzLzWNxvwOQG/JoPe1pSG+T/MOebwR/Kck+HqJLurSXYq/+eTncG/HWT3Mo/s2LZVjDHVtcuDY3rMwXL+W+Vz8R3rHNY3uEFRj8erefA+z1wxxDYQ/4Brb3OR8Woe0cO2Jw+fH5lfjN7w+RF1hlL1A54fQZmq859mY8rPcs4AfeNcKkN/NofK0L6Pht9II6tNFtv69h2pOBRjN5VvYd0b61hpejF63lhJ5Yfyxkq8xtitsRLyybFS3pwr1p/mobOuJJ11gk7Vud06VgqnUyRWuidSrHQIjPf30XiPviIkVpou2sH0Hu6CWOmDJLtO6wksu+EzFiC7j3hkx7Zdx0ojfOI7xF/HStmxkoo3qoyVpndoE8dKij8V7yRPy4U9IbEUti9H3w2F6qbhjxVLqbhExVIl99G2kv6YlNbDOPYV8Btlh3RmEA9l+0/lZsar/5rF6Hn7T+WsYvYf2lae/lO2yXst8saVal286rhyCtHJGuO/RmO8WtPy7Rkw+G/DnoGv0xiPtH37AnCfA7c50jp/z3jvLfXF6LwepfaaNFx7n6h9SLzmNEHQSdp6d8a6dQPwvkHUZdtG+BmCD4PnPaUMw3v6Df67sAZzTsZ5HrWvE/lnnf03zzqsWmv07e/otNboW6OfTWVqD5uyCYMraRND473flPUeY1neN8r2lTwbBC4fr80SvHI/Yl/NJVx4fkXt6WC9HNbZdL7Uab+xybyK/vetwyuZ+tbhO8mU812h+405l6V8b+g6PPqQr43xHJVzBvOAlx7Bq+HtJfiZMM9evnI0TpsvORdms2p+hnMu3o+Ec7MFAbh8vnShgF/goY18YV2mzXxavQptS+6Tw7k225bqJ4QPkZXqpybBo2zyzpfnUVnofHkutJn1M9YeGs5ZKV/l073QsUrZ/1wqw3rsN9QYp2yJ/Qb2LfsNzoMwPOcaDf6YtC9s/oU6kkPXZa5xIfE4H3hQ+s05RIM/F3zb8Rm+rS8nzucGjrPWj1Xc04b2zr7A54OTJ6/fZLvFvuE8qYpnUaYc15uM+gU84usl+DOgD/hOBfRH84n30Pwdn0lSawiJ3K9J+Rh07bbbArj1pHvo09hfJA/rnsG/HPT5gvR3TL/BezvRD3CcqsYcpWcqPsMxlOuZHzC/grpYRU7c8A+49jYXyVuF5qhL+s3hnPgiQU/1A+bEUaZI33D57p+s0q+hnEL8msqTN117G9me0UewH0Afwf5jpoce+giMxa8h21c+MjRmwXXIe2i+gfbF9o82zvaP+s5xA8qQ44aFwIuKeXDMRvgbwIfdTLJRuuyLY9W38PCewTnUHtT1AwNwzfXQVveIHuihre43Zl6cy7ZJZYsmmyrmGxgXsC2qfkL4EFmpfmoSPMomr+0upDIc39muUbfxXvqbM8ZtbAeO22y7cwSvGA+M1d6/WLmCW8B27+/yXIEv317nCkb46eRjY+YKQvchxsgVsH6q9bfQcRf3+14dkCvw6V5VuQL2G92UK3hiL8gV/B74tk9EyhV8qs4VDJeNV67gaU+uAP1R1bmCfwjMFfx+pFzBt0Gf/8iTKyjqN+pcQZ0reAZ5+u++mitAH1F1ruAfKsoVvMiTK2D776ZcwffBhzUOGY2zzhVk22SdK8hnuzFyBayfsXIFv5/hE6zfkgfva83ay9Jwel7OcZbRztprxXGWwQ+k7ce9Vuo8x3po2+RDdNvQT6i7+drOWRwyUm9q+lvNnzgvirLhvc/YBwx7ptMymAN8zDwkm5bp16CnjQmOeYdkw50p4BjHBCED394Y9kNqL5ojnBMELNNQ8bKiMYNwKptIHhX/+85osO3xuwkCfnZGe52gPacD3lkCj/JD7Numi7KGa7epvLEBfjd3esqAspcsm1B6NdvDO88HfPseFe9Kfug/fHuu7G/WreminQ3xt/G3Hd5l7WfFuSnCWF3es3es8JmMM+ueoFdl4DwBcIbsTz0W3uXdn8r3BCk7V7yjL+F3qn8mEyzHl2cKnrL+Vnv5s3hQd+uP5d0+P0//UHflDRLvTeIdYfksAv6t9LtBv62tqN8Iw/pt8Od69FvdoYB8vSoD5waPfiu5HwPv8u675/uu1R2qinf0PfxO9Q/rN/ujMwVPWX9nnZdXPDQFHtPvwQycTJP1IXlYvxuCTtLvbyX9Rjp8T3ve8zMTBf/8PbYXgy7xdzHUN96wjRsycG726Gfs+9iNH9833lQ97L+JglbLfvyP/zF8ZgsHuGwd5HMU14KcLr5M89Jgfjo8vvNRJe+EaKEO26NyhON1f1bJc36L8Rwc6hGeg1P3uGN/8TnEBtBP7Gg7zfeUjWHd69PfbGM3wjzr1Rk4nSvnm66bPhpv7DNdnHdT34Hz3c/t+96N8dDpLMkN6W+OIX8dbHN75XfXN3443nc68lkSnNdkxU6Iy3d2De8wVH3A3/wx+HdCH/i+G8b37g/m5L0peFd2jLbBdqzOFU4UeH12j3zbt1HY7m/3jK3qjju0+7x3rPM6fOg91WNwHnX6eJ9HNf5VDoPjSN/d5xij4fnS55HvfTfAGT+YJ2b9ek/6d1YO0+r2EvwjYr5i7RiA+u+mdrwHeDGds/H4vcR7ywU9E3BcskfFG4Z/gHjJSW843ngv0eP2ma4k/Wr9vnPHtdddu+PG9ds2bzlt8/Xbd163FU8Vo8SZSoOw4ju2YCzroXeTCO4C+nu9qOcEbvQct0KZkoThNC+Abbo1ox5rLr+bIODfS7jeK+oZ7z2e+ogD67HGsBWhl363oM1W9BRY0Rsuy6b7btcuB7akiYKeWd2tBOvciNXdRm1quaDn0lCrM/wDxEtRq7uN6HH7ilkdagpSuYSwGgzC4nMJcIbwk+hv7r3Joh4/JrFe4vkvIMb/EuV5sV2HEd9K2/Ed5wmwvsEpOktL0lkq6JgmD0HZGio71FO2GsoOo7KtUNaisquBz41Udo1rb7OVvdyD8xaBM+m761eN1En+uwvglKazV/0A0MS6+HefgOU1OoP9B9Crvya9Qitmvbq1A98+vbrVZdNZWpLOUkHH+gT1l3XnNtFWK7sdylpUdgfwwrrzPtEuK3u/B+edAucze21XjYbj/k8e8/h3w/scHviSUI9v+AeIl6Ie/26ix+3jvM6uYvQublB9pIc4jR+T9T2izHDdm/7dn4HL6vYS/A9Te2sSXPJsJBr3CH7xnckn0ZPv0jo5yraR8a/h5XdsX9h26x+jg/6mBfz8lObH6Kd6RF2b+7CvOmbtSL3/Il+F9bnvlJ0Ubf9doo1TXbtslsDvLP2+20Nniac9VfXnEqJzq2hrIvs+GsN2QVmPqHtt+ruX4A+E/pyY4pzqsm1RyZnHpbxyPkzQqVrOPL7cE5EO+qkW/E7+2024WM7WTybne6FsN9W7D8oQDmddu+H9fYK2wm84Oung/FW6bVk6aLR6CX4C6OCigjp4D5VhH6C/QD5QDgh/rdPt6s+Az2rX0rQt6psvVh9lhX3B/tfglwNOzjfudu3t+gC845ya0ofdol1Kpve5zrRRzuszaPc7vy72EvzhQqZqXNhNvCPuo4iXezvwzvaN9Q1uUNQr60cUz51s8ricNnld+pt1919PHqn3HLLJ3VCfdQR55nlEXjkvFXSqljPPEe6LSAdtpgW/k/8eIFwsZ+snk/P9UPYA1XsQyhAOx4UH4P2DgrbCHzounLtKty1LB41WL8H/OejgBtJBNa4oHbyPynZDGY8L9wk5IPx1BG989zv/eNtL8Bd5xgWrj7JCveFxweAv9YwLRhfb5RsXlC7eL9qlZPoA4fqAwIVy5nFByRTbb/hYpi8OHBesvspHHE1lmI/YRWWYj+CY9Q4ou4fKMB/BuRHMR7C/uxPKdqe/VT5iyNMezNtxvg/zdrdRGebtbqeyq6HsDirDvN37qAzzdu+nslug7E5oq+Xteqmt29P3Jde35FnerLwow+G/zoWNB9hXk4jOeyPSQVxnEp1bI9K51dOe2wUd6y+0lyrWIw3/gGu33SJ5sjuIHrev2MoIehuWCmLFdw03uvVYNhbrke+DMiUJzpxjm96XUQ9l4cS7CQL+DsJ1h6hnvPd46iMOrMca06D3WeuRhqOX4N8Jo9UbabRWtFAePGIa71k7C5gHg3838MA7oe+AOqpdt2fgfGDViDxuXaVxOoFTtet91C7m4Q7iweDfJyKBHoJhftS75G9c631fBn+qn5hXHOWy2sP9ZPC7PP10m+ABbXJ9Bx4Y5n0ZPNwneBDe7bRt19+YejdHTy/8Zm+kJM/rtrcJPFmPSSPRQtNIXs9gT6XesQZY3aTltlcvbfnpW6/bumNrRtvZc0/KoDnB6SdkDC241hQ8hvJaU9kxVOWI1RhqbVd5wKYo4zndXYF0kj61fYtpn27ase2GrC4NHVwbgi2u7whXQ7xLngqXHAurwVgtOeYLpVA5WSqIFd/5JN+pt8+kv4uEUmox9C6BUyW/d2XU6+TkJgj4uwnX3aKe8d7jqY84sB5rDFtIVijFIYfBfxGGJtvaxXXs7x3wm7duqYWmkgvd00OtyvAPuFJW3PDpklqAy2dV7FqNyjTCajAIiw9+ThXhs4ZFezaIevyYxEKGzIK9Oli0V8sOmapX1VBm7bunGL3JDaqP9BAnp8TuFWWGa3f6d94ltK+m1s2p+uTh7RmhywuJh/lTSiWZbv8dTGD+F6WclVdl74W01TjWdNkekbduJ7+ztkglD291CtkGpcreL9ql0o4tKvuAwJnI7bBDR8Oh3jYy/k0eX4rJ18fo2XiUVDrGOpmF60LClbVUnvx3XwdcFxEurG91OZzFer7lKLN3XuppuaBnSqg/M/wDxEtRf6aWJbB97M8eKEZvsEH1kR7iNH5M1lnLaMl/D6V/9zv/klovwf+U/BkuvbE/U8ty+A792Q9pGQBlW9Tmmq697dY/PBdB/5Dw8zNK/twHZSpq3Jn+5uX+z8AS4C/IH6P+GY9qeZR9tdK7+z3tv13QqVrO7Idvj0hHbaX16RzK2frJ5Kx03uo9BGVsu6zPCI84FH7D0UkHm4fqtmXpoNHqJfh7QAdnHDq6/VifdRDldjuVYR9wrKT0E+F3Erzx3Z8Bn7W8Pj9ti1qGVolt5IuvGjD4RYCTl6GV/1WzEp8uKn+tZPog4VKzUmwPJ0qVTNE+76b2G/xSIVOVpuIlY4z5fMvQvJyMCx28ZIwJ6t1UhjEfx58Y891HZbjFF3XEYj4+eHVE+n6ia++jHGO4XJplm0IZ4nI2ljk30p/qCGFT1H+Ph841JelcI+gMinrW7pJyDM7zGf5YRzhvJ3pZclE+3eqq7Ry8aGJbHJ5MfyS6uZbmI3x9ZfKYXIfgfY52HhcqV8M/QLwUlesQ0eP2sVwPFbw0Rdll8BvLkM6hgo7CNSMirhMj4podEdeCiLjmdmkbY/ZjzDYujIgrZhtnRsR1cURcyyLiakbEtTwirlkRccXUiZj2GNOGYupETHnNiYhrXkRcMWU/PSKumLKfFhFXTHnF9IXzI+KKKa9u9YUx5RXT5+wPMVNMnYg5bseU/cERccXU+5iyXxERV0zZx2xjTD8RMwaIKa+VEXGlSxvDOaYhKHsP0RkSdIY8dLD+UAAulT/wtTHrKi7zMcNbJK/YefX6bXjRyzMP7+g8I4PFYwlufQZrDYG3Qf/x+2PpXY+ARdxJWumENG6rcFve0Q3C55xOK43Xtry8uzMvhd9YhnR2CToK14yIuGZGxHVxRFzLIuJqRsS1PCKuWRFxxdSJ2RFxzY2IK6ZOxJTXnIi4YsprekRcMeV1YkRcMXV1QURc+0M/TouIK6a8Yo5D8yPiiimvbh2HYsorpr+PqV8xfU5Me4ypEzFjppiyPzgirph6H1P2KyLiiin7mG2M6Se6Nf5aGREXp0lwXs1pkry30GH9uwNwqfmwr40Vp0mMxaMIbn0Gaw2Bt0H/8fuj6F2nNAnvyll22LP/Wlqk4K4iuRuMd2lhOgh3u2GZc2GZOqx/qIfO6pJ0Vgs6g6KetbukHIN3/hv+Adfe5iLpJbVLTsnF2lcwnTW88993Ogf54bOAyq2Y/fRn4OKdoQZ/fKr7TdfuUnjnf6jrStKQRx82mne1azCknxGvcokh+liUDupTK/2tdlizHec9daV2vTIu3PGMO63vJHjsZ4VzDZQj/OlpfyU7hN9EH0xRO/MTfs48rDOvtwte+XTbTSeP1DsnxankbP2u9OAuKjtU0FU42Tfm7bvVggcfLuyvrQRvfdGfAW/4uO82Qd/xjnm8qErpz10ZPKD+IA9Z+nNpAf15/mGdecW6W4m2wV8B+vNC0h+s79Mf3s2L+mMyUmMr77TOO7Zifd8YzhfjK95945hvt7eSUchub9SLHOPf0yH+GPHH2u19J9HLkkvJ5bE9bEtID3HeSfR2FaPXo04687iwO/27P4OXrJPON9I4rk6uNqkseYpeUj/WuHyns7FPEt+yjWSB+tTI+Nfw8jvmEfsrxAaL0kEbaqW/1bR1M/zupMuKDtb3XZB9TUk61wg6Sr9fDjh8J8BL3lLQG+rbDP+AK2X7DZ9NqPSF8hVWtynKsj5ogXR8lyUjrkMj4rqDcCm92Sxw5ZVXBamQSwjuogzWegTeBv3H7y+hd1mpEMOtTDLrmiLnwkxS3UE7VqZf4bU5waZt+Mf62hw1RFvdvXGIrtBN9+1Lbjp5il46s7fgSn7/SvpbXaKygejk1T+sz4eZ1TdYJgr+qtA/wz/gSul7wyd/JRdr+27BS1OUnQm/sQzp7BZ0mqJsY5fjUhfvlNVzrO/7bkDZcOzuQDq7StLZNY7tGRT12G53w/sq7HZ3+nvAlfITDZ/eKrnwhUxYt0llycN6e5+gc5+gs7fgSn4fn/5Wl1yx/u0WdHZ76GD93R46u0rS2RVIZ19rz5Ul6VwZSOeeknTuCaQzVv0Tcqmcj869Xdae2n72v/YMinqN9F8bx++D91VsMTD8A669zUXG8fuIXpZcSl6eOLzF4H5BD3EaPybrB0SZ4bLLq7Iun7K6fFHZjMOf/bdJcMnD4/wDgl98h1sMpqR41cVmrPdK7vcJvErvDU7R2VWSzq5AOntzeyq8JHRqqB0b/rG+JFTZldVtirLnwO889hDTtmpcNa4a12hc6gJX9sm+sVbRwfoG57vAteSFw8G5C8M/4Er55oZP/kou6oJjq9uksuQpejHx3oIr+c0XdGPfs/7l1XOs/4CHzq6SdHYF0rmqJJ2rAunsa3Lbm9ujvuXZSn8nMf6WwzVN3CKIdW2bB1+Au+rIkXpX07wBtyVMpTbm3c6H9X3b+XhLKraBjwy8XOBsUBny93IPf1j/5Rn1kJ/k4e+fGkzylNzqH3zxK2/1v6UYPe9Wf2wfj0nvE7w0RRnKMIvOVEGnQbg68RVxW4qxeCjBrc9grSHwNug/fs+78nsELOI21cduZtVHsfhEpVT/ljGmw7jwA5bK9fUS/Pojnv03cV9vTt1XyA5d/hhkywU9a0LN0vDH2qGr1N93H/Odghe1o/IC+I1lSOdOQUfhmhUR17yIuBZGxDUjIq5FEXE1I+Ka1qV8LYiIa25EXCsj4jokIq5VEXHFlNfsiLhi2uPyiLhi6n1MXxizH6dHxBWzH2P6r5jyujgirvkRccWUV0wbihlPxJTXsoi4ar86fn41puwPjogrpt7HlP2KiLhiyj5mG2P6iTkRcXVrvHpWRFx8WQzO0Tn3oObD7/PQwfoGp7612kj/LXmSt6dB+IxPfIf4B1x7m4vkCZT8lVzUzRlWV6W/OX2X90gS4rqNcKlUrcptNKh+pzZGTAUai0cT3IUZrE0QeBv0H78/mt5lpQINt8qCvz+Db+fCsuBY/+UeOreXpHN7IJ3VJemsDqRzTUk61wTS8V1WwC4u72UFWD/PZQW3wvscLid4h5Hhj5UKvZXoZcnF2ndbMXpTfO4GcRo/akUEZYsutj8Dl9XlizzmpYrMKyvJw6vqoUNjkjKfuXo0HPKLl7TwSlfyuwV4Fq4ezcNtUNYj6vKFJQZ/yeqRegelv9Uq4ZAbXTYEZe8lnnHFjnX/anhfxeqc4R8gXorq/tVEj9uHQ59N4dKhb/22zVtO23z99p3XbZ2AqF27l0WpIFZ813CjW49lPfSOF7mGqN56Uc8J3DgiXgNlShL8YXls0zUZ9VAWTrybIOCvJlxXi3rGe4+nPuLAeqwxDXqPFvZuQbuX4I9MC5LriN5IVyIpWigPXvg03s2bMQzzYPDHAA/nXKZx9ma0i635Gvp7CH6fmUH/HPAyJ6zW9J2gz+1L/rPRvT+D36uJB4M/CWRgV1Op/QYcqvI7lAHWzfobYQ+itvDHTVkX303wt3RoO/e/wZ/m6f/Vggf8wMn6DjwwzEEZPJwleBBe87Rt19+Yek1HD8f27OW4l7gnVgs8WY9J45mL4GjMxl7bKuqtpr+VBiQtt7TT8FTpuq07tma0nUeEQzNoTnD6GXSat+SZ6EqNlcFjs+EfcFrzWi7oabD3NHrcPp56Xy14aYqyLCvtRCfpU/tOStqnm3ZsuyGrS0MHbeUsuL6jug3xLnmeccDpMpLK+vB0Nm/WB+sbnKJze0k6twfSWV2SzupAOteUpHNNIJ0qsnKMK2sKsS393Uvw14BjX3+ZxjlB4EwevnBI3VOpNjkavO/aaSVLzC7eHUAbZZl1T3Qor74LV5C+uqDonpy8XjjGvL5P8FrhpTnBQ854XZqTbzrIN5+iVBArvmu40a3HMh5ZXk5wZ9HfRaaD6nqMXQKnuiLn3ox6rNn8boKAv4dw3SPqGe89nvqIA+uxxqh6yd9vEXV8FhCiwcnDQcy9EXHtFrhKHmeeHWqZhn+sjzPzsSas2xRlvA6T92gV4rojIq47I+FKno01rhpXjavGtZfjUse7dlMZjp98pBF9Ks9Q8+6zUF8bUHTeU5LOewSdsboVWl2/wnLb7drbs9tDB+vvpvbgwl0r/Z3MVr+8WtPEmSzWta8O8A3jJx8xUu/3Vme3EeVs7WKeJwINK8uz2JvMpl9AXy+4DwD6AG+W/dwHMDelv1UscSuVYV8bjk598OfUB3dCmeqDm9LfvPC6HPrgq9QHWJ+vlVJ2o+ixjmQtDN9J/Bn8/xbLCIq/rGuIUB4o57dm0PtbkV1Reme0S+rdbKV3uwGA9Q510mffoXrKe6JQTzljozYKoB5wxqbTV00MH39R5Nuiz0P1nPvV4P8lsF93p7+r6FeUFferyqypccinB2oPWtO193lWJhJxYV+H9Ktvk4fB/8TTr2pDBfLJ/Wrw/xnYrybLKvoVZRXSrwjP/bpbwGO/8lnH3VB2NeHqtFcypF+xD9hHD391IR1DVL+qLLfPDxt8P+AcLz+MsgrpV7USENqv7Id3Q9kHqAzHOrblsfLRM0Sfc8zPfiGLv6y9rSUW93gt+p4MNmaJ+o7qNujdrAxchid5h2nVrOP0WR/sY5Eb/HwhcmWmyI9yUdaeklvAgxcFeAt4wf2K3i3gyqVa21G2bGZq8Yr7qROdiKqaPGdlsNEQ9R3haoh3WKZUFdcHTVXVdkgcoRfSTAFVKOQCWhX5G7xFoFnRheHrJfhDPaOQLwpOHvbWDwh4jIyNH9X+B6gM62VdpIOj426A4dHR4I8OHB2NdhWjI8qIR0e85KpHwLO8HxLweBnW7vR3k+CVSavLhkJdB+u/0lM1+75P4L3dZbe306yM9Ws3lN1PZfcJHpUuGFwVmRJsD+uCz5aSh2Xj0x2UTdN11hO0y/uJzm5BJ1QXdkNbLRs2EXAjnZYLelYYnQnwkodq7M8cfXYl8mSPGqrt3QDxUnSo7iF63D4eqlknk6cpyjik6hV0egUdhWtuRFwXR8Q1PyKuaRFxLY+Ia1ZEXDHltSwirpj6NTsirhkRccXUiWZEXI2IuOZFxBVTJxZGxBVTJ2ZGxBXTr8a07Zi62q1+NaZOxPRfMW0opk7ElNeciLhiymtBRFwxdTUmX/W4PX7yihmvxvTRMWOAEyPiWhYRV7fqREw/0a3jUMw5TMw2HhgRV+1X9w3/FbMfz42IK6a8utXndGtcOD0irpj2GHOsjdmP3RqvXtKlfMX0qysi4orpJ7rVR8fkK6bsu9VPLIuIa3+Y18Yctxd1KV8x57Ux+zGmPcacw8TM+8bEFVMn2IYa6d8IswZ+Hw3lCG8fOiq5VryF12INB+LuK4i7QficG82nI/yDgp7xNZBR1nL+5zc+9uW71n/vD/65QfWNF37H+xP6Bbxa0zZZHQD1c8jqCrWHw2hbGepIH5WhXIyH5N9VxF9/Qf5C5If4mwKeT6WF9sV0125HJifbF/MglPEpqQcFnQcFnaao/6CHzjUl6Vwj6DCurA+gbUt/9xL8mtQvqPtC1L6rawR/Bv+wgMe9WMaPko3VHRS0Gxn/Gh1+x3JDHm4nOg9HpPMwwNxFdB6JSOcRgLmD6HwwIp0PAgzfGv2hiHQ+BDCHEp0PR6TzYYDh05kfiUjnIwDzHqiX/P1RKMPNv8bHo4IP88WPwfscvrg3pB2If4B4yUlveH/XY0SP28f7ux4XvDRF2WvhN5YhnccFHYXrloi4rG+nuva+5tNyHxV0Puqhc3cgnV0l6ewSdAZFvbI2omRjdB6LSAdthm+CeTwiHdSDFtF5IiKdJwBmDdF5QPCQxAMvP3LkffLfx6Csh+omz0Xpv70E33PySL1XpjhNB9FXII9YH+OxR0U7mN52mrN8HOrk8Eej8s6OcHWS3U6S3aNQFiI7g/+nk0bqvZZkh+1i2/4ElD1GZU9C2eNU9kkoQxxY5qAN+I51Dusb3KCox+PVp+B9jv4K/iC54R9w7W0uMl59iuhh25OH526fLkav1+g9JeipfpjmtEyRvuEyG1N+9uNUhr7xk1SG/uxJKkP7Php+I86sNtnebDV2sX4jfw9RGcb0D1MZxuGPUBnGzh+kMmwzx7fW5j7Ckzw2T+0l2PfDx6VvS38rf8N+/FGB28o+JsoS/I8fM7ot6FNQjliWPD3inW8MNThFZ0NJOhsEHcbV69rnlsnDftfgn6IxBH1ZDpu92uT/JLxkf1fQ/1wd6u+yfC/ypXxhSN6r9ysPPP3Zl/14Y94xwuc7Nwj4kr5T5r2Mtsp7fZLKMPdkPKi8V8Gx64oQ+SH+poA/DeDy9IXCdVEkXOxzy+J6pCAuy+1h7MPxzSMCF45LPAY95OHr4x1wXUi4sD77sE90wMU3YH1ctJHjEobrE7iZ9qBrbxv7soJ+MjjXYPgHRBuKxG5KtmqsYT+OdZuijHX+SUHnSUFH4XokIi7Ol8bIYyod5qsRlG094uEZ6z9CZQ8LOjxnTn630t/P3EJ1pOYH9R7n2xwXGPxfwXzsr2k+hrR9sSXndFT+G9/5cjo+OveWpHOvoFN1/ptzOp+ISAd9071E58mIdNDeWkTnkxHp4LjIc4FHBA+Jzv4r2cGnoEzZ5ab0316C3wl28H2PHSCPWB9jLZWbYno/oni8YBwoczqGq5PsfkKyw7mdkh37EIO/DGT3nzl8CMaWn6AylMeTVPYUlCEOLHPQBnzHOof1DW5Q1DP5Wn99Bt5XkdMx/AOuvc1F4oLPED1se/LwvOSzxegN53Q+J+ipfsCcDsoU6Rsuzumgn32CytA3PkVl6M8+TWVo35zTeaJDmzieVvz5cuHjFXM+UYyeN+bE9hWNOc+E31iGdPLGiTFwcX5uPGKhXSXp7BJ09pVYiNe39pdY6NCjRt6jfw8dzw3+v04cqbc6xVllLLQmpTGesdCxJLuisdDfguxOINkhbbZtlBPHQhijcCyEsuL1Ritz0AZ851tTZblhPR6vCsYmwbGQ4R9wpfRjeLxSMaIar0rGesOx0GcFPdUPGAuhTFVc5IuFOL+AvpHjHfRnWbnY5DfHQo90aJMvFuI9YJi7SP7G/RW8pmSwvwt2dkFqZ2qPmZ3RUfmUjwLdC8lWUS6cv8wbO2D9J4mfGGOTWuvmfFXeHDXW5zXRJwUdHtPZv77oKM0P+leMB9i/GvwnoN9fSn2GtNlPIs8co+Xtz7sD6dxbks69gk7VMQ3HaFXFNJyv+lREOjhetojOpyPSwXGIY7SPCx6e2UdDdvAUlKl8PeerDP4isIPXeuwAecT6GKN9QrSD6f0qxWgFx0QZoxmuTrJ7I8nuE1CmZMc+xOCPB9m9KYcPwTH5k1SG8vgUlWEuA3FgmYM24DvWOaxvcIOinsnX+utz8L6KGM3wD7j2NheJ0ULzR9a+zxejNxyj/bagp/oBYzSUKdI3XByj+fIe6Bs/S2Xozz5DZWjfHKM92aFNHKMp3a9wv0dwvsrwD7h2ORbRLRULqXGYxyasq/qG81VqL4jKuSpcn4iIy7efjGMhtW/tMQ+duwPp7CpJZ5egU/U+6fHKV1UVc7WITlUxV2gs9Ekazz8NZSHjucH/7+eO1HvKM4/jtaJPAz4n4Ndk0PttioUK5j9kLMRrUFmy+yLJ7kkoC5GdwX8OZPclj+zYtnHc4XxVaJzEsalao8J3vvibY0isx+NVwdgkOBYy/AOuvc1FxqvQ/FHJWG84Fvq8oKf6AWMhtV6HuDgWQj/L+6rRN3K8g/6M1/XQvjkW+kSHNnEspPaMMS48W65yTjzv+JvUvhJb+z+Us1L7lBO4zUePhqvjsNF1Vd+/GX5jGdIJjZ0ej4irjsNG6PC7PHFYVfERx2H7Wk4qKzf73wE5KV9u1uBfCLHE/+eJJUJyUr44zOAnpL5xLHJSWbLrPXp0W1Qc5pOdwf8KyO6AFGdIHFbnpEb4xHeIv85JZeekfHFYN+SkFH+MKzQOM/jF5DcKxk3Sb/DZpDpeG12X9Sd5TgM4LssbYz0REVcdr43Q4Xd1vBaHTpF4bS3FHEXjtb97zki9UzwxR6x47cwuiNfOjhSvfRlkdx7JLvSuAo7X1L52FcvxOJg3b4b197e8mRqv9ta8mW8NkWMydc4hJF6LkTcLzXExzay47lIqN/irjh7BuYXyZursfgL33Tq/ts/k1/hOBsTN8Vre+63uFjwrOrtK0tkl6FR9TxPHax+PSAdtfl9f58yKOW4m/6bWOX0xh8FvgZjj7Z54LdY657soXqtynTNLdrdEitfOAtm91yM7tm0cG9m/1Ouczz71Omd2vOa7Pwp9Y6x1zo93aBPHa8if764he+eLwwz+w+Q3CsYx0m/wvjR1n2zJe/KC4zXDP0C8FNV/1XfqTgl1jpLvNMM47zSA4zJfXKjmi09ExOWLo+p4bTQdX7xW1b2aHK9VFRe2iE5VZxtC47U/oJij6FmV75wwUu+PPTkizud8EvA5Ab8mg95fkN8teHeX9Lt4txj7ulb6+5l7aTLm8qHnKA3+j0B2f02yQ9ps2yinJ6gMx1SO5WLuvcX6LDc1Fyl57jU4XjP8A66UfgyPV+p8qe+e0ILzh+F4LfQOC4zX1N2giMsXr/E5SvSNfFYS/ZnvvBzHa493aBPHa0r3VY4Lz1RyjkuNSxNFG3P00dRQHTT8A65d3kV0UN3Jocbryb/87+D0984d11537Y4bz9q6Y+POK6679srztt64/ZRXbtm4+YYd126+7pQtW27Yun07Mo2EpsB7LMeHYez3Q+I94vh4h8awMmBnhVyyh7guJFzqkj3D9WQHXBcRLjW48d99rp1PO+w7IQAPGloWX5uIL7X44nPyqJxvI1zqEkufY0Rcbydc6jJj/rvPtfPJ8vLhyXKgyNdvEF9Zh9CT/z7bAdevEq6sy32S/z7XAdc7CJeahPPffa6dT5aXD0/y3+c78PWbxFfW5pvkv9/ugOvVhEtt3jFcX+iAayfhwvpYF//uc+18srx8eJL/vtiBr5uIry9A2RepDOvtJjp5J2lYf6wmabuJzhcj0vkiwLSgXvL3HihTl52qQ0w2+D8N76tImBj+AeIlJ73hwf9posft44TJlwQvTVHGSY4vCTpfEnQUro9HxLWH2pN5EdCa0TSLXmbzJEzCVqc4VezxRWqjimPUZaQNale/gEd8vQS/JuUpubj6ssue/a1s5OMZvCS/cTwNuRB4D7yvwkb2pL9jXQi8h+hx+9hGnha8NEUZJy2eFnSeFnQUrk9GxMUX7WXZyKmRbGQX2MgZXWgj50awEYyhQmykzOWRiM/4wXeIP5aNqFjWZyN7BC9NUcYb6/cIOnsEHYXrMxFxhdrI8yPZyFvBRl5YoY2YvENtxOA3R7ARjJtDbKRMMgzxGT/4DvHHshF1aZrPRj4jeGmKMpwzYRnS8S2OI67PR8QVaiPXR7KRbWAj27vQRl6b00YU71XMvVT+6j74nSUj3wd47hPtUXO8+6g9WTrypjWaH6UjyW+bv/PC+otAR2726Eg3LKzeX5LO/YLOvrIR7n6i81REOjiutIjOZyLSQV8ZekHtB8gOPgtlyg5uSn/3Evwvjh+pt8tjB1k5y9ALag3+/rSg5MYjubBquDrJ7sFI48z/A9k9ksOHYEzPPh7l8RSV4ZjMeV+VX8V3rHNY3+AGRT2Tr/UX5i2rWFg1/AOuvc1FYq3Qg5/Wvi8Woze8sLpH0FP9MM1pmSJ9w+VbWOXL+tE3fp7K0J99jsrQvnlh9YkObfJthMtzWf9YbzIre1l/p3iR4/inBC+qb94Jv7EM6fg+xIG4Ho+Iy9YY6k1m7e+68VDA/hILfT1HLJQ8PJ4b/JtgPP/GGMRC3+qCWOgfIsVCW0F2365jId+z18RCXyhGbzgWUmvYeWIhtaa9L8RCPYI/hFMfHkR4J941PPSYxgRR913EN5ZdRTTy5oCuEvxWmNftCbWvvSWvy2voZXKxITFPyQ2MwfH4WGxgvAreRdpE2+Prh4976BVcy5tg9Hx7u5Be4k/7XXsfdvoQCtLA/sqy+aL7KZ/qgOtCwvXxjDZk9YFvP2XWxmUsO/yYZ/9N/PCBx4yGsb2AQwCzOP3NNoVyeGYvCcH5PgRU5kM5iM85bXv8UcSyHwJS/ZD1YZ4DnF9HsI+y9pmqS7NCdNb3YR3FT94+VZvKE7gjPHBPCjhFK/kb9z0bDo7Fj05xJHK+/rLRbcT6vDf5oRHSw/LCd77DGQan6Nxdks7dgXR2laSzS9AZFPUaGf8aHX7HdJRsfIcwi9JBHePcQFUH3VpEp6pcB+cGHhc8JDZzzjEj79nWfOMFH3rvh/nt+hSn2qPPYx1erOcE/JoMes9LaYzFxXpZsttEslMH0HyyM/h/Pm6k3iUe2bFto+9/hMpQHnw4TX3kr0FlDtrgO4CmLoPYXw6g+S542hsOoKmxTvlGPoCmPsypfBDnBh7p0CaON9RYnhyuOij9PXK46rytN16y+bprt2zece22V1649VU7t27f0QuY1cjBHp49MV4NlfU06O8JVPYQlW8UcPj4RtOSVxwER76Gf8C190IRy1EnulSUwVf1YN2mKPst+I1lSMf32UHE9VhEXPyJivoqz2w6vqs86082Z9PxfbI5K1p5B0UreGw3JFox+HdAtPIuilZw1OCd9o8DPifgOdIz+PdSpFcw6yYjPV59R1/XSn8n7bwtQHbo07Jk9wqQ3ftIdkibbRvlxP4F+/tJKkNZIQ4sc86/Oq8igjHYtRAc6Y3FrgV1NU7Jqy+GIz0VWap+wEgPZapO4vqu8nyIytQ1FsqfPU5leT/ZjG0KifRMtx4QdKzsUSh7mMo+Jtqc2N3jZHf4ueiN1A4rw3bgO7aRjYIfReeD6e9eauPvk68reM3TyYNEx3Ag7scK4g61y6y4AfkaEGW9Abz8x8x1h//77h/e1aD6xgu/mwD4UZcRfqOALznmPHcQaDiibWU4Hj5GZX1QZjwkWctVxF/BlaHnhshP2T6W8aco88aaiOvhgrimu9F6hbZj9od+5EPp70HXbtNsJwVtMHi+ZfgHXLsMioxfyvcqn8U+Aus2Rdmb4Tf7lh7xboIH1wMRcdkYoPqZ51sPCDoPeOjcLXhWdHaVpLNL0BkU9RoZ/xodfsd0lGzGOrP+wYh0UA9aROdDEel8CGB4vpU1Z/gOzRnwGvKQOcPwHADmDP/qiV2QR6yP48vDoh1M7wcUgxQcW+R8i3dXZMnu30l2D0NZiOwM/ofHjtT7iUd2bNvqeis13/oglWGcwDmlvPMtrL+/zbfUGG/tK3iTx/B8S+Uj88y31E1RPN9CP/swlal5tPJnHHOhffN86+EObeL5luKvjoXCYqHkOQ3guCxv/PLRiLh8MUodC42mU8dCrhCdIrHQymNH3qN/zxsLvRfG80PT31XGQkemNMYzFjqaZFc0FtoJsjuWZIe02bZRThwLqZyOipN4Xp/3VBLWH4MdusGx0Fjs0FXjVYwTgcl/nW7uVLFQ1q5EXi9XfpZzz2o3oPJnj1GZLxZ6qEObfLEQr7tj3phhH4T2Iux6sLMbjs2m9WHi40Eo+wiVhdon4kD5oq9A+G3UBoPflPKd5Bq3X6ZxTnBaR83/qNyntWMi0LWyHPr7dMLXCy4boYP6kjyYN0V9cc4fUxn8hwU86hzHhh+GMo7nlD5ifGH6qORlPFYhL+QhRF5qDSxUXmz3KK9HCZeKf1GGPnkZj1XIC3kIkZfa4xIqL5OBktfHCFenOc56gjfc/U77BN41bfDbwCfwrTw+H/+gwI2+sUE4sB1bRTsGqQzrJni3HP7s77HK83CsqW7cQf+N+yAQ/g0wbtxCslHjtG99S+U4fDtJcRx/MgDXwx7avk8BKtrIF++R4b05Kt5QfsBkU9IP9Ck/gPkq9gOqn9SJJ5+sVD+pNXfeGxeac+KbFUJzTnjS4paMOQm2I8tnsz3gfIbnOmqe4NM93xX9SvdUjlXZP/sNta9G2RL7Dexb9htFd8LvojlqFTvhWb97ndbvrB3unwDftjvDt/XlxPkAjEfrwUad0+vtJX1Br/IFaO/sC3w+OHny+k22W9/+VbVujjLlmMBk1C/gER/vzXssMCbw7S735cB98z6zh0Tuf5Hy0WkP5CdJ99RtDr49kAb/V6DPT9EcL4bf+BCVqT1avjFH6ZnavY9jKNczP1By33lwLoX3nZe9sT10nSfGJ5eT/9TJGdUPmEvpdHrTfNVY+zWUU4hfU2tNag8h2zP6CPYDas+rWotheugjMBb/i4wcNLYjNGbB/PVKsn+0L7Z/tHG2f9R3jhtQhhw3qE/GoQ/CMRvh/wZ82PdJNkqXfXGs2sOqPr2tTqd9OgDXEx7a6rT8pz201efpmRfnsm1S2aLJpor5BsYFbIuqn9Q5FZ+sVD81CR5lk9d2+YQYju9s16jbeBL1+xnjNrZD5Xg7nU7/pGcNqZtzBf8Jtjv5uNE461xBO591rmB02VjmClg/Y+UKeI9YnSsY+Z2VK5if9kU35wqOgP2OizJ8W95cweIUT50rGL9cwSrog/HMFWxI+eiUKziKdK9ormAj6PMx6e86VyCfOldA9OpcwfjkCjaQ7cfKFXyH9qDvLbmCS8GHvYxkU+cKsm2yzhXks90YuYKXZYzb2I4iuYKjaOxGvofP6rhsm1I2z+f11afduf+ycgWGt5fgd4Dtvo1k4/t6dPLktR+eMyn78eHy7TFSNyI95aGNfPEN7GzL6gx9heOotF20T7Zdn89MnhBZqX5qEjzKRp1D4n1vOA7xLVE4DrHNo27juMv6qfY2hY67uNeI7+94ogNelqfvSxZq3FA5FN8ZMWX/7DfUrW1K19lvWH+iriI85woM/nbKFRS8cVXmCvgLAXhvhdJvnlsZ/EfAt70/w7f15cR5V2CuwPqxipga7Z19gc8HJ09ev8l2i33Dd8aE3uDGdtbvdAyRdUPrw55cAfojjjPUTZPKH7EfU/cpJXL/A8oVqJs8E7hHSfdUXh99Duuewf8x6PMTFG/E8BufpDL0A3wzpxpzlJ41RX0cQ7me+YGSNyUG5wr4FvuyNzmH3mIf46bq5D/1xeCsm6OVTNVN5r5cQZV+zbce0kmuPHfHNrI9o49gP4A+gv3Hkx56an6HPsLnI0PnGxizvINyBSrHqmyc7R/1neMGlCHHDZ8BXlTMg2M2wn8VfNg/kWyULvviWHWjP97Gz+swvq/9Kly+PIX6Ss7nPLTVV3KYF+eybVLZosmmivkGxgVsi6qf1Bc0fLJS/dQkeJRNXtv9DJXh+M52jbr9FLT5nzLGbWyHyleqeADH/Edp7K76FuessTsrz2d4Ofb9Adhuz/GjcSr/rG5AZv+B8OrLe775ug+Xb33Mp7+KNvKFdZk282n1lO2abKqw3ZjzAyUr1U9N127XbIM4//at47F9ht4oPSoHRvrZ6Syrb9zFdWW+1d237yJ5WJ6+PKvSPXWDurJ/X26N/QbqKPsN9ZVNtjPUVYTnXIHBT0/7ouSXfGSugL9eh/kMpd88tzL4FfCFglkZvq0vJ865KZ5OuQLrxypiarR39gU+H5w8ef0m2y32TcheMPV1GbazfqdzlrjnBeGXQB9wrgD9Eec1Q2+4571T6isbidzPSPngtZjkdwvgDiHdU3l99DmsewZ/NujzYenvmH6D85YqZ+Qbc3xfzVXrAkqfzQ+UnEsH5wr4q08FcxPerz6p+U5JvzmcK1BzHNUPmCvo9KUzX66gSr/mWw/pJFeeu2Mb2Z7RR7AfQB/B/sO3j0HlwtBH+HxkaMyCa57nUK4A7cu3Lsb2j/rum1tz3KC+KKzmXPyF3wvAh11BslG67ItjO83XOfep5us+XL48hfpy7Oc9tJEvrMu0s2xS2aLJpor5BsYFbIu+HE3yhMhK9VOT4FE2eW33s1SmvvqobBdzYFdkjNvYDhy32Xaz8oeH0NjtW1eM8TVonlv/NvDC6/A8DiD8dWC7byTZ2JeJnQvTCfUlZPy6Mfsp1IkvBuDy7QnaI+C/6KGNfGFdps18Wj1luyabKmwX7Y1tV/UTwofISvVTk+BRNlam9tkoG/xtKgv9MvXnoc2sn2r9P+tOHrYH3BPEX4dXvtCne53GLNY9NWYp+2e/gfbPfgN1lP0G9i37Df7iOMNzrsDg30W5gj1Qp2yuYA/x+AXgQek3z60M/gHwbe/O8G19OXHeGpgrsH6sIqZGe2df4PPByZPXb7Ld7oEyzumovAPKlHMFJqN+AY/4egn+Hk+uAP3RF4h39Eccg6jcsfJHmCt4mnIFaLstgHuIdA99GvuL5GHdM/jfAX3+IMUbMfzGZ6gM/QDH1mrMUXqm1opwDOV65gfMr6AuVpErMPwDrr3NRXIFyv5wfOBcwZ5i9IZzBU8LeqofMFeAMt0Dvw2XL1dQpV9DOYX4NYTnuTu2ke0ZfQT7AfQR7D+e8tBDH4Gx+NNk+8pHhsYsOD//euqIlI2z/aONs/2jvnPcgDLkuGEP8KJiHhyzEf6PwIf9X5KN0mVfHPslAf80wHyO2rMHyr4UgOvzHtpfFvBf8tBGvrAu086ySWWLJpsq5ht7EADwZvUTwofISvVTk+BRNnltdw+V4fjOdo26/UVo8//NGLexHThus+1+TvCK8cDeliv4Dtjuz0g2yj/7cgV7BLxvvo4+bE8ALt987WkBv8dDG/nCukyb+bR63ZQrUP3k87FKVqqfmq7drvdQ2VjmCn5WUa7gwX08VxAy5qOuIjznCgx+4IRn/7X4E3WkbK7gaeIR8xkh83qDX5zymPTx4AkaZ2iuYDhHluIZz1wB2jv7gj1Q1iPg8/pNtlvsm/HKFSyAPvDlCjivGTtXcHLKR6dcwRDpXtFcwTrQ52Xp7ypzBegHOFegxhylZypXgGMo1zM/UHIuHZwr2JP+HnDtbS6SK9hD9LDtycO5gqeL0RvOFag5juoHzBXsAZpI33B1Y65gD5SF5Ar2QP2iuQL2H0VyBSeT7cfKFXwgUq4A9Z3jhj1QxnHD08CLinlwzEb4s8CHXU6yUbrsi2NjzNd9uHy5gt8R8F/20Ea+sC7TzrLJsc4VPI0AgDernxA+RFaqn5oEj7LJa7tPUxmO72zXqNt73EibL88Yt7EdRXIFHA90+q49x01qj5VvftJp76hvr9FnqUzt1Wc66g6w5PdN6W/ea7Q1MKY22iX1fWrV+2g6zQf57Az6bt7zgjLG80g8NuAZlzfR2IC5KN6T4bvrgetiH/RnwPN+MoPfIWJ2nz77zn/l1WdsQ1l9RtvYSW01+NePrT5PGW99Zp1FfeackNLnhmv3YWXyOdd3of7/5n6k/+/tcv3fA2Uh+v+0gN8DMKz/T0PZeOj/83Po/x4PTaX/1rYs/Td8HPff79F/JV+f/ndaI/Tp/5eoDOs9nkEH9X8PwLD+G/yHAvXfaFeh/ygj1n/fvCl58s519qS/Vfzu039er42l/6fm0H9f7K30f0/6d5b+Gz7Ol3/Go/97BA++c4xPC/g9AOPT/6epDOs9nkEnK55n/Tf4PYH6vyf9XYX+o4zKzl875Rk4nkfb8On/00Qnlv4fSvqPZ9w5N5T3HLvv7gprhzqzqc708ZnNv4Tc0D/SHFnFSL47EmPMeX24fPbZ6W4Mpq3uxmBenODT6lV4/quv6nOtSlaqn5oEj7JRtsVn3EPPlfjuysPzYqyf6ox7qO3iGfevHj0a76c64M17hyvfQaPucFX277sTIuQcu9J19ht8BxLD81q0wf+I1qJRR3LoulyL5rtq8By+0m9euxs+t/qcZ/9N+vinGb6tLyfO/wocZyPdVdNb9V01nfwm2606m9agvxGXWr9hO+t3eq7L97IMj2Fpv3Zai+b7ONR9Tcof8Zk7tBlci16R8sFndJPfLYCb/JzR7S56F+Mq0Oep6e+YfoPvw1J3HfjGHKVnTVEfx1CuZ36g5Bnw4LVowz/g2ttcZC069H66kn5zeC1a5QlVP+BatDpDi7h8a9FV+jXfPT6d5Mprw9hGtmf0Eb67d9h/+O7fQx+BsfgKsv1O9+dwzKK+8fTMPXtpzKJsnO0/7zl2tWeO44bPAS8q5sExG+GPAh92OslG6bIvju10zpzvD1LnzH24fOfrfWdFFW11bod5cS7bJpUtmmyqmG9gXMC22GlNNkRWqp+aBI+yyWu7vL6tzrEr28X8++kZ4za2Q92zoeIBHPMn09iN9H1jt+8OGr5TAe2a76dRawzoZ7LupzgfbHczySb2/RQ8Z8p7P4XvLr5OfoNp1/dTjIZX/RRyP4W6r0XZJ+cY1N0p6u4knNOxfnb6pphv3MW7ZW6hXIFayyxzD6TvvlreK4r12G+Ejuu+u1jYb3B8yPCcKzD4bWlfWPyJOlI2V8DjOJ65UfrNcyuDvxl82w0Zvq0vJ86dME/15QoijeO9VY/jnfwm2y32Tci3ilCmnCswGfU7nafg+5cN/qbAXEGeeEHl75Q/wlzBA5QrQNttAdzbSPeK5qkeBn1+B8UbMfyGL7bmfatqzFF6pvYG4hjK9cwPmF9BXawiV2D4B1x7m4vkCkLn7iX95nCuQMXhqh8wV4AyVff3+HIFVfo1Xw60k1x57o5tZHv25RPRR7D/+KSHHvoIjMUfCJhvhMYsON+4mXIFvrufQ8/Jctyg5nM8bmTtaco6J/so+LA9JJvYd2rxPvy8d2r5cux7BLzvDEB9p9ZoeNVP6syJ704tn+1yjgHHd7Zr1G3cX74nY9zGdqi1EBUP4Jj/Nk+u4DE3uixvPkDZPMdpKvZV3x3g2PcPwXa/UXGeL2S+7sPlm691yvMx7TrPNxpe9VNInu8xKONcQah9ss2jbuO4+42KcgVnU65A+QSf7nXaT8O6F3qGhP1G3nyA0nX2G9afqKsIz7kCg/9XyhUUvEdK5gq+QDxiPkPpd9aZ4MZzn/036ePvZ/i2vOeMfxiYK4i0fzv3WVCfD06evH6T7VaN8Q36G3GpM2BsZ/1O5yyzzgv83JMrQH/EeU30R5wDUXe7K3+EuYLFqX7xXCf53QK4nueObrfK66PPYd0z+CWgz/3p75h+g/c4qZyRb8xReqbWeXEM5XrmB0rOpYNzBYZ/wLW3uUiuQNmfmu+U9JvDuYLQ+/cwV6DmIojLlyuo0q/51kM6yZXn7urOF+UjfGsY7D98d/Wjj8BYfDHZvvKRoTEL7ldYS7kCtC+2/7z5ADW35rhB3Ser7ibi+2QPAR92EslG6bIvjt0j4NV9Pr75ug9XmXNPvvtCsC7TzrLJCu+b6Kv6zl0lK9VPIXdqhdou33mn8gHKdjEHdlLGuI3tUPlKFQ+MGvNp7N5bcgVngu0+n2RT5wra+axzBaPLxjJXwPoZK1fQW+cKcucKrk77optzBb8Kvu1lGb4tb67gFSmeOlcwfrmC10IfjGeu4K7AXMEbI+UK7gF9flOdK/A9da6A6NW5gvHJFdxVUa7gv4969vfelit4CHzYU3WuoI12lk3WuYJ8thsjV/BURbmCN+bIFSBvvnlE2TMIuCcj6wzCl8B2/xfJJvYZBN/+x6rPIPj2XtVnEPx3+/nOIPhyBTjOxTiD8L8CcgXqTOGga7cHzBV88ajReGOfQfDdO+I7g8B+w5d/GOszCH9PuYKCMX2lZxD+C3zbP2X4trxnEP45MFdQn0Fol2msMwg/DswVcJ5D5c7LnEGYe+KzvzudQfgZ6V7RMwgLThyp9wuKN2L4jfoMQn0G4Rnk6b/76hkE9BHsB9BHxDiDYD7C5yNDYxY8g/BJyhWE5gp963VjcQZhCHzYMSSb+gxCtk3WZxDy2W6MMwisn7HOIPyMxm61hjnW+wrU+UyOfdeC7T6PZBN7X0HIfN2Hy3e3Yaf1MaZd7ysYDa/6KWRfAebEeD9C7H0FrJ/qbsPQcRfvNnwj5QqUT/DpXqd9Bb47SXz7CthvdNO+gpekfdHN+wp2gm+7IsO35d1XsDXFU+8rGL99BddDH3CuAP1R1fsKbqVcQda+gteQ7hXdV3AH6PPr0t8x/Ua9r6DeV/AM8vTffXVfgbrLrKp9BbeS7SsfGRqz4L6CnZ59BWz/3bSvYBf4sCdINvW+gmybrPcV5LPdGPsKnsgYt7EdRfYVcDwQet9pg/hFeN93aZTP8e1XULGQWucM+b4Ctm1T+i+v/XwuMKauci0eZVT22wGd5oN8165ar1H6bjQ73Xv7IhobGgB3JfHacO28NkTbmhn1FS7slzXw+2goR/i/pbkkyjNHv24YhDoOcCDugjqzAdtqj4onMXZS9JJnQJT1BvDy5RP2nHf/z9ZMaVB944XfsV72CfgrBbzJqp94b7mg5zxlu0bbyrjtWIb2ZzwkNruK+OsryF+I/BB/U8BvBLg8fTHdjdYF1HezV7yj92Eq830zQ/lmX86Z/Rv6bfwOCK/ZG/zfQyz304CxEuPnKr5N48Pl+w5tpz1uTFvNZZkX57JjgArvjO+r+lsYSlaqn9SaLeeSHoYy/h6Vb1+H+vaNbw+a0s9Y37Q6lnLHKjbz6V6n2Ix1LzQ2Y7/huz83b+6I7Qx1FeE5dzwMf9Kz/5bcDyJzx7zn9LPAQ55c24KUx6SPDzhJ48ybv5uU4hmjOLe36j2nnfwm261v74H6npSaW7Gd9TsdY/O33Ax+NvQB547RH/HcUp3vUP6I43e0Gcwdn5Dywd/1SH63AG4R6Z6aY6HPYd0z+BNBnxenv2P6Dc4roR/gdQI15ig9a4r6OIZyPfMDJb8bE5w7NvwDrr3NRXLHyv7UPLOk3xzOHYfmqjF3rNbCEZcvd1ylX/PN3zvJlXO5ai1V+Qj2A7698U966KGPwFj8BLL9Tt/c88UsnwK8h1J+AO2L7T90n2lIzpnHDeXDeMxG+FPBh11MslG67ItjO617+tbCvhCAy5cf6rTHjWmrPW7Mi3PZNlnhOk5f1evTSlaqn5oEj7LJa7ucHw7NOeO6z8UZ4za2Q32bS8UDOOYvorF7b8kVvARs94aMeNq5OlfgqF6dK2i33apzBayfsXIFPzlyNN46VzDyOytXcNNekCu4A3zbmyPlCt5a5wqGy8YrV/CeLskVPBmYK3h/pFzBp0Gf76pzBb6nzhUQvTpXMD65gicryhX8axqz7G25gi+AD/uLOlfQRjvLJutcQT7bjZEr+IuKcgUcDzwi8D4h8DZcux8K2Wem9rGhPPi72mr/krpr5+EMOioHkTy8z8zg/zYwpjbaVeg7yoj1XflshGd5+761jDJR+xz5rBbK2Ggaz08InAnvX6Wx4VGA+6gbXfYxKHuMynCP8+NUhjqCfGA/oR48ADCGt5fgvwdjgzt5NE6lwx+Dd9wHvj5DfpReh8xrHvXQ7tT/TFvdh8G8OMEn6oPRsjKTTRW2gv6HbcXna5InRFaqn5StcFz3USh7lMp8dyc9DmV8xhJ1G88msn4+KtrxALzjseEBwesz5wcoF/Vxgdene76zl0r3Pibap+yf/QbaP/sN3zfhsW/Zb+B83wl4zkUNn4tI+8LmN6gjOXRd5qL4fMUngQel3zx3N/hlKY9JH0/P8G19OXHOSvF0GjetH6uYs43luMl2i33zMcL1MYFLzd/YzvqdjpEMXy/BL4Y+4FwU+iPeW47+iMf8xwVd5Y8wF3Vqyoc6n9QCuOWke+jTVCzJumfwZ4A+H5L+juk3OCZFP4A4ssYcpWdqnsAxFdYzP2B+BXWxilyU4R9w7W0ukotS9qfOy5f0m8O5KDU/Uv2AuSiUqZov+XJRVfo1lFOIX1PngtQZJ7Zn9BHsB9BHsP943EMPfQTG4qeS7SsfGRqzfAzwvpzmG2hfbP++u1pR3zluQBly3IB3NamYB8dshF8PPuwlJJvxuJfSh6vqey6YF+eybXKs5+YYF7AtdsrJhMhK9ZM6A8ZrYaG26/suO9s16jbme1+SMW5jO4rcsbKcxu47Ae49bnTZ3VB2qBvNzy7BD8LfTvD3pH/3Z8Abvl6Cv0bEW1MJJvm9OoMe8ofvOEbA+vdk4EJ/g+17WQbvrxTxuuG8V/C3WvBn8LsF/L0AY/wo2ex2mja2ZxfA7KT2GPyOwPmH6VRJ3zBF+QaUG/uG3VDWI+BZpvcJ+N0AYzJpEjzK18reA2X3Uhnazt3Ew52Ch9vhHds16p3VTeTw/MOe/W39fxfAdaNdvzXQrt+fQQ/589k11s9r16/O4P2dOe36/YK/brLr9wbatelUbded7fouwUOoXVvdRA5nHjYa74NQ1uPabZ372ODv8+jsQ4JXlCHL92EB/5DgfyrxgHWninr3UxmuhbDfeUTIAeHZdg3+QyCH7R5dN75K6vqg0nVcI2Nd/yCUqTU17osPCfgPAozJpEnw3C/4N+LCvuYcmsmo3+k+MHy9BP+kJ4d2P9TndbPbc/J+l+B90LXbDNpUMzVq08H7AG4X0XzAQ5PrIp3+DHjDx7b7BSEv9nVq7S15NhBOg3/a4w+ULO+Gd6yDyn88KNqlZPoQlWHOwXRB2afBVTEWYfvZPn1tTZ6ivlKt/95HZWgbrP/3CTqh+o869LNVo/E+AGWG91aoe136u5fgv5pTv3bDu7z6ZfwoHWL9wnr3Uhn2C9vuw0IOCL/NjZaDwf9N4HhjfJXU51OUPqMOsj6rvSgIz33hG59QJk2C537BvxEX9jWPN8p/PiTws//8J894g7E2j5X35eT9VsH7oGu3GbSpc1N7Mx3cDXB3Ec37PDS5LvqL/gx4w9dL8D/wjDe7gXeOFRtu9L0yCP8jjz8wutiuD8A71kEl+/tFu5RMfWOR6YKyT4MraZ+nKvvE9rN9+tqaPCwb5VtRd63/m67dH+6mMrSN+4nObkEnVP93Q1uPW6XxZo0316a/Wb/61j77r9Kv+1w7r5jnYBkqfUQ94fFmN5TxHAbr3U1lKFPOTahxF+E552jwU0AOvvEmkj7PUPqMOsv67NPP5Mk79ptMmq59PNhNuHYLXNjXPN6YjPqd7gPDx7H1POgDHm8wT/AA8X5PTt6L2Nt8Gm9wTsPjzT0emlwX/UXWeGP4OP+0RMirQTTQDlBOPN4Y/MEef6BydL7xZreAv1e0S8l0N5Uh76YLyj4NrqR9zhzvXBuPN+gPOQ+HtnEv0VF56VD9Rx3qo/GG83SIC/XCp49oN5PT36yPJ3j00WdnycMyV/qLesX5N9RHnvMg7z59jJT7vUTpI7af9dHX1uTJa6vWn03Xrqs+feTxWeV30YewPqIeYX73p4eMhsM1wEb6r+2d2Qrvc8h8QoPwGc/4DvEPEC856Q3vR9pK9Lh91neJzcxIf+/cce111+64cf22zVtO23z99p3XbZ2AqF37ihVKBbHiu4Yb3Xos66F3kwjuTPp7vajnBO4eoHs1lClJGE6zSmzT1Rn1UBZOvJsg4LcSrq2invHe46mPOLAea0yD3qPXHBS0ewn+UvCab7gsm+6ga5fDIP29Q9Cr0Oqm7x9WN42wGgzC4jMNOEP4SfQ39+gGUY8fk1gv8bwl1aJE+zanv63nD4K6tr/WyoYAt90z+8x5LsJxKPGg/kXe8R2PXzE8Ba9PJs9FVO9qqHd5AA9XC56bor7BDYp6RWXT9PBsdNCbtNLfSV+9au3I++S/a6BMeSJePzX4fwAd2pH+NlmixRqPSs4vdqN5ySvnFws6Vcv5xUTnmoh0rgGYFvxO/ruFcLGcrZ9Mzi+Hsluo3ruhDOFwlLsF3r9b0Fb4DUcnHbx5rW5blg4arV6C/wPQwbeTDqrRlEdf9/+39y7wepXVnfB+c04OOeSQA4qfUhw5SuvXirYUpEWnwAmQECDEEEQiFCtIBBS5CAhYdVJpvVSrCASTnFz2SUIukAvhIjfHqWNtbes49rOfth17/dqxw0zbr/xwnGmtTjfZ65z/+3//z9rPvp2T4Pv+fvlln/2sZ631rGet9axnPZed+DrPejkUgP9p4s/gf8OZx4+INiNfvE5p8Hc586YR0S7lK712oU6NBNp1r5PPUVGIGltOorJXQpn5cBxbBgnHRP5+XtLbHyWiBHnmKcQ3whndE6rRjZ6DGP7hpFeGVaKhE4get69aNITSZ6kgVnzXSbpbj2VFc5Bl9HeVOYjyAq8QOM2jqLie67EV8rs5Av4EwqUsiL2zqo84sB5rjKqX/T1f1ImxgIrx+UCsBRj+piygqN9NV63tqwQvo6LscHjGMqSzStBRuF5JuF4ZyXPWhy/On3OrveiWG967KjfbhH5Fk44TAmzMEfUTqsumzYH9K0ST0HSWBmiHBmHDN0jwT4jByqufJHFqj13UhuM3/E2pfawK8SQO63qDfCfp7cMZUtXstyzAhhpREsLVEe+yn4ol51G9mVLj33Firnmi/vNx5VHdtIvibJ7rGfxXnZhTzQ28cxufEfA4HzF+FhAPWHeBqMfzTNynfA3xcHfSKweE572yBv+HkWvJxlcbe2XvBgBeG8A1kgEBz31xr4DHdSKTySjBc7/g34gL+5rtwGQ0lOg+MHyDBP/njh3gPP1u4v2akrwrG1bzWrSpX6M5KNLkofTdDk2ls0Yn5DdCc+T/5sxBVe4H+eI5qMH/D8cfeHmK7Mc6qPzHp0W7lEzvojLMSWA+yHAzzjb2ymL72T69tma/qr5Snc24hsrQNlj/rxF0YvUfdYhzi+gvDO88gdfgbT+76TjDYH8h/A9BH88ln/BKqH8vtQPPn3Ty/y28u494H0uiftHhneEfJl5K0psK7+4jety+avN6jnZQKogV33WS7tZjWVEUdzb9XWVe/1koU5LgeT226bOBeqy5/G6OgL+PcN0n6hnvA059xIH1WGPYitCr3ytosxUdecaB/9XaItLFqIF5sb9XCXpmdZ8l2CSZtrq11KaxJOq3MtbqDP8w8VLV6tYSPW5fNatDTUEqlxBWg0FY/F0CnCE8T/O5964W9fhnEhsknn8q16JM+34sf16Q9Grsq4hv5MHzX6OiPp8JRTrH16RzvKBjmjwMZbxWOl+01VsXUfHDciq7S7TLyj7j4LzbwXmPKMv6bu8Z3XDojTqB/7PfgHjHMr1P8Gp9hx4AUx4ha1vr0MH6Bjci6tVtj+KZYwxsaybf158x/T77h2fX1WhgcdYgwf/Uyul6P0/2hndZGI9KzmyLZeX8KkGnbTmzTa1vkA7uTRuD5+zfBsLFcrZ+8vYTWr3QXmOMCNTdAYhD4TccRTq45AzdtpAOGq1Bgl8AOnh+RR1cT2XYBzweensNsQ+4XUMB+FC7VkBExLmG+0R9xTvfw7Le4T37efewGFzbOv/TRCekP5eR/uA+TqU/nKMw+O9dMl3vbaQ/GKG10X7PrjGS41mDsjuWpaqHNvqzETyoc8ajoj7uVeZ6dXVD8VykG9eRbqh94lj3uvyZ94n/BejGDaQb6D/5LBHyzDFgWTkfL+i0LWeO7zY1SAf3bo/Bc/YvJVwsZ+snkzPuJU+p3iSUIRyObym8nxS0Ff7Y8W31GbptIR00WnyW7sugg3c6cxpPB70zMXymQp1/UH3QIb6HAvChc0a/LsY3z15Rb9iXG/xvAM6Yc0ZqtuzpYtlzRh5tlPPSAO2hRLc/pCv3OjJV9ythe1imBv9ZR6Zp0tsuT6aTAj4V7VLnsyYJl8q0oZxjZIrtN3ws001OHLZe1FexA8eQKg5D+HcTvLIxFZuwjW2LjCE5tsHcAu+Vw9zCOirD3ALPxTDvP0FlmFvgPAfmFnj8uxvKNlKZOuuIuYVBauv+/H3NHLzc03cf8TYM8J3A/0kSN55iXx1OdNrKmzCdzzZIB3FZRl7N2XhNs2zeAOt7c8P5NenMF3QYF/rkMYDhPbAG/yWw68Xkk9UdhvPh3VKnrWzPiMv6zOwDfV8ba1SGf5h4KUmv4/lcbB9vQZoQvIyKslCfIp0TBJ2yfM3P6We/PIt/9qorb7166Q142uD53yD9vSjA4rEEtzTAWkfg7dA/fn8svRsQsIh7pkxvNum8tiad1wo6bac6X0t0QtOdPy2ZUuYrMwz+EZju/IUz3QmZHeqatxXO6IWW+0cC/P0NuN5zI45VvMvheR3QYLrZ88kBHp6hUKWiK5ahCqdCkZ9hKsPQg6+ExBBnQLxjnVsj6DCu0DBpcuWQ7h9LDpPeQj3ytI7KcGhiOSg6yr0rOXh0XleTzusEHW/Yr+pLFM9qKjGWP2d9/APyJeuhTIU0vFXM4CfBl3TGDzwrX4I88t/KL4fGyZAvWRvgb2j8wP/Kl3BoiO1UPOMUkOkqX2Lw88cP/G++hJeCxpK4n/IlvDSB/JxI/JcdC7H+TI2FJxKdtpf9VLqf/Ytajppw6KgltSJ7PGZc01T2yOMawl8L9vjy8e42qrE9Zqmubd/LuGLHIIP/8fED/zcxBq2N4G8w6bWp7PlnoM0hXIl4Z/A4/nH6Yj3BrnNgQ34re74+f27bvuwSEWVfryf+ytoX1o+1r5PHNc2Qfd2UP7N9vRns6+fGu9uIywEsV14CQNjFBLsR2h2Ldy7VzX7LCXYD4UWdfGvS3d6p8X18Gv9p+fOIoFVXdzC1z7qDKepT4BnLjA6/YzpY3+DYFlh3Fo1rmqg7WJd1Z+ozCuPT9ZaMh9vIadYm5GzvN8N7pstLkCnBYiqf08Sbqa76v4hHdQ1nSngnHf55mX6jqNf2cmtKdNIG6aRQdinRCenupePT71EOId29LX/mKx6vGJ+ud3n+rLbDsO6iT+UtlCr9l+H/8ng3z1sAzuR0mahr8FsJHnFkP55bbMv/Ds0trC5fs/zO8QP/49zC2jYp6GVtu2Zctw37YxJobyXaBv+R8el6786f1TWr1h/qqnC2AfwsAMMuDsjg5vHpOjeOh2ml+fOI08YMx63jYbjFAo5xzBEyMBzKL1g9dX1tmnTT2EI0Jh0aqajnXcE8J+mVmbo69v6CcvUZgkS8myPgtwTamwjaWwvwTgo8yr9vpbJNoox9F7Y39gpC9HvmE71rie3vbdSuLU67Nol6bOfI+6TDu5If+g8vbrC/Y8b6jvjb+LsZ3rGPTfO/Q1surS4v9d89fuB/lY9JoZ1qS8ZNAZxrAGfMVdinwDteKvL6CfnxrsJWvKdJ9w/febFMInhAX6h0NhTHsTwUD2r7jfKbKfGj4vBY28R42mLtH7U5xq5xTbPsHOMMmJ/uHg+38VCYY3DO/GCYY6wjPP05RpJ8YXz6Pcqh7BzjaNDdL+Y4y84xeCtV0RzDyky+c0Q9Pj5g9J4Zn8b3FcI3H2ih3mS/5QCHujgo6mfPvK5g8F8dP/B/Nu69KR/3Foj6v0D0cF1HrfWwTvyC4CvUTjWGsdy+M37g/3lJry2WWA9Z6Om/4Z6siDvGfpTNI700fx4WZYMRvFz/vStOvmLo/b/LdmW88LuYWOYXBLzJiufNY0nU77QRoJEQbVzjT5JemWW/uVBmPGQ6/Rrib0tF/mLkh/jV1f23w3OZvlC4Yj5zFItrXUVcRyXdOop2qPw9525Unjnrx3kLDzwrP/RG4rWsH8L6ZfwQr9tMwea8mn7x8bqxJOr3ei8+MdxpRdyxfijNn0eScL8Oi7IYP3TN9xfe+B9XfOPfdJJefzsg3sVsSX+jgK9p5ycqP8S+Bv1QSmXoh4wH5YcqjiknxsgP8atcEvshD1f2m+PgmmgQ17qKuMwPeWsL6Ic4vlNHbNEP8XrW6MJpmMMXduPyctUqfuMYU5VtEDgz2q9YOF0H/dVQ/v+FUMbrgWqObn/jO9R1rMPr6Ab/UpDN0cQfrmVjO5E/1V+4x+aYhWG4jQ6cF9+rdXAv9o/tFx4rXkljRcWLTOQeHsOV0fq/8ud8+/E5q2656Jor3rvqqotWveO9q24ZAEzIHWOyv63VWI9/xgnvPL6H/uYdaxP09waBp4im2mFyKjwz3ZgdJqcKnmeTzmk16Zwm6LS9i/A0ooM7U8by58xaTlw4/R71DWf+uDtlRf4/e+WFF0/XOznHqSJIljNa4cKkm5eyu92w/to+ncbpnFmTzpmCTtu7Ec+k9qCNsNzK2jXWXzfDdIrsetlCTTPWrg3+uTdP17vQsevQrn1sY9kDVuyTQrhWEC6s711asjaCjnfxR+zlKDHt8ejMZnsMl9rhh33wZocvnqVsKMB1EeFSF3koHWSey2YnsP58h85ETToTkXRmqj1ratJZE0lnYU06CwWdEVGvE/jf6PA776TaQqIT8re3kb9VFzWhv+XTGAb/V+Bv30/+Fmc8L3Q5t7VqPEZ0Qv35EepPtZrr9afB/x7058cj+lPJJrQrEul6fa0uzukIXN7ObZYDwqsxpcWMavRnCtP8eZh4KUlv6nD0JNHj9uEh5KPz5zwLsHDVzT970qln/2sK4I4bbwllV49Eokn3yjrCJ/Q318t4GySY+YJG9mP92Uhw3O/2nvHH8FQEW1SufN3mQDuTJM7XYf35AVyh0yxp/syZpomFB/5Xp1lUTKYuZPHiAbUij3ADog2HB+p9MNH8WZuRJ9Vmg9/itHmioM0cv6vYkX0Tww2INsxLenUAcSgZn5V0815Wn7D+TI2dZxGd0Ji2d+H0e5SDGtOy5w/lz3yC5nEY0/bnONUJtZlqP8ev6nrtDwFMaG4zGMDJuzcM/qm87TVXH2VGmVdQhgX/Wfs+T32q2u71qcHvgj79DxF96tmHuqzZ8wXrHHg1V1Q5Ji9utP7hHbJjScyv8xcxOor4h4mXkvowFW+oC9GwfVXjDcP759Ag5L8o3uB6XrzBsCHb4xhgA70vijcUTyHYOvHGxkA7kyRufMD6Bmf6WfEDE2PGy1rgQ+1gDp38nZP02paCVzGG2qXBvmgw0ePwGJQj/DcWHvg/iyVWOLvizg7wlyRxfYH1Z2qsOpvorGmQjrp1RuVX8eQVlhmdkI8dFfW99YKNNelsFHRidf0D+XNRTPQ3C7vxenlypMt58rfC+Pm3OU7vFiUvDxdzk0/ZjyR4dh1rpyq/fiHhKru2gfW90/qK99DNP4fliz41b/5ZrnaHmP3VjPmWx9g44le7HoyvYVEWsyvsvw3/wu/990cm/nOH6hsv/C4md3ShgK8XfyUXqF1huGMl+6GObKAy3BVmPKhdYRXjtQti5If41WXSeBqoTF+MirKlFXHZTi41x54tnxTKvZh/4tjhiNz2Y28SUTcWebcfsU/jNrLPSZKwHv2QfobP5H+YoMWX2Brs0dDui1d287pe8Go+YsChkYh3nSQsG6YxR9T9d0k3bxMRvKl8EOJYE+Azw6HWEFlvy95eslbwo+gsq0lnmaDjjUn8v9Hhd9565DKiE4qbXn3m9Hv0J6G4aXX+zOtd50Dc9FM5TnWbHK+5qpsM1f4Cln3ohgD2Jwb/02BXfNpV5YdXA86QnsWeEjL4kymeaSPPxG0aTHp9a/Y7N9FtCuWLWQZKT8YceLXehOtu7LO9S/WtbW9YNM3DG88s1/7zAjhPPXsa52klcZ4fwLnszGmc445tLEm66ZW9VRLr8w5cdQn3vKRXd0voYfTlxoZ/OOltc5V8msoPKLlY20cEL6OiLGafxhJBp0O4ivianzR2ubGx+FKCWxpgrSPwdugfv38pvVMpOcSdqfkf5Yyq74e/nfCrb/XiO1ZzrM/fJUY6x9Wkc5yg4+F6u8Bl8Or7wscJ+AZVw1h8OcCwl2bWGG+RajDukGrYb4BoZs98/yh3DfOoPjs/7LRpQLzjrh4WtBSdK2vSuVLQ4SjhFooSkH4Jb/lR8374SUr2/BUz1R+N9fz8eQukZ3ypzzLHZD1e84UPbvm3x1/zpg7VN174HZukmkVeKeBrZp9+VWU9cPdv9lOZMZX1MB5U1qPiJwN+NUZ+iF9lqTnrUTaDoO4BLYvLsh74mRTPlmfKZ7RBx8Pl3d1sshlK9EoR+ySD/xDMnlZSVkLJOxHv5iS9/ihHNSU3xHV6gHdF2/Bnv1FR3+Ba9Ilzy/rE4aS3zVWiYWUfSi7qnJ7V5R3q2Y/vxii7InCw40LdHEl69bcT+N/o8DuWcxMrgk2eLuOznnVwqSzZz8Ezlhkufsf9gvUnqOwzgo4ah+6mMpTbUipTdyooP8T+u6wfGhb8qfO0Y/lzNt5vO1PTxGyLOrXDfvsPzpqut+PMcBtjdlIhfCjDtXsGMlxFsttbQnbZ783UFoN/FGS335Edj/0qE652ivNJs9AnqrEsSfwdRCoTHHO/WM2Vveixr+mdVSqrqHxMzfuNBo1eKuipfjgy0TJVd52ZjSlfx/4MfR2vQuK4FvpMcvZ8EjyH/Bm2iTOzir+Z8puKzqU16Vwq6HhxYoyuKzqK5yJf9nXyZWo1Fevemj9zdnoL+LJvkC/D+sgj/x0zvzB6sd+GMfg/clZnVJtvdXhGGknSazc8dhn8n9LYVXE+LccuPu2rTknXpBudjTf8w8RLVR9ctBqPqc0X5c95anPpDVdcddYVN95863Wr5iDqJLzHsUNY8V0n6W49lg3QuxGCW0J/LxX1EoEbM57qTIi3L0Gt1atZ+RpBl9fm1blrb4+D8T7g1Eccof0iA4F62d+/Juo0eU9AkzOaFveIvTjWMg3/MPFS1TLVfiEVHakbnLwvOOBiEpYhHS86RVx3NYQr+y3v4+rj6uPq45oFXN6eMp6FZb8V+f9q4ZrPZpVduMb63gL5spp0lgk6I6Je1TF51OFZZVtYbmUzkOpsadH+uZ88S9MM7Z/jGZrB3wMztBPO6uZZzdBQBjgDwn4wHFx3HvBgZSXiiwXZLO0y+soOyhVXLIvikOx5df6s9lPzfh3Uhdg++jnqI7Xfz9vjaPAfgD56Q/6s9nHF7CNS9NgOhwLwvMfR4E/PecJVOsXf2gC9UFbh2gC9M4HeUtAHa2dCtGvq3YuV3qGfYb1TmSDlzzx/gbbFuog6zCuzau+et6/V6g8lug8M3yDBXyD6PFbPuV8Nfnlkv5os2+hXlBX3q1r1VucDPT1QK/QqU/dpwvVpgUvtY421ZcPHtnWZ06/qC+HIJ/erwb8tsl/xPKvhsbK6/Yqy4n5V8YfaP+npAY4PJhOVWb+HytAncuZa+W/Ug5g+x/4J+e93iT737gCLGV+yH2bgXpw/5xm4i2654b2r8hRcQj8vZZb9vS7AxotE/YTqdujdi6hMuU9vk5DRHkp0yordp8HfJETuud/sF7OlGru7jSSu4W9qS3WRW+NUkWdm3lRmFlQ1+y0JsNER9RPC1RHvsp/a5qxu+YnxbkpUaq8Wwhs+Xrf+FWfkUCOhd0uYitzVGp9qP9/wiPViTpOgGvGIZvAfixzRGpr5yBENZcQjmsoseCdx1Xq2ypaOEjzKXo1oodNBSEdFMWpmhVElz6yKbgTl9nryUfql9jWovRXeLNjg2pgFY3tYF7y+zX6h210QHvubo1bcW8CZJ7Qlvs1BzXpidQGzHZwJUfsSvRmQurEBh/DV+TPfErBd+ADDub6gbTEzQHXqVq3g8QlSrIf7Cgx3QnA19fGIJrMy2a+srbL/QT3jveM4FnAWR92kgXshZmoPFo/f6uZQNd7xzaFPQ9boa2Qjysa9PkgFvLr5UH1nMo3AdbdDe1LApw5t5AvrMm3mE799ZbSszGRT01bmKltB/8y24vni7BcjK9VPowSPsim7H4y/ERu7Hwy/98L6qeJF5cOV7eK+y71ku2ifPNsum7VX4xHHxN+EMWJxICYO2fXqAM4/dsadojE1Js72bhdH38dxtspKKt/HflH5a+VH2C+qb2YifOibmX+dy6/mLcJyv1VKPOIJchV78R5gg/8n8N3fOUvjnFsS5zORc5aGfN1g274uFfDo63ifagplof2GiEvtRWU7G0r0fMnw8Wrbd51MG/pb9qnob9mnrhN0vbMGmdxfdvaBZ47XsucxgPt+YJ6Fuoc+h3XP4I+F2w1+SCtYTfgNvmVIfYOW7SdJfD1Tq4L8LW/1feeae76j97TzNx0r7qF3bwtVOYOafnNqT/ukoKf64chEyzSFZ8Nlvmqm/ZqXiymSK58PwjayPaOPYD8QE5MpeqGYzHyE5yOrxGTbKCZD+2L7Rxtn+1c3h6o5AMcNKfCiYh6+9cXgXwU+7BSSjdJlL8eyRcBPAgzP6VMo2xKBy8v1bRXwWxzayBfWZdohm/Ru32tjPpUiAOAN9RPCx8hK9dMowaNsytpuSmU4vrNdo25vhjazfhblXNh21ReTMB4w3cDlpl9MummqpR18x+Ms1jc4Ree4mnSOE3Q8XL8ocBm8Wltp+XoVY/F4gMnejzmsMd4O/eP3jHtAwOJPddNwgO8kiesmtVmBcZkLz34rAIYvFcY09OWEq+zmQ6zPS2HG1+W5+c0T9Eu4t3u84+GGu+Ix/ns6hC9JdJgZOpqGfKkrBWKuUnlq54VHfOM/njp1FUjsETqDV6n+ywV8zatU7lJDGF+Xoo4sl71KpeIVEHfFyA/xq3Q4X6VS9jgjlq2oiMuuUsGhkjcSt+1jeOp6ZW7LmMKbaV5sOL5a8OL5MfWBTsW7t1mb21XWXw5H0nlbTTpvE3Ta3hT+NqITOk57C4Vjn4Eylfp9X/7Mmy5fDRdP3pbjVFsg+HATjz84RmY/tlfeFMowawP8fQD0k4/Tqja/z+EZU2hJ0usXOL07tQ2Fxt6KPlWmd/lasRau84neiTVb1/mUO07L25NRKogV33WS7tZj2QC94w1Xi+nvKsdp1Wcm7hY4vSvN1ehb5pIqxKs2JfDlfN5ojzjUop7hUPWyv28RdZq8qGCmjuaaZVY83hr92Uj+rELFqHPKMr3NIdmP264+8aCS2TyrqvrJgOx5Y4O41jWEK/st7+Pq4+rjOuhwqRnoeirD8YA/D6+ONXSoDPnzZl5Y30s8XlqTzqWCzoioV3XsG3V4VhsHWW5lLzTE+nzRTOhI5FfO1jRDR8V4JmTwL4WZ0O+f3c2zmgmhDNQZghaPmckNkihXXqRQm0ex3+wor3dER+lCbB99k/qo6DgfHy2eWhSEPvpjmq16x0KLjq3eSvDWxthjqwb/ZzBb9Y6t3h2gp2bv2e+CAL2/AnozcGz1KKV36GdijsEpf+b5C3UGRy1k8TE47+hj2SOt6hicd6TV4P9e6AOPRawbIf6U3Bo+BrcmwMaRon5CdTv07sgALsOTvcPpa8wxOHXSlV3Ed4XIvS7Lfv1jcIfcMbjFATY6on5CuDriXfYrOgbHo4onYiWqqgeo5+Y8qWNwysN6H69WkYDKzXvHAFXUc3eAjjrYnf14RDP4EWjrDBzYlyMayohHtNjMicEXbYdmU/OOoXjXHDd1DI4jNaUv3jG4omNHrF+xx468qPqFcuyIj8F5x45wOOIrllUUFasLOHv6SmCNCfGiLoTWaNEH4BC+On/m9ZbXCB9gONcUtC3G36mst3eVuLou2DuWaXA19XFE6SO2P2aW5302pshWvUtieBspjgUcRhbpjbfNE9f4bqEZH9Jh3Sv72ZYVgn9F57iadI4TdDxcKwQur79b3ipmLB4LMNn7MYc1xtuhf/yecQ8IWPypbrorwHeSxHWTUmdFZ7gmneFIOm+tSeetgg5vBXl73tk1l5vvjFkwq3iy4M4O4UsSPZsKnapAvtQph5gtZn8/evGXr3tu+wMdqm+88LuY0/BvFfA1T0WsVkMTn0hVJ93UFrM0f1ZbzCqeSlkdIz/EPyrKeBpY9iQOli2tiMu2mHmn69v2GbzFbBWEULzFbDb816U16Vwq6KiQqBP43+jwO6ajeC7ainXjoun3qAexXzYw+FPgu9M3O2mIUNiAY6X3ZQOjF/tlA4O/HXSKt2KtFW2+1eEZvxnPdLPnkwM8fJDGqIobL+RWLJ5+Ij+cylEbetSXAtTC1lqHzi/VpPNLgk6Tm2FGHZ69cb8qHfSpY/mzOuV5BTxjmdHhd0wH6084dO6qSUfd+arSQjhlUicCTWY146nBmH5B/MPES0l67teO1IK/tX2z4GVUlHEqRMVamwUdhWukQVwxNxVdIXCVlVeDUz1j8S0E9+YAawMCb4f+8fu30LvQVM9wz9RV2TNl+kXr5tsXaZqhdfPQh5j/ZfF0vV0UWiBfC6iNZXfMY31vZz4PgZhZ46ybuhK8Q2XIn3eiRK1YDAg6yv3+KH7oiId0rKuG6JhLMBYIOmX5atDNGYsnEFzoTreOwFvk5k6gdyE3Z3/PlOorOufWpHNuJJ2Zas/amnTWCjoernMFrr56d+FW3RS6MjZJ4rpJXQ0xmyMIJiWKRvk/pFFefSbQG+UN/kgY5b8FO+V4TwPiui/pLkM5fpb4x/V7HgErnkeOHgEN/zDxUnUEjN2ZVu5sEk8ZUCqIFd95lsK7YHiD0nyqV+Vsklqd+7TAqeK4zwTqoSwS8W6OgL+LcN0l6hnvA059xIH1WGM69B6t7V5Bm/dePgPpsH9H6TBFC+VRtL+QYZiHqf2FTkoObxJQ7WJr5hsB0BMsDtAfAI/z7CJN/3k4os/tQ+85FOD3LuLB4P+n2B2lPDLfXsHvUAZYN/Q3ws6jtuDfShfvJfh7CtrO/W/w/+L0/4jgwfjKfksLeGCYeQEeOot7eRBe86wbbrwjsNePYw32ctxL3BMjAk/oZ9J43tpzzlk6bB1Mx/5WGpC1/Oj8eSp0u27VLaF9jjwiDAdozkn0byTRvCXJ7G1dHalGz926iu2runU1ZKVFdGpuXQ0N2spZcP2E6nbEu+yXqfOGIw88z+b6xV016agkEeMKhcU35M/8NexjwEEtDaxbzRE4sx8nO73ts4YH4Yu2WLEs1XZIj7a3zrehJK9ejhnpq+ToppK8rphhXtcKXltcV4l2nbO1rlJuWhO6P75DWPFdJ+luPZaxh+Spwjn0d5VpTewdmerux82BeqzZ/G6OgN9EuEL3Tw8E6KkexXqsMape9vevijqeBcRocPYLrdQ1gSsVuMwyJ+F9CUt5SaxlGv5h4qWqZU4SPW4ft32L4GVUlHHKYYugs0XQUbg2NohrXUO4st/yPq4+rj6uPq5DHJc65JVSGY6ffEVF21ctKDrLatJZJuioKws6gf+NDr9jOopnddc1yy1NetuTOnSwfkrtwV2OY/nz8wdXFmuaOJPFurxD1OD/HtKtty0OtxHlbO1intv4ZtwkAPDhJGU/kwCzOn9WsQQfNsK+NhxFffAr1AdVv9H2LeiDX6U+wPq4+ytkN4oe60joM7DriD+D/zhkO1Y6O783BOihPFDOHwnQ+w2RXfEut62pdy9p+372Ij3l7S+op5yxUbvc1XcTOlR/KNF9EDq5s1b0eayec78a/ERkv6b5cxv96l1pozJr3sF3pQfq23qjSW+fhzKRiMv7pLPqV3XFI/frdqdf1SYB5JP71eB3RfarybKNfvUOsap+9Q6xpgIe+9VkMpr0jpOfJlxF+3Ni+hX7gH20wT/q9KvKcnt+2OAfPwj8MMoqpl/VSkBsv7IfTqGMrwLCsY5teaZ89JdEn6ud4jGHgkN7xhq8CmhTgI2jRf2E6nbo3dEBXIYne4dpVRa5NXco0SlQFrnB/54QuTJTtVdLHSqbrd2+FQ/iurt9lUstu9u37LDYgqpmv3MCbHRE/YRwdcQ7LCu6bsK7SgNH6D+kLXioQjxTSAVNFfkbvEWgoejC8A0S/LedUciLgrMfe+utAh4jY+9r01upDOttCNDB0TEFGB4dDf7/ixwdjXYboyPKiEfHbVA2IOBZ3vcL+G0Ak+bPowSvTBplvJXoFLkO1n+lp2r2PSnwetcKFc3KWL9SKNtCZZOCR6ULBtdGpgTbw7rg2VL2Y9l4uoOyGU2K9QTtcgvRSQWdWF1Ioa23UNZEXXnVoTKk6V0MrL5irujcVZPOXYIO44rdp2LwQ/lApvapqFVgb3+E9+Vb5EfJBu+IYNqdwP9Gh9+x3JCH+USniZVjL6L2VpWr0kkBZiPRmWyQTshnsW+oS0etLKvxqy4d9E98Tn1bg3TQ162HejwmqttAtws+bAqwA96XGAuiz1sb/mHipSS9qSnADqLH7eMpwE7By6goux2esQzp7BR0FK67G8Rlfbsg6e3r04mOiqXud+icHklnvCadcUFnRNSrayNKNkZnR4N00GbGic7OBumgHowRnV0N0tkFMCcTndDXz08/Z/p99u8BKOMsV/bjr58b/Dcvmq63MMdpOoi+AnnE+hjLbhftYHqLcxrm/x6EOiX8kbx3xXAVyW4JyW47lMXIzuCfBNmdT7LDdrFt74ayHVS2B8p2UtleKEMcWJZAG/Ad6xzWN7gRUY/Hq33wvkR/RX853vAPJ71trjJe7SN62PbsZ3Kx9j1Ujd7Ul+P3C3qqH45MtEyRvuEyG1N+9kEqQ9+4l8rQn+2hMrTvk+AZcYbaxDtgkT/Wb+RvE5WpnbPqq+kplaVQNkll2GaOb63NcwlP9rOdNoME++5zputcnT8rf8N+fLvAbWUPiLIM/4fP724L+hSUI5ZlvwHxzhtDDU7RuaAmnQsEHcaFBwtxjsh+1+A/QWMI+rISNnu1yX8PvGR/V9H/XB3r70K+F/lSvjDmfsnB39n6xafe9dzysmOE5zsvEPA1feeVKmdmtNX9knupDPNexoO6X7Li2HVljPwQ/6iAPwvgyvSFwvXmhnCxz62LK62Iy+69xNiH45tU4MJxyTuFkRKuBwtw8eeIsT77sN0FuHjn5YOijRyXMNxcgZtpjyS9bWNfVtFPRucaDP+waEOV2E3JVo017Mex7qgoY53fI+jsEXQUrrRBXJwvbSKPqXT4fOI5TXp5Th2esX5KZZsFHZ4zZ89j+fPzl5Odo/lBvcf5NscFBr8D5mO7aD6GtL3YknM6Ze/qOz2SzkU16Vwk6LSd/+aczu4G6aBvuojo7GmQDtrbGNHZ2yAdHBd5LpAKHjKd/QLZwT4oU3Zpchok+CVgB1907AB5xPoYa6ncFNP7bYrHK8aBMqdjuIpk9xWSHc7tlOzYhxj8CSC73y/hQzC23E1lKI89VLYfyhAHliXQBnzHOof1DW5E1DP5Wn89DO/byOkY/uGkt81V4oKHiR62PfvxvOSRavSmcjqPCnqqHzCngzJF+oaLczroZ3dRGfrG/VSG/uwhKkP75pzOroI2cTyt+PNy4bMVc+6qRs+NObF9VWNO/r5AE3FiE7g4PzcbsdB4TTrjgs4LJRYaJzo/KrHQD0rGQjyeG/xXV0zX6yw58NxmLDSU05jNWGjeku62VI2F9oHs5pPskDbbNsqJYyGMUTgWQlnxeqOVJdAGfOetqbLcsB6PVxVjk+hYyPAPJ7X0Y2q8UjGiGq9qxnpTsdAjgp7qB4yFUKYqLvJioZTK0DdyvIP+LJSLzZ45FkoTv01eLIR18W9bU8L9FbymZLBrwc5eldvZiMBvl9yrfMr9QPcnyFZRLpy/LBs7YP09xE8TY5Na6+Z8VdkcNdbnNdE9gg6P6exfT1yi+UH/ivEA+1eD/wj0+8nUZ0ib/STyzDFa2f48PZLORTXpXCTotB3TcIzWVkzD+ap9DdLB8XKM6DzUIB0chzhGe1Dw8Pw+GrKD/VCm8vWcrzL4/xvs4HzHDpBHrI8x2m7RDqa3nGK0imOijNEMV5HsVpDsdkOZkh37EIM/HGR3cQkfgmPyXipDeeyjMsxlIA4sS6AN+I51Dusb3IioZ/K1/noU3rcRoxn+4aS3zVVitNj8kbXvsWr0pmK0zwl6qh8wRkOZIn3DxTGal/dA3/gIlaE/e5jK0L45RttT0CaO0ZTut7jfIzpfZfiHk145VtEtFQupcZjHJqyr+obzVWoviMq5Kly7G8Tl7SfjWEjtW9vh0Dk9ks54TTrjgk7b+6RnK1/VVsw1RnTairliY6GP0Xj+EJTFjOcG/+CF0/U+4czjeK3oIcCXCPiTA/TuolioYv5DxkK8BhWS3d0kuz1QFiM7g/8UyG6NIzu2bRx3OF8VGydxbKrWqPCdF39zDIn1eLyqGJtEx0KGfzjpbXOV8So2f1Qz1puKhR4T9FQ/YCyk1usQF8dC6Gd5XzX6Ro530J/xuh7aN8dCuwvaxLGQ2jPGuAbhXQq43kLlBr83t6/M1nZTzkrtU87gXn9uN1w/Duuuq/r+TnjGMqQTGzvtbBBXPw6bpsPvysRhbcVH40TnhZaTCuVm/1NETsrLzRr8z0As8XUnlojJSXlxmMH/vzOYkwrJ7lsRcZgnO4N/EcjuT0rEYf2c1DSf+A7x93NS4ZyUF4cdDDkpxR/jio3DDP5Z8hsV4ybpN/hsUj9e667L+pP9zgI4LisbY+1qEFc/Xpumw+/68VozdKrEa0edO/0ex6Cy8dojy6frHZ3jbDNeOyanMZvx2rEku6rx2n0gu1eQ7JC2d1cBx2tqX7uK5XgcLJs3w/o/ankzNV4dqnkzbw2RYzL0Z5w38+K1JvJmsTkuphmK6y6hcoN/w7nTOH+e8mbq7H4G9x/6+bUXTH6N72RA3Byvlb3f6nTBs6IzXpPOuKAzIup1Av8bHX7n3dPE8dqDDdJBmx8nOi+0dc5QzLGS/Jta5/RiDoP/eYg5LnPitabWOd9O8Vqb65wh2V3ZULz2YyC7VY7s2LZxbGT/0l/nPPDrr3OG4zXv/ij0jU2tcz5Y0CaO15A/764he5cCLo7DDP6D5DcqxjHSb/C+tBTgWf8r3qURHa8Z/qa+Uqr6LoV33jlKvtMM47yzAI7LvLhQzRd3NYjLi6P68Vo3HS9ea+tezXGi01ZcOEZ02jrbEBuvbaCYo+pZlaffNF1vs5Mj4nzOXsCXCPiTA/S2kd/FcaKu3zVc7HdZdtsDc/nYc5QGvwlkt4tkh7TZtlFOu6gMx1SO5Zrce4v1WW5qLlLz3Gt0vGb4h5Na+jE1XqnzpWgXHK9VnD9MxWuxd1hgvKbuBkVcXryWUhn6xn1Uhv7MOy/H8drOgjZxvJZCfR5vdgjeVY5LjUvzRBtL9NGCWB00/MNJr7yr6KC6k0ON1/P/9d9P5M/5Z4/OWXXL8luvvO7ad5y/6o6bF15/1fIr3nvLtVdct/Cqq9676uabkWkkdAS8x3L8MYw9bxLvEceDBY1hZcDOirlkD3GtIFzqkj3DtacAF1/YpwY3/ntu0sunHfadE4EHDS3E10XEl1p88Zw8KudHCRfWDyVcQrg+RriwPi8uYrKI+WR5eXhCDhT5+jjxFTqEnv17pADXBwlX6HKf7N+jBbh+nXCpSTj/PTfp5ZPl5eHJ/j1WwNcniK/Q5pvs3+cKcL2PcKnNO4br8QJctxIurI918e+5SS+fLC8PT/bviQK+VhNfj0PZE1SG9S4lOmUnaVh/piZplxKdJxqk8wTAjEG97O8noQx964h4ZzRs8H8K3reRMDH8w8RLSXpTg/9TRI/bxwmTpwUvo6KMkxxPCzpPCzoK14MN4nqS2pNC2Vj+/PxFQDQJq3qZzUdhEtY578Czij2eoDaqOEZdRtqhdg0JeMQ3yPA5T4clvZ91fULUV7hxPPUSHfOSXvtqw0YMf1MXAj9J9Lh9bCNPCV5GRRknLZQtPiXoKFx7G8TFF+2lUDaWP2f6/JLzumlWtZEbwUZedhDayL9pwEYwhoqxkTqXRyI+4wffIf6mbETFsp6NPCl4GRVlvLFe2eKTgo7C9XCDuGJt5LUN2chbwUZ+pkUbMXnH2ojBv74BG8G4OcZG6iTDEJ/xg+8Qf1M2oi5N82zkYcHLqCjDOROWIR1vcRxxPdYgrlgbOashGzkTbGTxQWgj55e0EcV7G3Mvlb9aBM8hGXkf4Fkk2qPmeIuoPSmUjeXPz18ydJ7mR+lI9mzzd15YPxF0ZKWjIwfDwupVNelcJei8UDbCXUV09jdIB8eVMaLzcIN00FfGXlD7HrKDR6BM2cHq/HmQ4P9g2XS9Gx07COUsYy+oNfhbcxo1Nx7JhVXDVSS72xoaZx4F2b2/hA/BmJ59PMpjP5XhmMx5X5VfxXesc1jf4EZEPZOv9RfmLdtYWDX8w0lvm6vEWrEHP619T1SjN7WwquYSqh9wYRVlivQNl7ewypf1o298jMrQnz1KZWjfMZf1Y5u8jXBlLuuf6U1mdS/rL4oXOY7fL3hRffNJeMYypON9iANx7WwQl60x9DeZ9b47GA8F/KjEQntKxELZj8dzg78YxvOHZiAWeuwgiIUebygWOhVk91Q/FvJ+h0ws9Hg1elOxkFrDLhMLqTXtF0IsNCD4Qzi0PZVPSsS7jkOPacwRdX+D+MaydxKNsjmgdwp+W8zrDsTa16GS1+U19Dq52JiYp+YGxuh4fCY2ML4T3jW0iXbA64cHHXoV1/LmGD1vbxfSy/zpUNLbh0UfQkEa2F8hm6+6n3J/AS5vPyWvAz5cgIv3U4Y2Lnfxdf6B/zI//P+f1w1jewGfO28a5tn8mW0K5fD8XhKC8z4EVOdDOYgvSbTt8UcR634ISPVD6MM8hyW+jmAfhfaZ7hNtidFZ78M6ip+yfZoC3E6Am3N+GG6PgFO0sr/Vh8U5Fp+b48jkfOPK7jZi/d3wjGXZb0C88w5nGJyic3pNOqdH0hmvSWdc0BkR9TqB/40Ov2M6SjasF03QSQFmnOi0ddBtjOi0levg3MBOwUNmMy8/f/o925o3XvCh9z++YLrecTlOtUc/9IGr2ANoBv/jOQ0bDypemBJ1sV5Idq8m2akDaJ7sDP7zILufcmTHtq0+dK/ODPDhNBwbeG9d2QNo6jKIH5UDaN4FT4fCATQ11infyAfQ0J/xATS075gP+XkH0NRYPv9f/70if54+XHX+qjvecsV11151xS3X3nD9ilU33brq5lsGAbMaOdjDsyfGq6FCvw79PYfKNlH5cgGHP280rXnFQXTka/iHk95eqGI56kSXijL4qh6sq66q+BQ8YxnS2SvoKFw7GsRleqOuKetf5dlN52D4BM4L7ZPNoWjlcopWUiiLiVYM/nKIVt5O0UoKtHmn/U7Alwh4jvQMfhVFehWzbjLS49V39HVj+XPWzqsjZIc+LSS7cZDdu0h2SJttO4Uy9i/q2h81Y0ccWJYk/uq8ighmYNdCdKQ3E7sWUnjHkV7FyHIq0lORpeoHjPRQpuokrneV5yYqU9dYKH+2k8rQvmMiPWxTTKRnujUh6FjZdijbTGUPiDZndvdhsjv8XPRyaoeVYTvwHdvIcsGPojOZPw9SGyfI16VQp4RunTZCdAwH4t5REXesXYbiBuRrWJQNRvDyvRePv+7Z9B8nOlTfeOF3cwA/6jLCLxfwNcecN44AjYRoWxmOhzuobC6UGQ9Z1vI1xF/FlaE3xshP2T6W8acoy8aaiGtzRVxHJd16hbZj9od+ZEv+PJL02jTbSQrv25hvpfnzcNIrgyrjV0r0Qj6LfQTWHRVld8Iz+5YB8W6Og2uiQVw2Bqh+5vnWhKAz4dA5XfCs6IzXpDMu6IyIep3A/0aH3zEdJZuZzqxPNkgH9WCM6GxpkM4WgOH5VmjO8DTNGfAa8pg5g8H/5dLpel9wYhfkEevj+LJZtIPpfYlikIpji5xv8e6KkOy+TLLbDGUxsjP43wLZfcWRHdu2ut5KzbcmqQzjBM4plZ1vYf0ftfmWGuOtfbur0Zuab6l8ZJn5lropiudb6Gc3U1kKZTzfmoQyjrnQvnm+tbmgTTzfUvz1Y6G4WCj7nQVwXFY2frm/QVxejNKPhbrp9GOhpBKdKrHQPzcUC62C8fwHMxALDeT0ZjMWmru0uy1VY6ElILt5+bPKv7Fto5xSKlM5HRUn8by+7KkkrD8DO3SjY6GZ2KGrxqsmTgRm/3YLeqEds0qmKi7yYiHOPadQxvHOJJTtoDIvFtpU0CYvFuJ1d8wbM+yGZLq9CHsc2NmipWFaW4mPDVC2jcpi7RNxoHzRVyD8DdQGg391zneWa7x5pcY5J9E6av5H5T6tHfOArpWV0N8vZnxdtnKaDupL9sO8KepLkvgxlcFvFfCoc2n+PErw2TPHc0ofU3hn+qjkZTy2Ia8UAGLkhfBl5cV2j/LaTrgmBS6UoSevNH9uQ17IQ4y81B6XWHmZDJS8HiBcqcCF9riU4A33UKJ9guEbJPgzwSfwrTyej98gcKNv7BAObMewaMcIlWHdDO/2RQeeZyrPw7GmunEH/Tfug0D4N8G4cSXJRo3T3vqWynF4O0lxHN8TgWuzQ1vtndrj0Ea+eI8M781R8YbyAyabmn5grvIDmK9iP6D6SZ148mSl+kmtufPeuNicE9+sMAllXs4JT1pcGZiTYDtCPpvtAeczPNdR8wRP97wr+pXuqRyrsn/2G2pfjbIl9hvYt+w3qu6Ev5HmqG3shGf9Hky0fod2uH8EfNvNAd82tyTO98F4tBRsNEn0entNXzCofAHaO/sCzwdnv7J+k+3W27+q1s1RphwTmIyGBDzi4715vxIZE3i7y70cuDfvM3vI5L4t56NoD+THSPfUbQ7eHkiD3wH6/Ama4zXhN7ZQmdqj5Y05Ss/U7n0cQ7me+YGa+86jcym877ziOo+771yt89T0m1O5lH2CnuoHzKUUnd40XzXTfg3lFOPX1FqT2kPI9ow+gv1ACmXsPyYdeugjMBbfRravfGRszIL563+mPDTaF9s/2nhKZajvk1SGMuS4YS/womIeHLMRfi/4sC+SbJQue3Gs2sOK+1L5VhvU9YcicO1yaKvT8g85tJEvvgGKT5wrm1S2aLJpY76BcQHbouondU7Fk5XqJ3ULzENUFmu7fEJsEsrYrlG38STqFwPjNrZD5XhVPIBj/sdo7D5UcgW/D7b7Z/1cQQ9t5rOfK+gum8lcwZ+1lCvgPWL9XMH0cyhX8D8OgVzBHDgj9Q8N5Qqe7ecKpspmK1fwLwdJrmAs16+iXMHgBd3trporOB70+bD8uZ8rkL9+roDo9XMFs5MrGCPbbypX8PQhmit4Dfiw00g2/VxB2Cb7uYJytttEruC0wLiN7aiSKxiksTsFOD6vr2xK2Tyf139QyIL7L5QrMLyDBH8O2O6lJBvv69HZr6z98JxJ2Y+HK3VoqxuR9ju0kS++gZ1tWZ2hb3EclbaL9sm26/nM7BcjK9VPowSPslHnkFIqw3FoH5XhOMQ2j7qN4y7rZ5r0tiN23E0BL9/fsasAL8vT+5KFGjdS0T7vjJiyf/YbqKPsN7Bv2W9Yf6KuIjznCgz+mrwvat64KnMF/IUAvLdC6TfPrQz+Q+Db3h3wbXNL4rw+x1OUK7B+bCOmRntnX+D54OxX1m+y3WLfpIQrFbhQppwrMBkNJTqGMHw8Z74D+oBzBeiPOM5Af8Q5EHVbovJHmCvYQLkCdZNnBreadE/l9dHnsO4Z/GbQ5zsp3mjCb+ylMvQDfDOnGnOUno2K+jiGcj3zAzVvSozOFfAt9nVvco69xb6m35zKFagvBodujlYyVTeZe7mCNv2atx5SJFeeu2MbUypDH8F+AH0E+489Dj01v0Mf4fnI2PlGCngvp1yByrEqG2f7R33nuAFlyHHDw8CLinlwzEb47eDDniTZKF324lh1oz/exs/rMN7XfhUuL0+hvpLzqENbfSWHeUmSsE0qWzTZtDHfwLiAbVH1k/qChicr1U+jBI+yKWu7D1MZju9s16jb+6HNTwbGbWyHyleqeADH/NU0dnvr6U3c4hwau0N5PsPLse+XwHa/SbJR/lndgMz+A+HVl/e8+bqHy1sf8/RX0Ua+sC7TZj6tnrJdk00bttvk/EDJSvXTaNJr12yDsTdKs33G3iiN4y7rp1rbih13cV2Zb3X39l1kP5anl2dVuqduUFf27+XWUipDHWW/ob6yyXaGuorwnCsw+L+mXEHFL/nIXAF/vQ7zGUq/eW5l8P8Evu07Ad82tyTOZyJzBdaPbcTUaO/sCzwfnP3K+k22W+ybmL1g6usybGdDic5Z4p4XhP+ukytAf8R5zRTKOAeicvTKH2Gu4GXLDjzzWkz2PAZw3w+sn6Huoc9h3TP4Y5dN1/shxRtN+A3OW6qckTfmeF/NVesCSp/ND9ScS0fnCvirTxVzE+5Xn9R8p6bfnMoVqDmO6gfMFRR96czLFbTp17z1kCK58twd28j2jD6C/UAKZew/vH0MKheGPsLzkbExC655vpxyBWhf3rpYSmWo797cmuMG9UVhNefiL/y+CnzYKSQbpcteHFs0X+fcp5qve7i8PIX6cuxjDm3kC+sy7ZBNKls02bQx38C4gG3Ry9FkvxhZqX4aJXiUTVnbfYTK1Fcfle1iDoz1s2g/BdtuKH/4fSfPz3OFJr4GzXPrzwEvvA7P4wDCnwG2u4JkY18mTpI4nVBfQsavG6fUHtSJJyJweXuCnhTwTzi0kS+sy7SZT6unbNdk04btor2x7ap+QvgYWal+GiV4lI2VqX02ygY/R2WxX6Z+DNrM+qnW/1N4x7abCl4zvPx1eOULPd0rGrPS/Nkbs5T9s99A+2e/gTrKfgP7lv0Gf3Gc4TlXYPBvz/vC4k/Ukbq5gieJx8eBB6XfPLcy+PeBb3tHwLfNLYnznTmeolyB9WMbMTXaO/sCzwdnv7J+k+0W+4ZzOirvgDLlXIHJaEjAI75Bgr8J+oBzBeiPHife0R9xDKJyx8ofYa7gXsoVoO2OAdztpHvo09hfZD/WPYP/LOjzL+fPTfqNh6kM/QDH1mrMUXqm1opwDOV65gfMr6AutpErMPzDSW+bq+QKlP3h+MC5gop+cypX8JSgp/oBcwUoU6RvuLxcQZt+DeUU49cQnufu2Ea2Z/QR7AfQR7D/2O/QQx+Bsfi9ZPvKR6YCr4pZcH6+J49ZlI2z/aONs/2jvnPcgDLkuOFJ4EXFPDhmI/wm8GH7STZKl7049mkB/xTAPErtQV1/OgLXYw7tzwv4px3ayBfWZdohm1S2aLJpY76BcQHbouonhI+RleqnUYJH2ZS13SepDMd3tmvU7SegzfsD4za2A8dttt1HBa8YDxxquYKnwXa/RrJR/tnLFZSdr6MPezIClzdf8/RX0Ua+sC7TZj6t3sGUK1D95PlYJSvVT6NJr12zDc5kruBrLeUKbnuB5wpixnzUVYTnXIHBf5tyBagjdXMFTxGPmM+Imdcb/LPg2/484NticwUG/1cHQa4A7Z19geeDs19Zv8l2i30zW7mCv4vMFXBes+lcwZFvOvBclCt4rqFcwYvfNF3vezOQK0A/wLkCNeYoPVO5AhxDuZ75gZpz6ehcgeEfTnrbXCVXoOzPyxVU9JtTuQI1x1H9gLkCNRdBXAdjrqBIrjx3VznNsvMN9h9VcgXmIzwfmQq8RbmC9zSUK0B957gBZchxw1PAi4p5cMxG+B8DH/Y6ko3SZS+ObWK+7uHycgX/XsB/3qGNfGFdph2yyZnOFWBcwLbo5WiyX4ysVD+NEjzKpqztPkVlOL6zXaNuYw6M9bOpXAHHA0Xftee4Se2x8uYnRXtH0/zZ23Ov9hrtDNBBn4B9sjp/5r1Gp+ZyLoqpjXZNfV/Q9j6aovkgn51B3817XlDGeB6JxwY843IxjQ2Yi+I9Gd5dD1wX+2AoAM/7yQz+HOjjlSs1TuTBO/9VVp+xDXX1GW3jVmqrwS+bWX0+Yrb1mXUW9ZlzQkqfO0mvD6uTzznrINT/t/0I6f+qg1z/1VzC0/+iHAnrP8Zvs6H/ry2h/086NJX+W9tC+o/5RIS/1dF/JV9P/4vWCNMk3P6nqQzr7QzQQf3Hfmf9N/gPROq/0W5D/1FGrP/evCn7lZ3r8JoAxu+e/vN6bVP6/5IS+u/F3kr/ra0h/Td8nC//pKP/ygZ3w7u6a13YhqeoDOvtDNAJxfOs/wZ/T6T+G+029L/J+WtRnoHjebQNT/95naMp/f/BuQeerY/xjLt3h2PMOXZ1VoXPF6ozmynAGF4+s3k/5IaeoLm3ipFwT38bc14Pl2efRXdjpERb3Y3BvCSCT6vX4vmvuW2fa1WyUv00SvAoG2VbfMY99lwJn1VRd1co/VRn3FN459kunnHffm433n0FeMve4cp30OwV7VP2790JEXOOXek6+w2+A4nheS3a4H877wtb30AdKaHrci2a76rBc/hKv3ntzuC/Db7tdwO+bW5JnF+NHGetH9tYs2nyrpoiv8l2q86mdehvxKXWb9jOhhI91zV8fNb7WyKuU/6I7+NQ9zUpf8Rn7tBmcC36n2gtGm13DOD+jHSv6l2M/wL6/Jf5c5N+g+/DUncdeGOO0rNRUR/HUK5nfqDmGfDotWjDP5z0trnKWnTs/XQ1/ebUWrTKE6p+wLVodYYWcXlr0W36Ne8enyK58towtpHtGX2Ed/cO+w/v/j30ERiL/xPZvvKRuwXeESrDuhneDTTf8O5tL3uOXe2Z47jhUeBFxTw4ZiP84PLpei9d3o1T6bIXxxadM99H7VHnzD1c3vl676yooq3O7TAvSRK2SWWLJps25hsYF7AtFq3JxshK9dMowaNsytour2+rc+zKdjH/zvpZdO842+4+wSvGAwsEfW/s9u6g2UtlaNfIB7eRfRDi5Zj/lWC7ryfZNH0/Bc+Zyt5P4d3FV+Q3mHb/fopueNVPo0mvD+S9Iuq+FmWfnGPAeQbPR9SYo/Sz6Jti3riLd8tcSbmCpu+BZN1TcbOyf/YbseM6+w3sW/YbHB8yPOcKDP7MvC8s/kQdqZsr4HEcz9wo/ea5lcGvBN+2KODb5pbEuSTHU5QraGgcH2x7HC/ym2y32Dcx3ypCmXKuwGQ0lOg8Bd+/bPAXQR94uYIy8YLK3yl/hLmC9+V8cD43ex4DuEtJ96rmqe4Afb48f27Sb3ixNe9bVWOO0jO1NxDHUK5nfsD8CupiG7kCwz+c9La5Sq4gdu5e029O5QpUHK76AXMFKFN1f4+XK2jTr3k50CK58twd28j27OUT0Uew/9jr0EMfgbH4+yLmG7ExC843VlKuwLv7OfacLMcNaj7H40ZoT1PonOxq8GH3kGyavlOL9+GXvVPLy7EXndH17hnq36ml+0mdOfHu1PJsl3MMOL6zXaNu4/7yewLjNrZDrYWoeADH/Etp7FbfBK2aD1A2z3Gain13C1459t0ItvtQy3m+mPm6h8ubrxXl+Zh2P8/XDa/6KSbPh9+94FxBrH2yzaNu47j7UEu5gmMpV6B8gqd7RftpWPdiz5Cw3yibD1C6zn7D+hN1FeE5V2DwX6BcQcV7pGSu4HHiEfMZSr9DZ4L/EHzbFwO+rew549+KzBU0tH+79FlQzwdnv7J+k+1WjfEd+htxqTNgbGdDic5Zhs4L/GcnV4D+iPOa6I84B7JP0FX+CHMFz1KuAG13DOC+Sbqn8vroc1j3DP67oM9/TPFGE36D9zipnJE35ig9U+u8OIZyPfMDNefS0bkCwz+c9La5Sq5A2Z+a79T0m1O5gtj79zBXoOYiiMvLFbTp17z1kCK58txd3fmifIS3hsH+Y59DD30ExuLPku0rHxkbs+B+haMoV4D2xfZfNh+g5tYcN6j7ZNXdRHyf7PfBh41e2I1T6bIXxxbN1737PWPu1Kpz7sm7L6ToTi1lky3eNzG37Tt3i+7U4vjfu1Mr1nb5zjuVD1C2izkw1s+iPZtsu+obJRgPHGq5gmMunK73WpJNP1fQy2c/V9BdNpO5AtbPpnIF31rSjbefK5h+DuUK3pj3xcGcK1gOvu20gG8rmysYz/H0cwWzlys4H/pgNnMF1+d8FOUKVgRijrK5gptAny/On/u5Avnr5wqIXj9XMDu5guvJ9pvKFfynPGY51HIFt4MP+0Q/V9BDO2ST/VxBOdttIlfwiZZyBSto7PZyBcibN4+oewYB92SEziCsAdvdSbJp+gyCt/+x7TMI3t6r/hkE/24/7wyClyvAca6JMwg7I3IF6kzhSNJrD5gruJtyBU2fQfDuHfHOILDf8PIPM30G4XOUK6gY07d6BuGr4NueDPi2smcQPh+ZK+ifQeiVaVNnEH4nMlfAeQ6VO69zBuEZyhWEziB8jXSv6hmEvwN9/gOKN5rwG/0zCP0zCM8jz/9/oZ5BQB/BfgB9RBNnEJ4h21c+MjZmwTMIH6NcQWyu0Fuvm4kzCM+BDztsRTfO/hmEsE32zyCUs90mziCwfjZ1BuFrNHarNcyZ3legzmdy7HvUiul6P06yaXpfQcx83cO126FdtD7GtPv7CrrhVT/F7CvAnBjvR2h6XwHr527RjthxdzfgXRGxr8DTvaJ9Bd6dJN6+AvYbB9O+gpPyvjiY9xUsAd92SsC3ld1XcGqOp7+vYPb2FZwFfcC5AvRHbe8reGfOR9G+gvNI96ruK7gW9PmC/LlJv9HfV9DfV/A88vz/F+q+AnWXWVv7Ct5Jtq98ZGzMgvsKljj7Ctj+D6Z9BTeCD7uTZNPfVxC2yf6+gnK228S+gjsD4za2o8q+Ao4H9gq8aq9Rh/hFeO+7NMrnePsVVCyk1jljvq+Abbso/5/Xfj4VGVO3uRaPMqr77YCi+aDJRMVG+6hM3Zmr9pztBd5PpLGhA3DvIF47SS+vHdG20UB9hQv75WR4PgnKEX4fzSVRniX69YIRqJMADsRdUWcuwLbaT8WTGDspetlvWJQNRvDypVN/8/wt/3zyER2qb7zwO9bLuQL+HQLeZDVEvI8lUb/zle0abSvjtmMZ2p/xkNnsa4i/uRX5i5Ef4h8V8MsBrkxfHJV06wLqu9kr3tG7mcrQN7PfVr7Zyzmzf0O/nQIMr9kb/OcglvvdiLES4+c2vk3j4fK+Q1u0xy0l2mouy7wkSTgGUPZhsmljbPPWYItimhhZqX5Sa7acS9oMZfw9Km9fh/r2jbcHTelnU9+0mke5YxWbebpXFJul+XPZ2Iz9hnd/btncEdsZ6irCc+7Y4L9F433FnIvMHfOe00eAhzK5tr8D3/YnDeXv/nRm49zBtvecFvlNtltv78E+gUvNrdjOhhIdYxs+/j7M3zq5Y/RHPLdU5zuUP+L4HW0Gc8fz88nQSNJru2MA9w+B/BHqHvoc1r0pH3HRdL1nKXfchN/gvBL6AV4nUGOO0rNRUR/HUK5nfqDmd2Oic8eGfzjpbXOV3LGyPzXPrOk3p3LHsblqzB2rtXDE5eWO2/Rr3vy9SK6cy1VrqcpHsB/w9sbvceihj8BY3HyE5yNTgVfFLPsA7w/OOfCsbJztP3afaUzOmccN5cN4zEb4l4AP+0mSjdJlL44tWvf01sIej8Dl5YeK9rgxbbXHjXlJkrBNtriOM7ft9WklK9VPowSPsilru5wfjs0547oP66cX52c/tt2HBK8YDxxquYKTwHYXkWz6uYJePvu5gu6ymcwVsH42lSv4yjndePu5gunnUK7gorwvDuZcwbXg294S8G1lcwVvzfH0cwWzlyu4CvpgNnMFH43MFbw7EHOUzRX8Oujz9flzP1cgf/1cAdHr5wpmJ1fw0ZZyBV84RHMFnwEftq2fK+ihHbLJfq6gnO02kSvY1lKugOOBVODdJfB2kl4/FLPPTO1jQ3nwd7XV/iV1187mAB2Vg8h+ebOnfILB74uMqY12G/qOMmJ9Vz4b4Vneav6IsXKaP6t9jnxWC2VsNI3nXQJnxvt2Ghu2A9z9SXfZA1DGZ5lxj/NOKkMdQT6wn1APJgDG8A4S/G/C2PANshGlww/AO+4Dr8+QH6XXMfOa7Q7tov5n2sgX1mXazCfqg9GyMpNNG7aC/odtxfM12S9GVqqflK1wXHc/lG2nMu/uJPzWGp+xRN3Gs4msn9tFOybgHY8NE4LX588PUC7qQYHX0z3v7KXSvQdE+5T9s99A+2e/4X0THvuW/QbO9xMBz7kog/9LykWhjtTNRfH5ir3Ag9Jvnrsb/PfAt/11wLfNLYnzO5HjpvVjG3O2mRw32W6xbx4gXA8IXGr+xnY2lOgYyfANEvyzTi4K/RHvLUd/xGP+TkFX+SPMRb0kVxJ1PmkM4P436R76NBVLsu4Z/MvePF3v+5SLasJvcEyKfgBxhMYcpWdqnsAxFdYzP2B+BXWxjVyU4R9OettcJRel7E+dl6/pN6dyUWp+pPoBc1EoUzVf8nJRbfo1lFOMX1PngtQZJ7Zn9BHsB9BHsP/Y6dBDH4GxuPkIz0fGxiwPAN7Tab6B9sX2793VivrOcQPKkOMGvKtJxTw4ZiP8ceDDTiLZzMa9lB6u3Q5tb/1X0Va5eOYlScI2OdNzc4wL2BaLcjIxslL9pM6A8VpYrO1632Vnu0bdxnwv66cX52c/tt3QHSscD6wXeOcLvAY/AbgGCEf2vDp/HiT4N+TtwdjVcG4QPAzDO+7TTQJ+A8AYPwuSXj+2icqw3pr8Wem7wdXU9yOUvmN7WN83Q9mAgGfZpAIec0rWt6MEj3KysjVQZjRHCA/KO+P9xkXd/BT1LevXRsCl+vbD+fMgwZ/v6JfSl7XwjmXoyRz5WUA8YN0Fop7JV+mXwdXUrwVKv7A9rF8plA0IeJbNpIBPAcb6dpTgUU5WhnZpNEcID8o74/3VZ3bDof/qBP43XvkdzxMQ13LiZ6JBOtjuk4nOOigby5+zdl9B4wHKZEDU/UD+PEjwH4QY6Kr8eYGoP0H1rexqsLP3rQzXZx+MY8R8KkN5oM8JtRPhPxxo53uAz5udXInxVdPuRpXdoe+L8esIX9avs+9OoWwd4VoncKl5AMcIQ4nuA8M3SPC3Qx9wrgTHjw3E+5qSvKvxRPkRq5v1xd8sPPCs4oCNRFONYaqvRkX9DQFccwT/aLfc7wOJHg8Z3nQC85UpwAxDOcL/GvTVHSs1ziTAw7oAz0MB+M3Eg8F/XOiL5wdQ/zcRToP/JOBcXBLnhwI4P+3EGmky/TOcG+Fd2fGU4wmU4ySVIe88LqZAn2F/hehjGeo5000cfnlMLeKXxxsr2w7j1fr8eR7hK+mrB7y+ukzwG9tX65z2MS6rh3dwxNgIymPyzRrn3JI4t4kxXcUqJwH+7YF4JPtxPJL92C+jz0A7vIJiEqQ/n/i3cWK3sEc11huuemN95y/UWL8GIHisV7JBePYJGwU89iPH2Dje/AyV4TjLsdUaQSd2LF0Dbf38wm68Ew7e7PldxEdRjPfe/Jn98NOOH1Yy9GSu5ogoV15Hxf7gnILS2ZnWR2w/66PX1uxXdj7M+qjGD6WPHGd5epP9PH3EvNTeXB/VHJznHpsdflLBz2bRbh4fhgLwhm+Q4L/uxD1bBA/ePGGrgN8ieF5APGBdph3a33UBtcfgvxnpjxvKeRyl9B/lxvrvySj7sUy3CXiUVZo/jxI8ylfp/xYqU3kkz2ZjbcPqZnL4yMJuvE3n59hXG/x/LZmf83x1W/k5z1e3qasHa34OdTU2P3cb6Zfy6fMd/pU+Tgj+VV6J+x3rrU+K+ZoQfKl5zIRDZ2FNOgsFnbZzkAupPRuc9pTNhWD9DdSeDQ22R/FclFOdd/H0+5BvwzkMj3cG/6qLp+vNz5+9nGpZ3V2bdPPp5ZCy3wpof5K0EXPqdduZjDk5rsTxMiZniLqHY6fBJMRjG/JCe46ZMyq/4clX5ehGk15Zrqcy1LcJotNU/nXZwmL+1zvtLdIPzsUcRGt0sx4DsC5MQlnMGh37S6Sj/CX3MfpX7BdeszL4k3KfqmJHpQee3qQCXs0BlW6kVKby/C36kINabzZRmco7xuqNlyvEMdrGby9H1km6x0nUZ4QPra9MEJ4OvT8c3mO9O6jNHCMx7vcTvLVzKABv+DgWORdsZaWTE1M4f5l42FTAw0biweAvEDx48s9+Xkw4L+m1xRJ2M9ghfMYPvkP8w4nWj7Ek6tdh+Rk9pQfZj21Z2ZNaK/F8oLJzhWt+g7gsblAx7OlEp+y8COt786/xmnTGBZ2251+nE51NDdJBmxknOpsbpIN6MEZ00gbppADDe2fWCx6yceI9NM+bhDIVM/AZCIN/7C3T9W6keR76ijTR9HDc3yDawfRuzWmY/8M8bgl/JM85Ga4i2d1GslNrNZ7sDH4tyO79juzYtiehjNdZUB4c02+FMsSBZUnSm8/NfqxzWN/gRkQ9Hq8wD1xmrhhjG4h/OOltc5XxSuW5J+Ednx+5vxq9qfMj6gyl6gc8P4IyVec/zcaUn+WcAfrGrVSG/ozz9CmUnQTPSCPUJottFzj8qTgUYzeVb2Hdm+lYaWM1em6spPJDZWMl3n91sMZKyCfHSmVzrlh/g0NnvCadcUGn7dxuP1aKp5MCTGystLehWOkNMN7vp/EefUWaaHoYK20U7WB6nzsIYqUnItYTPNkZ/MtBdk87smPbnoSyfqzU3Yf9WGn6ORQrqXijzVhpY0GbOFZS/Kl4J/uNJXG/mFgK21ei714Zq5uGv6lYSsUlKpay9qXV6I1lunZ4Xg/j2PfAs9r/hP3VVP+p3Mxs9d9ENXpu/6mcVZP9h7ZVpv+UbZ4Kz1iG7fHiSqw/U3HlqUQnNMZ/h8Z4taaFYzzvGTD478GegWdojI/dF7AOeOY2N7TOP1D2XJO3dzn7ld13y/uVvHVrtae8k/T2Sdl1azzfeuJCzX8H8H5A1GXbRvhNgg+DT/O/bU8pw/C5F4P/PqzBnBvYbxc69xJah/2hsw6bJtM/b8wx+EkBnwKMt0Y/SWVYz1uHNbiaNvFKZRPYHrYJtYcX4cvu4WW9x1h2E+Fi+8p+FwhcHq8TNXjlfkyhbCvhMljUS2wP66XBH5XPl4r2G5vM2+h/bx1eydRbhy+SKee7UI4plXnr8EV7btgnrhc84Jg4U3PUlNqxDXgZELwa3kGCPx7m2T/3lm6cNl9KkjibVfMznHPxeWicm22PwOX50h0CfrtDG/nCukyb+bR6LdqW3CeHc222LdVPCB8jK9VP6l4XvmMydr68jcpi58tboc2snyrOirVdzEtxzkr5Kk/3Yscq77yJsn/2G2qMU7bEfgP7NiXeOQ/C8JxrNPiz876w+RfqSAldl7nGHcTj/cCD0m/OIRr8peDbzgn4trklcZ4XOc5aP7ZxTxvaO/sCzwdnv7J+k+0W+2aScE0KXChTjutNRkMCHvHx2aqLoQ/4TgX0R/cT77H5u0kqS6EM75+8PeeDz1tlz2MA94uke+jT2F9kP9Y9g/9l0Odfyp+b9BsplaEf4DhVjTlKz1R8hmMo1zM/YH4FdbGNnLjhH05621wlbxWbo67pN6dy4jsFPdUPmBNHmSJ9w+XdP9mmX0M5xfg1lScfTXrbOEll6CPYD6CPYP+x2aGXQj2MxW8n258U7YiNWSYB716ab6B9sf2jjbP9o75z3IAyTJPuduwAXlTMg2M2wn8YfNgako3SZS+O3SXg8Z7BLdQe1PVdEbi2OrTVPaK7HNrqfmPmJUnCNqls0WTTxnwD4wK2RdVPCB8jK9VPowSPsilruzuoDMd3tusUyvBe+jWBcRvbgeM22+4WwSvGAzO19y9NuttRNVewGWz34YM8V+Dl2/u5gml+inxsk7mC2H2ITeQKWD/V+lvsuNt1tjsiV1DnboqquQL2GwdTruA3D4FcwTfBt32poVzBb/dzBVNlk4RrUuBqI1fwB06uAP1R27mC5yJzBX/UUK7ge6DP/8XJFVT1GymV9XMF0fT6uYKkvl+bqVwB+oi2cwXPtZQreI+TK2D7P5hyBT8AH3bUJd04+7mCsE32cwXlbLeJXAHrZ1O5Ao4HeE9/9rsM3vFelq0EH+LD4E1PQnutQrmBY/L2414rtS9oKbTt2Et029BPTALtrUTb4N9wyXS9V+TPKtbhey1UrJMkvX6ZYRcnWgavBj6OvyRMK82fR5w2Zjh+8pIw3GIBxzjmCBnw+LZR1FNzzzTpprGFaEw6NFJRT9HYTDhRZuqswf0F5dtE2xLxbo6A3xJobyJoby3AOynwKF/j+SiOqSeT3vZWiQ2+MH7gWdlLyCaUXm1xeN9GvBftBWTelfzQf6j9kXyWgXVrk2hnR/xt/N0M79jHpvnfODdFGKvL+1MXCZ/JONEXIl83BXAuAZy8P1XpzCnwjsdir5+QH7WvcQvVU3cIJeKd6p91BDtJfC4WPIX+TgWeEA/e+Vrv/F5Tewp3jR949u5ytL83EO8Iy3el8NkM1m8+44v38AwIGNZvg7/U0W91LhD5uimA83JHv5XcXw/vWL+L7k/juZG6P03xjr6H36n+Yf1mf7RY8BT6e6PAE+JBrTupuz5j7qhW30sbSXp1Be+oPnn8wLOSL9/Trvb6qT156vspfEeT8XA96BJ/F0N94w3beEEA502OfjZ9H7v3DaFNTj3sv3mC1pg9/ND/GT6zhcOSsA7yfvU7QE4Xr9S8dJifgl+L5xjHOoQvSXSO8BA9x3hcE+cY+WxUB+hndnQnzfeUjWHdG/NntrGPwzzrIwGcSVLPNx0z3o23rbtble165374zgz1vRvjIYX2DAh4vqfc4D8Dtnlz63fXd/5R5ZRSgOCc0iSUDQj4snEsf69HrY94+qVyvaw3oe8h8Dd/DH4D9AGvW+HdtCnxvr4k76E7gNkW0TbYjpv+fqp9G4Xt/n5nbG36+zLe91M5j6TuGFb2YnBt3IE6k/dO8/dTlT6r86hGU/lePF/6gzO6+VH3LWPfsn4hrgHBx7X58yDBP+7oV9N3+PPdzGXvQW/xvPOLZvu8s/Vt2Xu6+Zy8+oZixvufkn6lUDYg6l6XP/M4+ZWSuRbP5orGKOPHy7WonCrrksrvGQ9bk145IPwNSbccDP7rkfGC8VVTPxeWXQ9WuWFvve5+Aa9yw6MEz/2CfyMub/3FZDSU6D4wfHz3039x4oXYPbNpBO/K7yp7s7pZX6zO7U3N8zlm9b6Dw3Vx7BkKwIfmn38j5MX+LJR7fTfhNPi/dfyBGlM/C+9YB1MBr/KR3n1iav7g3Q3QTDyfnDnbd7Tz+IH+kM+olr2jPVb/UYeuI/3H8fw+ounFsVwX6YT0P3RH+vcd/S+al19NOA3+hyVzX57+F8UIXozk3ctj/qbF+HzRbMfnrP9efF42zxur/6hDl1G8pe5PxrrX5M+DBH9ULtNY/cJ5Q9UYVOmQ53s5P6NiV+7H0DjD8xSDPwbk4MVbDX1z48Wz7c957Q39Od9xpPynd7eQ8p9qvGT/+ePQB15+xvsWdAzvsfaGNrWExhuc+/J4s96hyXXRrkPjjeHjseGnhbw6RCOUD+LxxuB/1vEHynd5403RfJ3zQeqeLTWX9+brBlfTPo9u+7taRbkyHm/QH/L3csp+VytW/1GHXp/rfz253v5wB3gx3AMCcpD+N5hFeZ/gPWr2/2AEH3/y5e9+89HzTnoPn3vJftZHh9fAf8SXn3jTX/6vG1/dFv5jP7/q62d8+5lvt4X/r+ctXzTnsU8e1xb+j/7VD//ok798zN+3hf+0zbd9fOSUffvbwr9n/v9z5r/fPO9tbeH/+mH//bnf/+2r7yrCvyB/HoLyAapzWP7/IJQNCXyDBP9LuY1ltnkFxUJzBb3s3Q0OXCfwv+IZ+bF3wwJ+QMAb7cMFvJVhfhl9OMKgvBDXMJQj/HvytlufzIM6Vn9U0J9H9BXf+G4Owc8X8Cp/nrXzneQ3se1l19Cz3xDVx3dIu44tfOCr793xg6Me/K9t2dojp7z2jUesfPXqtvD/25/41MuO/d2bRtrCP3fw2HVj+96+tC38Hz9p8KhPvfWCJW3hX/vcslPufNnx/9AW/jW/9bol/3Dh372iCP//AWknTlXBqwwA","debug_symbols":"TJ3LsjS7bpzf5Yw9aIIEQOpVPHD4qlCEQorwZaSX9yokwcyJ95fW+ZmoYiG7uhrd6z/+8T/+53/7f//8X/7l3/7Xv/+ff/zTf/6Pf/y3//0v//qv//LP/+Vf//2//9f/+y///m9//7//8Y/f9//sv/93/qd/7PGPf4q//9g//mn9/WfiPwv/8X/80/77T+A/if9s/OfUf84P/xn4j+E/E/9Z+A9WOVjlYJWDVQ5WGb/f/e+4/7X733n/u+5//f437n/z/nff/971xl1v3PXGXW/c9cZdb9z1xl1v3PXGXW/c9eyuZ3c9u+vZXc/uenbXs7ue3fXsrmd3vXnXm3e9edebd71515t3vXnXm3e9edebd71111t3vXXXW3e9dddbd71111t3vXXXW3c9v+v5Xc/ven7X87ue3/X8rud3Pb/r+V0v7npx14u/9cbvg9mwGrzhb80xP8iG3XAu5N+6Iz74W9i+f5XWMBtWgzdEw9/Ktj7YDefC1x6Ab2X/wBpmw1fzdzhfowCi4W/lOT7YDefC1zKA0WANs2E1eEM09MqnVz53Zfu6aM4PRoM1zIbV4A3RkA274VwYvfLolUevPHrl0SuPXnn0yqNXHr3y6JWtV7Ze2Xpl65WtV7Ze+euv6R9kw244F74eA4wGa5gNq8EbeuXZK89eefbKq1devfLqlVevvHrl1SuvXnn1yqtXXr2y98reK3uv7L2y98reK3uv7L2y98reK0evHL1y9MrRK0evHL1y9MrRK0evHL1y9srZK2evnL1y9srZK2evnL1y9srZK+9eeffKu1fevfLulXevvHvl3SvvXnn3yqdXPr1y9eD+YDasBm+IhmzYDQcwqwcLRoM1zIbV8LfyGh9EQzb8rbzig3Ph60HAaLCG2bAavCEasqFXHr2y9cp2E2maNcyG1eAN0ZANu+Em0py/hl559sqzV/56cJ0PvCEasmE3nAtfDwJGgzXMhl559cqrV1698teD/vvgXPh6EDAarGE2rAZviIZs6JW9V45e+etBzw+sYTasBm+IhmzYDefC14OAXjl75eyVs1fOXjl75eyVs1fOXnn3yrtX3r3y7pV3r7x75d0r715598q7Vz698umVT698euXTK59e+fTKp1c+vfK5K6/fr2E0WMNsWA3eEA3ZsBt65dErj1559MqjVx698uiVR688euXRK49e2Xpl65WtV7Ze2Xpl65WtV7Ze2Xpl65Vnrzx75dkrz1559sqzV5698uyVZ688e+XVK69eefXKq1devfLqlVevvHrl1SuvXtl7Ze+VvVf2Xtl7Ze+VvVf2Xtl7Ze+Vo1fuHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24ugdX9+DqHlzdg6t7cHUPru7B1T24uge9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHvXvQuwe9e9C7B7170LsHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B6N7MLoHo3swugejezC6B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwezezC7B7N7MLsHs3swuwez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qmEjr3dUNWzk9Taqho0ag/itUG8qatio8TysPr44iLVuHVD1Zr3zqQEir3dUNUB0sXrz4iAacRIX0YlBLLc64urNi+dh9Wa93akBokYjTuLnVu9maoCoMYifW72FqQGixvOw+rje7tQAUaMRJ3ERnVhudVKrjy9uYrnVqa4+vjiIRnRirVDbEudhdWy9YaqhoEYjfvV6nZ3q44tODGISN/E8rD6+OIhGpNum26bbptum26bbptuh26Hboduh26Hboduh26HboVv18fd20msoqHEQy20WTuIilpsXBrHcduEmnofV3RcHsdxO4SR+bt/7Qq+hII+qrHr+e2PjNRTUuImfW6wPq+cvDuLn9t3bew0FNS6iE4OYDysJvsfOXoM+HnUU1fNRpVfPXwxiEr96sw6oeh5YPX9xEI34uWUdZvV81lmvns8qp3o+y6J6HljdvetMVh/vWqw6dtdi1bEXN/GrbNd2V8deHEQjTuIiOrHc6vTVK+/F/bBaGpVVS180YlnUqa6WvujEz+Lgf5vETfwO6FQ51dIXP7dTR1wtfXESP7dT10619MUgJnETz8Nq6YuDaMRJpNuh26Hboduh23luNZvTOIhGnMRFdGIQk1huXngeVktfLLcsNOIkltsudGIQk1hup/DPLb43Cl6zOfG9O/CazWk04vxwFi6iE4OYxE08D+ePOIhGpNuk26TbLLdRmMRNPA/XjziIRpzEcquzvpwYxHKLwk08D/1HLLfaITfiJAaxVqht+UIhRm3LFwqNRpzEb4VRO/S9jMeos5M/4iAacRIX8TviUYeZQUziJp6H+0ccRCOWW53fvYhODGK51enbm1hudf2eH3EQPzerU/L1fOMiOjGI2VjTMvHdunvNxcT3YYjXXEx89+teczGNQUziV+93F+81F3Nx/IiDaMTPbVYNXx83OjGISdzEz+278fb6PbjGQTRiuZVx9fFFJ5ZbFn5uqyyqjy9+bqtOVPXxxc9t1TmrPr44iYvoxCAmcRPPw+rji3RbdFt0W3RbdFt0W3RbdFt0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbekW9It6Vb5sOqqrny46MQglltdO5UPF8/DyoeLg2jESVxEJwaRbptum26Hboduh26Hboduh26n1v1ypwaa/j65KDRirbALF9GJQUziJp6HlQTf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"},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"459713770342432051":{"error_kind":"string","string":"Not initialized"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2360858009427093503":{"error_kind":"string","string":"InvalidTimelock"},"2369193878689457446":{"error_kind":"string","string":"HTLCNotExists"},"2718955667607728260":{"error_kind":"string","string":"Function get_htlc can only be called statically"},"3380315280177356474":{"error_kind":"string","string":"FundsNotSent"},"3781809441605198943":{"error_kind":"string","string":"Function get_user_swaps_count can only be called statically"},"4493654309393309420":{"error_kind":"string","string":"AlreadyClaimed"},"4736483829072576196":{"error_kind":"string","string":"HTLCAlreadyExists"},"5029608433027800177":{"error_kind":"string","string":"NotPassedTimelock"},"7413154743021792023":{"error_kind":"string","string":"InvalidRewardAmount"},"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14576755381182599325":{"error_kind":"fmtstring","length":24,"item_types":[]},"14924807131364042204":{"error_kind":"string","string":"HashlockNotMatch"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16190783185788596410":{"error_kind":"string","string":"Function has_htlc can only be called statically"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16810041750452690220":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"16884080922827299127":{"error_kind":"string","string":"InvalidRewardTimelock"},"17552554873437466887":{"error_kind":"string","string":"SwapAlreadyInitialized"}}},"bytecode":"JwACBAEoAAABBIBqJwAABGonAgIEAScCAwQAHwoAAgADAGktCGkBJQAAAEElAAABqCcCAQRqJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAKQAARARqCeZnKQAARQS7Z66FKQAARgQ8bvNyKQAARwSlT/U6KQAASARRDlJ/KQAASQSbBWiMKQAASgQfg9mrKQAASwRb4M0ZLQABTCcATQQJAAABTQEnAUwEAQAATAJNLQBNTi0ERE4AAE4CTi0ERU4AAE4CTi0ERk4AAE4CTi0ER04AAE4CTi0ESE4AAE4CTi0ESU4AAE4CTi0ESk4AAE4CTi0ES04nAE0EDSkAAE4E/////ycATwQQJwBQBAQoAABRBAEAJwBSBA4nAFMEAScAVAQDJwBVAQAnAFYCACcAVwQAJwBYBgAnAFkAACcAWgEBJwBbAAEnAFwEAicAXQYIJwBeBAwnAF8EDycAYAQeJwBhBCAnAGIEWicAYwS7JwBkBL4oAABlAAEcKAAAZgABICgAAGcAASUoAABoAAEpJiUAAEVyKQIAAgAX8SiICioBAgMnAgQEACcCBgQDACoEBgUtCAECAAgBBQEnAwIEAQAiAgIFLQ4EBQAiBQIFLQ4EBScCBQQDACoCBQQkAgADAAACASMAAAJDJwIDBAQtCAAEAAgAAwAlAABFmC0CAAAtCwIDACIDAgMtDgMCACICAgUtCwUEJwIGBAIAKgUGAzsOAAQAAyMAAAJDKQIAAwD8WpQ3CioBAwQnAgMCUycCBQJlJwIGAm4nAgcCZCcCCAJyJwIJAiAnAgoCbScCCwJ1JwIMAnMnAg0CdCcCDgJvJwIPAmInAhACIS0IAREnAhIEGQAIARIBJwMRBAEAIhECEi0KEhMtDgMTACITAhMtDgUTACITAhMtDgYTACITAhMtDgcTACITAhMtDgUTACITAhMtDggTACITAhMtDgkTACITAhMtDgoTACITAhMtDgsTACITAhMtDgwTACITAhMtDg0TACITAhMtDgkTACITAhMtDgYTACITAhMtDg4TACITAhMtDg0TACITAhMtDgkTACITAhMtDg8TACITAhMtDgUTACITAhMtDgkTACITAhMtDgYTACITAhMtDg4TACITAhMtDgYTACITAhMtDgUTACITAhMtDhATJwID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LS0KFy4ACAAkACUAAFK/LQIAAC0KLh4tCi8iHAoeFwAcCiIeACkCACIAKzxNXi0IASQnAiUEEAAIASUBJwMkBAEAIiQCJS0KJSctDiInACInAictDhonACInAictDhsnACInAictDhcnACInAictDh4nACInAictDhwnACInAictDiYnACInAictDiAnACInAictDh8nACInAictDiEnACInAictDiMnACInAictDFknACInAictDFknACInAictDFknACInAictDFknLQ4kGS0LKhcAIhcCFy0OFyotCAEXJwIaBB8ACAEaAScDFwQBACIXAhonAhsEHgAqGxobLQoaHA4qGxweJAIAHgAAJEYtDFYcACIcAhwjAAAkKy0IARoAAAECAS0OFxotCFcTIwAAJFwMIhNgFyQCABcAAEJWIwAAJG4tCxoXJwIaBC0tCAAtLQoXLgAIABoAJQAAU6ctAgAALQouGC0LGRctAhcDJwAEBBAlAABUWy0IBRoAIhpeGy0OGBstDhoZLQsrFwAiFwIXLQ4XKy0IARcnAhgEHwAIARgBJwMXBAEAIhcCGCcCGgQeACoaGBotChgbDioaGxwkAgAcAAAlAi0MVhsAIhsCGyMAACTnLQgBGAAAAQIBLQ4XGC0IVxMjAAAlGAwiE2AXJAIAFwAAQhIjAAAlKi0LGBcnAhoELS0IAC0tChcuAAgAGgAlAABTpy0CAAAtCi4YLQsZFy0CFwMnAAQEECUAAFRbLQgFGgAiGk0bLQ4YGy0OGhktCAEXJwIYBB8ACAEYAScDFwQBACIXAhgnAhoEHgAqGhgaLQoYGw4qGhscJAIAHAAAJbEtDFYbACIbAhsjAAAlli0IARgAAAECAS0OFxgtCFcTIwAAJccMIhNgFyQCABcAAEHOIwAAJdktCxgXJwIaBBstCAAbLQoXHAAIABoAJQAAU6ctAgAALQocGC0LGRctAhcDJwAEBBAlAABUWy0IBRoAIhpSGy0OGBstAhoDJwAEBBAlAABUWy0IBRcAIhdfGC0MWRgtDhcZLQgBGCcCGQQQAAgBGQEnAxgEAQAiGAIZJwIaBA8AKhoZGi0KGRsOKhobHCQCABwAACZ7LQxZGwAiGwIbIwAAJmAtCAEZAAABAgEtDhgZLQhXEyMAACaRDCITXxgkAgAYAABBiiMAACajLQsZEycCGQQP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","debug_symbols":"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"},{"name":"redeem","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"swap_id","type":{"kind":"field"},"visibility":"private"},{"name":"htlc_id","type":{"kind":"field"},"visibility":"private"},{"name":"secret_high","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"secret_low","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"459713770342432051":{"error_kind":"string","string":"Not initialized"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2369193878689457446":{"error_kind":"string","string":"HTLCNotExists"},"4493654309393309420":{"error_kind":"string","string":"AlreadyClaimed"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14576755381182599325":{"error_kind":"fmtstring","length":24,"item_types":[]},"14924807131364042204":{"error_kind":"string","string":"HashlockNotMatch"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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"},{"name":"refund","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"swap_id","type":{"kind":"field"},"visibility":"private"},{"name":"htlc_id","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"4493654309393309420":{"error_kind":"string","string":"AlreadyClaimed"},"5029608433027800177":{"error_kind":"string","string":"NotPassedTimelock"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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"},{"name":"sync_private_state","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"344423948968719440":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"8992688621799713766":{"error_kind":"string","string":"Invalid public keys hint for address"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14067204867181196045":{"error_kind":"fmtstring","length":75,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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4iYa0YmHGES6DboNug26MUuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySahEcYxQO4iQu4iYa0YmHGMR8mHRLuiXdKkvGLNxEIzrxEIOYF2d1EjYO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxulSVjFy7iJpbbKXTiIQYxH1aWXBzESVzETaSb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG7j9yMO4iQu4iYa0YmHGES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9GNWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWL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26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptumW2XJ960xu/peG534uc0oDGI+rCz5fqNyV99r4yR+bqvcKksuGvFz+z7h39X32hjEz+37XG9X32vjIH5u2woXcRM/N6sLqiy5eIifm2GwfFhZcvFz81/hJC7i5+Y138qSi0783LzWrLLkYj6sLDk138qSi5P4uZ1as8qSi0b83E6temXJxSDmw8qSi4M4iYu4iUakW9It6ZbPrfpeGwdxEhdxE43oxEMMIt0G3QbdBt0G3QbdBt0G3QbdKku+++pdfa8XK0sufm7fX1Da1ffauIibaEQnHmIQ82FlyUW6Lbotui26VZZ8f4FpV99r4yF+bjkL82FlycXPLesyK0suLuImGtGJhxjEfFhZcpFuRrcvS9av5vtlSaMR/cOa75cljUHMD796q77XxkGcH9Z2+yLuRnRKRtE37Piqv1oi1/eOYFdLZOMibqIRnXiIQcyH3zFrpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxudcyGFRrRiYcYxHx4yq0O6hnESVzEz23W+f1esho/t++b5na1RDYGMR9+L1mNgziJn9vchZtoxHLzwkMMYrnVfPNHHMRJXMRN/Ny+r0jY1RLZeIhB/Ny+34Tb1RLZOIif2/4VLuImfm5f2+uulsjG83DUVZzCb9y6hak2x7W9sEbIQiceYhDzYeXDxW/curGpNsfGRdzEz63ucarNsfFzs5pk5cPFfFj5cHEQJ/Fz+zosdrU5NhrRiZ/b98RrV5tj4+fmNcnKh4uDOInlVsaVDxeN6MRDDOLndmo6lQ8XB3ESP7dTk6x8uGjEcrPCQ4yHVfMXa4S6iqruupWrzsS/J+AfVklfHMRJXMRvsKhJVklfdOIhBjEfVknXPUN1JjZO4iKWW823SvqiE8utZlYlfTEfVklHHdoq6awaqpKuu47qTGzcRCM68TRWD+LfvyocxElcxE20h1WF35+d3NUg2FgW33yrFXDXXUe1AjZO4iJuoj1c9f+t+S4jOvEQg5gP9484iJO4iHTbdNt023TbdNt0sxp3FdYIu7BG8MJDDGKN8G13teE1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"}],"outputs":{"globals":{"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Train"}},{"name":"fields","value":{"fields":[{"name":"contracts","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"user_swaps_count","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"user_swaps","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"Train::constructor_parameters"}}],"kind":"struct","path":"Train::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"swap_id","type":{"kind":"field"}},{"name":"htlc_id","type":{"kind":"field"}}],"kind":"struct","path":"Train::get_htlc_parameters"}},{"name":"return_type","type":{"fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"hashlock_high","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"hashlock_low","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret_high","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret_low","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"src_receiver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"timelock","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"claimed","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"reward","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"reward_timelock","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"Train::HTLC_Public"}}],"kind":"struct","path":"Train::get_htlc_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"user","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Train::get_user_swaps_count_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Train::get_user_swaps_count_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"swap_id","type":{"kind":"field"}},{"name":"htlc_id","type":{"kind":"field"}}],"kind":"struct","path":"Train::has_htlc_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"Train::has_htlc_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"swap_id","type":{"kind":"field"}},{"name":"htlc_id","type":{"kind":"field"}},{"name":"hashlock_high","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"hashlock_low","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"reward","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"reward_timelock","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"timelock","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"src_receiver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"total_amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"src_asset","type":{"kind":"string","length":30}},{"name":"dst_chain","type":{"kind":"string","length":30}},{"name":"dst_asset","type":{"kind":"string","length":30}},{"name":"dst_address","type":{"kind":"string","length":90}}],"kind":"struct","path":"Train::lock_dst_parameters"}}],"kind":"struct","path":"Train::lock_dst_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"swap_id","type":{"kind":"field"}},{"name":"hashlock_high","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"hashlock_low","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"timelock","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"src_receiver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"src_asset","type":{"kind":"string","length":30}},{"name":"dst_chain","type":{"kind":"string","length":30}},{"name":"dst_asset","type":{"kind":"string","length":30}},{"name":"dst_address","type":{"kind":"string","length":90}}],"kind":"struct","path":"Train::lock_src_parameters"}}],"kind":"struct","path":"Train::lock_src_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"message_ciphertext","type":{"fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"}},{"name":"message_context","type":{"fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext"}}],"kind":"struct","path":"Train::process_message_parameters"}}],"kind":"struct","path":"Train::process_message_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"swap_id","type":{"kind":"field"}},{"name":"htlc_id","type":{"kind":"field"}},{"name":"secret_high","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"secret_low","type":{"kind":"integer","sign":"unsigned","width":128}}],"kind":"struct","path":"Train::redeem_parameters"}}],"kind":"struct","path":"Train::redeem_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"swap_id","type":{"kind":"field"}},{"name":"htlc_id","type":{"kind":"field"}}],"kind":"struct","path":"Train::refund_parameters"}}],"kind":"struct","path":"Train::refund_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"Train::sync_private_state_parameters"}}],"kind":"struct","path":"Train::sync_private_state_abi"}]}},"file_map":{"100":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr","source":"use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"},"105":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"108":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr","source":"use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"},"110":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/notes.nr","source":"use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"},"111":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/storage.nr","source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"},"113":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr","source":"use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"},"114":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr","source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"},"115":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr","source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"},"116":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr","source":"use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"},"117":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr","source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"},"118":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr","source":"use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"},"119":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encoding.nr","source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"},"12":{"path":"std/convert.nr","source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"},"120":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr","source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"},"137":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr","source":"pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"},"149":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr","source":"use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"},"152":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification =\n        compute_note_hash_for_nullification(retrieved_note, storage_slot);\n    let inner_nullifier =\n        retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"},"157":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr","source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"},"159":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"},"16":{"path":"std/embedded_curve_ops.nr","source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"},"161":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"},"166":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"},"167":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"169":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr","source":"use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"},"17":{"path":"std/field/bn254.nr","source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"},"174":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr","source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"},"176":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/version.nr","source":"/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"},"18":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"},"180":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n}\n"},"19":{"path":"std/hash/mod.nr","source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"190":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"210":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/append.nr","source":"/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"},"213":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr","source":"/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"},"214":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr","source":"use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"},"216":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr","source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"},"217":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr","source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"},"220":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"},"231":{"path":"/home/ubuntu/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr","source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"25":{"path":"std/meta/expr.nr","source":"//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"},"253":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"294":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"},"309":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"},"319":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"},"332":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr","source":"use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"},"333":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr","source":"/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"},"334":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"},"335":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr","source":"use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"},"342":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"},"347":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"363":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"},"365":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr","source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"},"366":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            let T_N = serialized_t.len();\n            for j in 0..T_N {\n                result[i * T_N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"},"384":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"},"388":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"404":{"path":"/home/ubuntu/nargo/github.com/noir-lang/sha256/v0.2.1/src/sha256.nr","source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks::<N>(message_size, h, msg_block)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let new_msg_block = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, modulo)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    let num_blocks = N / BLOCK_SIZE;\n\n    // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n    // for the given message size with a lookup.\n    //\n    // These can be reasoned about as followed:\n    // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n    // - `states[i]` should then be the state after processing the first `i` blocks.\n    // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n    // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n    //\n    // In other words:\n    //\n    // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n    // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n    //\n    // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n    let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n    let mut states: [STATE; N / BLOCK_SIZE + 1] = [h; N / BLOCK_SIZE + 1];\n\n    // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n    // no matter the value of `message_size`.\n    //\n    // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n    let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n        message_size / BLOCK_SIZE\n    } else {\n        0\n    };\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, msg_start);\n\n        blocks[i] = new_msg_block;\n        states[i + 1] = sha256_compression(new_msg_block, states[i]);\n    }\n    // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n    if N % BLOCK_SIZE != 0 {\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, BLOCK_SIZE * num_blocks);\n\n        blocks[num_blocks] = new_msg_block;\n    }\n\n    // verify the 0 padding is correct for the last block\n    let final_block = blocks[first_partially_filled_block_index];\n    verify_msg_block_zeros(final_block, message_size % BLOCK_SIZE, INT_BLOCK_SIZE);\n    (states[first_partially_filled_block_index], final_block)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) {\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = msg_item << 8;\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n        }\n    }\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, 0);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], 0);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = msg_item << 8;\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u32) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = (item << 8) + b1 as u32;\n    item = (item << 8) + b2 as u32;\n    item = (item << 8) + b3 as u32;\n    item\n}\n\nglobal BIT_SHIFT_TABLE: [u32; 4] = [1, TWO_POW_8, TWO_POW_16, TWO_POW_24];\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item * BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        if shifts >= 4 {\n            0\n        } else {\n            item >> (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item / BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let mut msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks::<N>(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"},"42":{"path":"std/option.nr","source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"425":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/uint-note/src/uint_note.nr","source":"use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Deserialize, Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(\n        self,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n\n        let encrypted_log = note::compute_partial_note_private_content_log(\n            private_log_content,\n            storage_slot,\n            recipient,\n        );\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct UintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for UintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_anchor_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, UintNote, UintPartialNotePrivateContent, UintPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"},"43":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"46":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn len_empty() {\n        let empty: [Field] = &[];\n        assert_eq(empty.len(), 0);\n    }\n\n    #[test]\n    fn len_single() {\n        assert_eq(&[42].len(), 1);\n    }\n\n    #[test]\n    fn len_multiple() {\n        assert_eq(&[1, 2, 3, 4, 5].len(), 5);\n    }\n\n    #[test]\n    fn push_back_empty() {\n        let empty: [Field] = &[];\n        let result = empty.push_back(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_back_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_back(4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn push_front_empty() {\n        let empty = &[];\n        let result = empty.push_front(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_front_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_front(0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_back_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_back();\n    }\n\n    #[test]\n    fn pop_back_one() {\n        let slice = &[42];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_back_multiple() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_front_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_front();\n    }\n\n    #[test]\n    fn pop_front_one() {\n        let slice = &[42];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_front_multiple() {\n        let slice = &[1, 2, 3];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn insert_beginning() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(0, 0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test]\n    fn insert_middle() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(1, 99);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 99, 2, 3]);\n    }\n\n    #[test]\n    fn insert_end() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(3, 4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn insert_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let _ = slice.insert(3, 4);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.remove(0);\n    }\n\n    #[test]\n    fn remove_beginning() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(0);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn remove_middle() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(1);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 3]);\n        assert_eq(elem, 2);\n    }\n\n    #[test]\n    fn remove_end() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(2);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let (_, _) = slice.remove(2);\n    }\n\n    #[test]\n    fn fold_empty() {\n        let empty = &[];\n        let result = empty.fold(10, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn fold_single() {\n        let slice = &[5];\n        let result = slice.fold(10, |acc, x| acc + x);\n        assert_eq(result, 15);\n    }\n\n    #[test]\n    fn fold_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.fold(0, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn reduce_empty() {\n        let empty: [Field] = &[];\n        let _ = empty.reduce(|a, b| a + b);\n    }\n\n    #[test]\n    fn reduce_single() {\n        let slice = &[42];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 42);\n    }\n\n    #[test]\n    fn reduce_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn filter_empty() {\n        let empty = &[];\n        let result = empty.filter(|x| x > 0);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 0);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn filter_all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 10);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_some() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0);\n        assert_eq(result, &[2, 4]);\n    }\n\n    #[test]\n    fn all_empty() {\n        let empty = &[];\n        let result = empty.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 2);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_empty() {\n        let empty = &[];\n        let result = empty.any(|x| x > 0);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 3);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn any_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 10);\n        assert_eq(result, false);\n    }\n\n    // utility method tests\n    #[test]\n    fn append_empty_to_empty() {\n        let empty1: [Field] = &[];\n        let empty2: [Field] = &[];\n        let result = empty1.append(empty2);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn append_empty_to_non_empty() {\n        let slice = &[1, 2, 3];\n        let empty = &[];\n        let result = slice.append(empty);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_non_empty_to_empty() {\n        let empty = &[];\n        let slice = &[1, 2, 3];\n        let result = empty.append(slice);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_two_non_empty() {\n        let slice1 = &[1, 2];\n        let slice2 = &[3, 4, 5];\n        let result = slice1.append(slice2);\n        assert_eq(result, &[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn as_array_single() {\n        let slice = &[42];\n        let array: [Field; 1] = slice.as_array();\n        assert_eq(array[0], 42);\n    }\n\n    #[test]\n    fn as_array_multiple() {\n        let slice = &[1, 2, 3];\n        let array: [Field; 3] = slice.as_array();\n        assert_eq(array[0], 1);\n        assert_eq(array[1], 2);\n        assert_eq(array[2], 3);\n    }\n\n    // complex scenarios\n    #[test]\n    fn chain_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0).map(|x| x * 2).fold(0, |acc, x| acc + x);\n        assert_eq(result, 12); // (2*2) + (4*2) = 4 + 8 = 12\n    }\n\n    #[test]\n    fn nested_operations() {\n        let slice = &[1, 2, 3, 4];\n        let filtered = slice.filter(|x| x > 1);\n        let mapped = filtered.map(|x| x * x);\n        let sum = mapped.fold(0, |acc, x| acc + x);\n        assert_eq(sum, 29); // 2^2 + 3^2 + 4^2 = 4 + 9 + 16 = 29\n    }\n\n    #[test]\n    fn single_element_operations() {\n        let single = &[42];\n\n        // Test all operations on single element\n        assert_eq(single.len(), 1);\n\n        let pushed_back = single.push_back(99);\n        assert_eq(pushed_back, &[42, 99]);\n\n        let pushed_front = single.push_front(0);\n        assert_eq(pushed_front, &[0, 42]);\n\n        let (popped_back_slice, popped_back_elem) = single.pop_back();\n        assert_eq(popped_back_slice.len(), 0);\n        assert_eq(popped_back_elem, 42);\n\n        let (popped_front_elem, popped_front_slice) = single.pop_front();\n        assert_eq(popped_front_slice.len(), 0);\n        assert_eq(popped_front_elem, 42);\n\n        let inserted = single.insert(0, 0);\n        assert_eq(inserted, &[0, 42]);\n\n        let (removed_slice, removed_elem) = single.remove(0);\n        assert_eq(removed_slice.len(), 0);\n        assert_eq(removed_elem, 42);\n    }\n\n    #[test]\n    fn boundary_conditions() {\n        let slice = &[1, 2, 3];\n\n        // insert at boundaries\n        let at_start = slice.insert(0, 0);\n        assert_eq(at_start, &[0, 1, 2, 3]);\n\n        let at_end = slice.insert(3, 4);\n        assert_eq(at_end, &[1, 2, 3, 4]);\n\n        // remove at boundaries\n        let (removed_start, elem_start) = slice.remove(0);\n        assert_eq(removed_start, &[2, 3]);\n        assert_eq(elem_start, 1);\n\n        let (removed_end, elem_end) = slice.remove(2);\n        assert_eq(removed_end, &[1, 2]);\n        assert_eq(elem_end, 3);\n    }\n\n    #[test]\n    fn complex_predicates() {\n        let slice = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n        let even_greater_than_5 = slice.filter(|x| (x % 2 == 0) & (x > 5));\n        assert_eq(even_greater_than_5, &[6, 8, 10]);\n\n        let all_positive_and_less_than_20 = slice.all(|x| (x > 0) & (x < 20));\n        assert_eq(all_positive_and_less_than_20, true);\n\n        let any_divisible_by_7 = slice.any(|x| x % 7 == 0);\n        assert_eq(any_divisible_by_7, true);\n    }\n\n    #[test]\n    fn identity_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n\n        let mapped_identity = slice.map(|x| x);\n        assert_eq(mapped_identity, slice);\n\n        let filtered_all = slice.filter(|_| true);\n        assert_eq(filtered_all, slice);\n\n        let filtered_none = slice.filter(|_| false);\n        assert_eq(filtered_none.len(), 0);\n    }\n\n    #[test(should_fail)]\n    fn as_array_size_mismatch() {\n        let slice = &[1, 2, 3];\n        let _: [Field; 5] = slice.as_array(); // size doesn't match\n    }\n}\n"},"5":{"path":"std/cmp.nr","source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"},"50":{"path":"/home/ubuntu/Dropbox/WEB/aztec/nft-portal-example/train-contracts/chains/aztec/contracts/train/src/lib.nr","source":"pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"},"51":{"path":"/home/ubuntu/Dropbox/WEB/aztec/nft-portal-example/train-contracts/chains/aztec/contracts/train/src/main.nr","source":"//     @@                                    @@@\n//    @@@\n//    @@@        @@   @@@@      @@@@@         @     @    @@@@@\n//  @@@@@@@@@   @@@@@@      @@@@    @@@@@    @@@   @@@@@@    @@@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//     @@@      @@@        @@@@       @@@@@  @@@   @@@          @@@\n//       @@@@@  @@@           @@@@@@@@@ @@@  @@@   @@@          @@@\n\nmod lib;\nmod types;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use std::meta::derive;\n\n    use aztec::macros::{\n        functions::{external, initializer, view},\n        storage::storage,\n    };\n\n    use dep::aztec::{\n        protocol_types::{address::AztecAddress, traits::{Deserialize, Packable, Serialize}},\n        state_vars::{PublicMutable, map::Map},\n    };\n    use dep::sha256;\n    use dep::token::Token;\n\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use crate::types::events::{DstLocked, SrcLocked, TokenRedeemed, TokenRefunded};\n\n    #[derive(Eq, Packable, Serialize, Deserialize)]\n    pub struct HTLC_Public {\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        sender: AztecAddress,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        claimed: u8,\n        reward: u128,\n        reward_timelock: u64,\n    }\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts: Map<Field, Map<Field, PublicMutable<HTLC_Public, Context>, Context>, Context>,\n        user_swaps_count: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        user_swaps: Map<AztecAddress, Map<Field, PublicMutable<Field, Context>, Context>, Context>,\n    }\n\n    #[external(\"public\")]\n    fn lock_src(\n        swap_id: Field,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        timelock: u64,\n        src_receiver: AztecAddress,\n        token: AztecAddress,\n        amount: u128,\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n\n        let htlc_public_current = storage.contracts.at(swap_id).at(0).read();\n        assert(htlc_public_current.sender == AztecAddress::zero(), \"SwapAlreadyInitialized\");\n        assert(context.timestamp() + 1800 < timelock, \"InvalidTimelock\");\n\n        let hashlock_tuple = (hashlock_high, hashlock_low);\n        let sender = context.msg_sender().expect(f\"Sender must not be none!\");\n        let htlc_public = HTLC_Public {\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            sender: sender,\n            src_receiver: src_receiver,\n            timelock: timelock,\n            claimed: 1 as u8,\n            reward: 0 as u128,\n            reward_timelock: 0 as u64,\n        };\n        storage.contracts.at(swap_id).at(0).write(htlc_public);\n\n        // Transfer tokens from sender to contract\n        Token::at(token).transfer_in_public(sender, context.this_address(), amount, 0).call(&mut context);\n\n        // Track this swap for the user\n        let sender = context.msg_sender().expect(f\"Sender must not be none!\");\n        let current_count = storage.user_swaps_count.at(sender).read();\n        storage.user_swaps.at(sender).at(current_count).write(swap_id);\n        storage.user_swaps_count.at(sender).write(current_count + 1);\n\n        let hashlock = u128_limbs_to_bytes(hashlock_high, hashlock_low);\n        let log_msg = SrcLocked {\n            swap_id: swap_id,\n            hashlock: hashlock,\n            dst_chain: dst_chain,\n            dst_address: dst_address,\n            dst_asset: dst_asset,\n            sender: context.msg_sender().expect(f\"Sender must not be none!\"),\n            src_receiver: src_receiver,\n            src_asset: src_asset,\n            amount: amount,\n            timelock: timelock,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[external(\"public\")]\n    fn refund(swap_id: Field, htlc_id: Field) {\n        let htlc_public = storage.contracts.at(swap_id).at(htlc_id).read();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n\n        let refund_amount = if htlc_public.reward != 0 {\n            htlc_public.amount + htlc_public.reward\n        } else {\n            htlc_public.amount\n        };\n\n        // Transfer tokens back to sender\n        Token::at(htlc_public.token).transfer_in_public(\n            context.this_address(),\n            htlc_public.sender,\n            refund_amount,\n            0\n        ).call(&mut context);\n        \n        let modified_htlc_public = HTLC_Public {\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            sender: htlc_public.sender,\n            src_receiver: htlc_public.src_receiver,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n            reward: htlc_public.reward,\n            reward_timelock: htlc_public.reward_timelock,\n        };\n\n        storage.contracts.at(swap_id).at(htlc_id).write(modified_htlc_public);\n        let log_msg = TokenRefunded { swap_id, htlc_id };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[external(\"public\")]\n    fn lock_dst(\n        swap_id: Field,\n        htlc_id: Field,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        reward: u128,\n        reward_timelock: u64,\n        timelock: u64,\n        src_receiver: AztecAddress,\n        token: AztecAddress,\n        total_amount: u128,\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n    ) {\n        assert(total_amount > 0, \"FundsNotSent\");\n        assert(reward > 0, \"InvalidRewardAmount\");\n\n        let amount = total_amount - reward;\n        assert(amount > 0, \"InvalidRewardAmount\");\n        // Enforce reward >= 10% of amount: reward * 10 >= amount\n        assert(reward * 10 >= amount, \"InvalidRewardAmount\");\n\n        let htlc_public_current = storage.contracts.at(swap_id).at(htlc_id).read();\n        assert(htlc_public_current.sender == AztecAddress::zero(), \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        assert(reward_timelock <= timelock, \"InvalidRewardTimelock\");\n        assert(reward_timelock > context.timestamp(), \"InvalidRewardTimelock\");\n\n        let hashlock_tuple = (hashlock_high, hashlock_low);\n        let sender = context.msg_sender().expect(f\"Sender must not be none!\");\n        let htlc_public = HTLC_Public {\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            sender: sender,\n            src_receiver: src_receiver,\n            timelock: timelock,\n            claimed: 1 as u8,\n            reward: reward,\n            reward_timelock: reward_timelock,\n        };\n        storage.contracts.at(swap_id).at(htlc_id).write(htlc_public);\n\n        // Transfer tokens from sender to contract\n        Token::at(token).transfer_in_public(sender, context.this_address(), total_amount, 0).call(&mut context);\n\n        let hashlock = u128_limbs_to_bytes(hashlock_high, hashlock_low);\n        let log_msg = DstLocked {\n            swap_id: swap_id,\n            htlc_id: htlc_id,\n            hashlock: hashlock,\n            dst_chain: dst_chain,\n            dst_address: dst_address,\n            dst_asset: dst_asset,\n            sender: context.msg_sender().expect(f\"Sender must not be none!\"),\n            src_receiver: src_receiver,\n            src_asset: src_asset,\n            amount: amount,\n            reward: reward,\n            reward_timelock: reward_timelock,\n            timelock: timelock,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[external(\"public\")]\n    fn redeem(swap_id: Field, htlc_id: Field, secret_high: u128, secret_low: u128) {\n        let secret = u128_limbs_to_bytes(secret_high, secret_low);\n        let caller = context.msg_sender().expect(f\"Sender must not be none!\");\n\n        let mut htlc_public = storage.contracts.at(swap_id).at(htlc_id).read();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\");\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            sender: htlc_public.sender,\n            src_receiver: htlc_public.src_receiver,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n            reward: htlc_public.reward,\n            reward_timelock: htlc_public.reward_timelock,\n        };\n\n        storage.contracts.at(swap_id).at(htlc_id).write(modified_htlc_public);\n\n        // Handle token transfers based on reward logic\n        if htlc_public.reward == 0 {\n            // No reward: transfer amount to src_receiver\n            Token::at(htlc_public.token).transfer_in_public(\n                context.this_address(),\n                htlc_public.src_receiver,\n                htlc_public.amount,\n                0\n            ).call(&mut context);\n        } else if htlc_public.reward_timelock > context.timestamp() {\n            // Before reward timelock: amount to src_receiver, reward back to sender\n            Token::at(htlc_public.token).transfer_in_public(\n                context.this_address(),\n                htlc_public.src_receiver,\n                htlc_public.amount,\n                0\n            ).call(&mut context);\n            Token::at(htlc_public.token).transfer_in_public(\n                context.this_address(),\n                htlc_public.sender,\n                htlc_public.reward,\n                0\n            ).call(&mut context);\n        } else {\n            // After reward timelock\n            if caller == htlc_public.src_receiver {\n                // src_receiver gets amount + reward\n                Token::at(htlc_public.token).transfer_in_public(\n                    context.this_address(),\n                    htlc_public.src_receiver,\n                    htlc_public.amount + htlc_public.reward,\n                    0\n                ).call(&mut context);\n            } else {\n                // amount to src_receiver, reward to caller\n                Token::at(htlc_public.token).transfer_in_public(\n                    context.this_address(),\n                    htlc_public.src_receiver,\n                    htlc_public.amount,\n                    0\n                ).call(&mut context);\n                Token::at(htlc_public.token).transfer_in_public(\n                    context.this_address(),\n                    caller,\n                    htlc_public.reward,\n                    0\n                ).call(&mut context);\n            }\n        }\n\n        let log_msg = TokenRedeemed {\n            swap_id: swap_id,\n            htlc_id: htlc_id,\n            redeem_address: caller,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn has_htlc(swap_id: Field, htlc_id: Field) -> pub bool {\n        let htlc = storage.contracts.at(swap_id).at(htlc_id).read();\n        htlc.sender != AztecAddress::zero()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_htlc(swap_id: Field, htlc_id: Field) -> pub HTLC_Public {\n        storage.contracts.at(swap_id).at(htlc_id).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_user_swaps_count(user: AztecAddress) -> pub Field {\n        storage.user_swaps_count.at(user).read()\n    }\n}\n"},"52":{"path":"/home/ubuntu/Dropbox/WEB/aztec/nft-portal-example/train-contracts/chains/aztec/contracts/train/src/types/events.nr","source":"use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\nuse dep::aztec::protocol_types::address::AztecAddress;\nuse dep::aztec::protocol_types::traits::{FromField, Packable, Serialize};\n\n#[derive(Serialize)]\npub struct SrcLocked {\n    pub swap_id: Field,\n    pub hashlock: [u8; 32],\n    pub dst_chain: str<30>,\n    pub dst_address: str<90>,\n    pub dst_asset: str<30>,\n    pub sender: AztecAddress,\n    pub src_receiver: AztecAddress,\n    pub src_asset: str<30>,\n    pub amount: u128,\n    pub timelock: u64,\n}\n\nimpl Packable for SrcLocked {\n    let N: u32 = 13;\n    fn pack(self) -> [Field; Self::N] {\n        let zero: Field = 0;\n        let mut out = [zero; 13];\n        out[0] = 0x1A2B3C4D; // Event signature\n        out[1] = self.swap_id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n\n        out[4] = self.sender.inner;\n        out[5] = self.src_receiver.inner;\n        out[6] = self.amount as Field;\n        out[7] = self.timelock as Field;\n\n        let src_asset_byte_array = self.src_asset.as_bytes();\n        let mut src_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..src_asset_byte_array.len() {\n            src_asset_byte_array_filled[i] = src_asset_byte_array[i];\n        }\n        out[8] = Field::from_be_bytes::<30>(src_asset_byte_array_filled);\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[9] = Field::from_be_bytes::<30>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[10] = Field::from_be_bytes::<30>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_3 = [0 as u8; 30];\n\n        for i in 0..30 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n            dst_address_byte_array_filled_2[i] = dst_address_byte_array[i + 30];\n            dst_address_byte_array_filled_3[i] = dst_address_byte_array[i + 60];\n        }\n\n        out[11] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_2);\n        out[12] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_3);\n        out\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        assert(false, \"unpack not implemented\");\n        SrcLocked {\n            swap_id: fields[1],\n            hashlock: [0 as u8; 32],\n            dst_chain: \"000000000000000000000000000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n            dst_asset: \"000000000000000000000000000000\",\n            sender: AztecAddress::zero(),\n            src_receiver: AztecAddress::zero(),\n            src_asset: \"000000000000000000000000000000\",\n            amount: 0 as u128,\n            timelock: 0 as u64,\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct DstLocked {\n    pub swap_id: Field,\n    pub htlc_id: Field,\n    pub hashlock: [u8; 32],\n    pub dst_chain: str<30>,\n    pub dst_address: str<90>,\n    pub dst_asset: str<30>,\n    pub sender: AztecAddress,\n    pub src_receiver: AztecAddress,\n    pub src_asset: str<30>,\n    pub amount: u128,\n    pub reward: u128,\n    pub reward_timelock: u64,\n    pub timelock: u64,\n}\n\nimpl Packable for DstLocked {\n    let N: u32 = 15;\n    fn pack(self) -> [Field; Self::N] {\n        let zero: Field = 0;\n        let mut out = [zero; 15];\n        out[0] = 0x2B3C4D5E; // Event signature\n        out[1] = self.swap_id;\n        out[2] = self.htlc_id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[3] = hashlock_high as Field;\n        out[4] = hashlock_low as Field;\n\n        out[5] = self.sender.inner;\n        out[6] = self.src_receiver.inner;\n        out[7] = self.amount as Field;\n        out[8] = self.reward as Field;\n        out[9] = self.reward_timelock as Field;\n        out[10] = self.timelock as Field;\n\n        let src_asset_byte_array = self.src_asset.as_bytes();\n        let mut src_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..src_asset_byte_array.len() {\n            src_asset_byte_array_filled[i] = src_asset_byte_array[i];\n        }\n        out[11] = Field::from_be_bytes::<30>(src_asset_byte_array_filled);\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[12] = Field::from_be_bytes::<30>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[13] = Field::from_be_bytes::<30>(dst_asset_byte_array_filled);\n\n        // Note: dst_address omitted for brevity in this packed format\n        out[14] = 0;\n        out\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        assert(false, \"unpack not implemented\");\n        DstLocked {\n            swap_id: fields[1],\n            htlc_id: fields[2],\n            hashlock: [0 as u8; 32],\n            dst_chain: \"000000000000000000000000000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n            dst_asset: \"000000000000000000000000000000\",\n            sender: AztecAddress::zero(),\n            src_receiver: AztecAddress::zero(),\n            src_asset: \"000000000000000000000000000000\",\n            amount: 0 as u128,\n            reward: 0 as u128,\n            reward_timelock: 0 as u64,\n            timelock: 0 as u64,\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRefunded {\n    pub swap_id: Field,\n    pub htlc_id: Field,\n}\n\nimpl Packable for TokenRefunded {\n    let N: u32 = 3;\n    fn pack(self) -> [Field; Self::N] {\n        let mut out = [0 as Field; 3];\n        out[0] = 0x2D17C6B8;\n        out[1] = self.swap_id;\n        out[2] = self.htlc_id;\n        out\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        TokenRefunded { swap_id: fields[1], htlc_id: fields[2] }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRedeemed {\n    pub swap_id: Field,\n    pub htlc_id: Field,\n    pub redeem_address: AztecAddress,\n    pub secret_high: u128,\n    pub secret_low: u128,\n    pub hashlock: [u8; 32],\n}\n\nimpl Packable for TokenRedeemed {\n    let N: u32 = 8;\n    fn pack(self) -> [Field; Self::N] {\n        let mut out = [0 as Field; 8];\n        out[0] = 0x4F8B9A3E;\n        out[1] = self.swap_id;\n        out[2] = self.htlc_id;\n        out[3] = self.redeem_address.inner;\n\n        out[4] = self.secret_high as Field;\n        out[5] = self.secret_low as Field;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[6] = hashlock_high as Field;\n        out[7] = hashlock_low as Field;\n\n        out\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let swap_id = fields[1];\n        let htlc_id = fields[2];\n        let redeem_address = AztecAddress::from_field(fields[3]);\n        let secret_high = fields[4] as u128;\n        let secret_low = fields[5] as u128;\n        let hashlock = u128_limbs_to_bytes(fields[6] as u128, fields[7] as u128);\n\n        TokenRedeemed { swap_id, htlc_id, redeem_address, secret_high, secret_low, hashlock }\n    }\n}\n"},"6":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"},"62":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/capsules/mod.nr","source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"},"63":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, false)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"},"71":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"},"73":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/utility_context.nr","source":"use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"},"76":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/event/event_selector.nr","source":"use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"95":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"},"99":{"path":"/home/ubuntu/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/aztec.nr","source":"use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"}}}